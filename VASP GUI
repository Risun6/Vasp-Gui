#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
VASP Linux 一体化GUI（Tkinter 版 | 单文件可运行）
=================================================
目标：把 Linux 下常用 VASP 操作整合到简洁 GUI：项目管理、INCAR/POSCAR/KPOINTS 编辑、
POTCAR 拼接（本地已有赝势）、K 点生成、作业脚本生成与提交（本地 / SLURM）、
以及 OSZICAR 能量-步数监视与简单可视化。

依赖（尽量轻）：
- Python 3.8+
- tkinter（随 Python 自带）
- matplotlib（绘图）

可选依赖（提升体验，但不是必须）：
- ttkbootstrap（更美观的主题）
- pymatgen / ase（将来可扩展结构与后处理）

使用：
- python vasp_gui.py

说明：
- 本工具不包含、也不会分发任何 VASP 程序或赝势文件。请确保你拥有 VASP 许可，
  并在"POTCAR 面板"正确设置本地赝势库路径。
- 监视功能主要解析 OSZICAR（F= 或 E0= 行），用于快速查看收敛趋势。
- SLURM 模板可在 GUI 中一键生成，你可以直接提交或先手动修改。

作者：ChatGPT（GPT-5 Thinking）
许可：MIT
"""
from __future__ import annotations
import os
import sys
import re
import time
import json
import textwrap
import shutil
import math
import threading
import subprocess
from dataclasses import dataclass
from typing import Any, Dict, List, Optional, Tuple, Literal
from pathlib import Path

try:
    import tkinter as tk
    from tkinter import ttk, filedialog, messagebox
    from tkinter.scrolledtext import ScrolledText
except Exception as e:
    print("[FATAL] Tkinter 未安装或不可用：", e)
    sys.exit(1)

# matplotlib 放在 TkAgg 嵌入
import matplotlib
matplotlib.use("TkAgg")
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib.figure import Figure

try:
    import ttkbootstrap as tb
    HAS_TTKBOOTSTRAP = True
except Exception:
    tb = None
    HAS_TTKBOOTSTRAP = False

try:
    import pymatgen  # type: ignore  # noqa: F401
    HAS_PYMATGEN = True
except Exception:
    HAS_PYMATGEN = False

# === CODEX BEGIN: imports for twist/shift page ===
try:
    import numpy as np  # 数值与线性代数
    HAS_NUMPY = True
except Exception:
    HAS_NUMPY = False

try:
    from pymatgen.analysis.interfaces.zsl import ZSLGenerator  # type: ignore
    HAS_ZSL = True
except Exception:
    HAS_ZSL = False
# === CODEX END: imports for twist/shift page ===

try:
    import seekpath  # type: ignore  # noqa: F401
    HAS_SEEKPATH = True
except Exception:
    HAS_SEEKPATH = False

APP_NAME = "VASP Linux 一体化GUI"
APP_VER = "0.1.0-MVP"

# 配置文件路径（保存用户设置）
CONFIG_DIR = Path.home() / ".config" / "vasp_gui"
CONFIG_PATH = CONFIG_DIR / "config.json"


@dataclass
class WizardProfile:
    system_type: Literal["metal", "semiconductor", "insulator"]
    workflow: Literal["relax_scf_dos", "relax_scf_bands", "scf_dos"]
    encut_strategy: Literal["auto", "manual"]
    encut_value: Optional[int]
    k_mode: Literal["kspacing", "kpoints"]
    kspacing: Optional[float]
    kgrid: Optional[Tuple[int, int, int]]
    use_slurm: bool
    np: int
    slurm: Dict[str, Any]
    figure_style: Literal["AFM", "AM", "PRB"]
    emit_report: bool


FIG_STYLES: Dict[str, Dict[str, Any]] = {
    "AFM": {
        "font": "Times New Roman",
        "size": {"title": 12, "label": 11, "tick": 10},
        "linew": 1.2,
        "tick_dir": "in",
        "tick_len": 3,
        "box": True,
    },
    "AM": {
        "font": "Arial",
        "size": {"title": 12, "label": 11, "tick": 10},
        "linew": 1.4,
        "tick_dir": "in",
        "tick_len": 3,
        "box": True,
    },
    "PRB": {
        "font": "Helvetica",
        "size": {"title": 13, "label": 11, "tick": 10},
        "linew": 1.1,
        "tick_dir": "in",
        "tick_len": 3,
        "box": False,
    },
}

DEFAULT_POSCAR_TEMPLATE = """Si
1.0
5.430000 0.000000 0.000000
0.000000 5.430000 0.000000
0.000000 0.000000 5.430000
Si
1
Direct
0.000000 0.000000 0.000000
"""

EXAMPLE_SI_POSCAR = """Si example (diamond)
1.0
0.000000 2.715000 2.715000
2.715000 0.000000 2.715000
2.715000 2.715000 0.000000
Si
2
Direct
0.000000 0.000000 0.000000
0.250000 0.250000 0.250000
"""

EXAMPLE_SI_INCAR = """# 示例项目默认 INCAR
SYSTEM = example_Si
ENCUT = 520
PREC  = Accurate
EDIFF = 1e-6
IBRION = 2
ISIF   = 3
NSW    = 60
ISMEAR = 0
SIGMA  = 0.05
LREAL  = Auto
LWAVE  = .FALSE.
LCHARG = .TRUE.
"""

EXAMPLE_SI_KPOINTS = """Automatic mesh
0
Gamma
6 6 6
0 0 0
"""

# === ETA helpers ===
ETA_LOOP_RX = re.compile(r"LOOP:\s+cpu time\s+([0-9.eE+\-]+)\s*:\s*real time\s+([0-9.eE+\-]+)", re.IGNORECASE)
ETA_LOOP_CPU_ONLY_RX = re.compile(r"LOOP:\s+cpu time\s+([0-9.eE+\-]+)", re.IGNORECASE)
ETA_ITER_LINE_RX = re.compile(r"^\s*\d+\s+[-+]?[\d.eE]+\s")  # OSZICAR: "  N   E   dE ..."
ETA_F_LINE_RX = re.compile(r"\bF=\s*([-+]?\d+\.\d+)")

def _fmt_eta_seconds(sec: float | None) -> str:
    if not sec or sec <= 0:
        return "—"
    sec = int(sec)
    h = sec // 3600
    m = (sec % 3600) // 60
    s = sec % 60
    return (f"{h:d}:{m:02d}:{s:02d}" if h else f"{m:d}:{s:02d}")

def _parse_incar_int(path: Path, key: str, default: int | None = None) -> int | None:
    try:
        txt = path.read_text(encoding="utf-8", errors="ignore")
    except Exception:
        return default
    rx = re.compile(rf"^\s*{re.escape(key)}\s*=\s*([-+]?\d+)", re.IGNORECASE | re.MULTILINE)
    m = rx.search(txt)
    return int(m.group(1)) if m else default

def _oszicar_stats(osz: Path) -> tuple[int, float | None]:
    """返回 (已完成离子步数, 每离子步平均SCF迭代数)。"""
    if not osz.exists():
        return 0, None
    steps_done = 0
    iter_counts: list[int] = []
    cur = 0
    try:
        for line in osz.read_text(encoding="utf-8", errors="ignore").splitlines():
            if ETA_ITER_LINE_RX.match(line):
                cur += 1
            elif ETA_F_LINE_RX.search(line):
                steps_done += 1
                if cur > 0:
                    iter_counts.append(cur)
                cur = 0
    except Exception:
        pass
    avg_iter = (sum(iter_counts) / len(iter_counts)) if iter_counts else None
    return steps_done, avg_iter

def _vaspout_loop_times(vout: Path, take_last: int = 40) -> tuple[float | None, int]:
    """解析 vasp.out 最近的 LOOP 行，返回(平均单次SCF耗时(秒), 已解析迭代数)。"""
    if not vout.exists():
        return None, 0
    try:
        lines = vout.read_text(encoding="utf-8", errors="ignore").splitlines()
    except Exception:
        return None, 0
    times: list[float] = []
    for ln in reversed(lines):
        m = ETA_LOOP_RX.search(ln)
        if m:
            # 优先 real time
            try:
                times.append(float(m.group(2)))
            except Exception:
                try:
                    times.append(float(m.group(1)))
                except Exception:
                    pass
        else:
            m2 = ETA_LOOP_CPU_ONLY_RX.search(ln)
            if m2:
                try:
                    times.append(float(m2.group(1)))
                except Exception:
                    pass
        if len(times) >= take_last:
            break
    if not times:
        return None, 0
    # 使用中位数更稳，也可用均值
    times_sorted = sorted(times)
    mid = times_sorted[len(times_sorted)//2]
    return (mid, len(times))


# ----------------------------- 工具函数区 ----------------------------------

def which(cmd: str) -> str | None:
    """返回可执行文件绝对路径，找不到则 None。"""
    return shutil.which(cmd)

def read_text(p: Path) -> str:
    try:
        return p.read_text(encoding="utf-8")
    except Exception:
        try:
            return p.read_text(encoding="latin-1")
        except Exception:
            return ""

def write_text(p: Path, s: str) -> None:
    p.write_text(s, encoding="utf-8")

def format_bytes(num: int | float | None) -> str:
    """将字节数转为易读字符串。"""
    if num is None:
        return "-"
    try:
        n = float(num)
    except Exception:
        return str(num)
    if n < 0:
        n = 0.0
    units = ["B", "KB", "MB", "GB", "TB", "PB"]
    for unit in units:
        if n < 1024.0 or unit == units[-1]:
            if unit == "B":
                return f"{int(n)} {unit}"
            return f"{n:.1f} {unit}"
        n /= 1024.0
    return f"{n:.1f} PB"

POSCAR_ELEM_LINE_RX = re.compile(r"^\s*([A-Za-z][a-z]?(?:\s+[A-Za-z][a-z]?)*?)\s*$")
COUNTS_RX = re.compile(r"^\s*(\d+(?:\s+\d+)*)\s*$")
# 兼容:  -12.34   12.   .1234   -1.23E+02   3.4D-01
ENERGY_RX = re.compile(
    r"F=\s*([+-]?(?:\d+(?:\.\d*)?|\.\d+)(?:[EeDd][+-]?\d+)?)"
    r"|E0=\s*([+-]?(?:\d+(?:\.\d*)?|\.\d+)(?:[EeDd][+-]?\d+)?)"
)
# 备用：从 OUTCAR 也能抓（有时 OSZICAR 很慢才写）
TOTEN_RX = re.compile(
    r"free\s+energy\s+TOTEN\s*=\s*([+-]?(?:\d+(?:\.\d*)?|\.\d+)(?:[EeDd][+-]?\d+)?)",
    re.IGNORECASE
)



def parse_poscar(poscar_text: str):
    """粗略解析 POSCAR 的元素与计数。尽量兼容两种第6/7行写法。
    返回 (elements: list[str], counts: list[int])，可能为空。"""
    lines = [ln.rstrip("\n") for ln in poscar_text.splitlines() if ln.strip() != ""]
    if len(lines) < 8:
        return [], []
    # 寻找元素与计数两行：兼容存在 Selective dynamics 行
    # 常见：
    # 1: comment
    # 2: scale
    # 3-5: lattice
    # 6: elements OR counts
    # 7: counts (if 6 is elements)
    # 8: Selective dynamics? OR Direct/Cartesian
    elem_line = None
    cnt_line = None

    # 尝试 line6 作为元素，line7 作为计数
    l6 = lines[5]
    l7 = lines[6]
    if POSCAR_ELEM_LINE_RX.match(l6) and COUNTS_RX.match(l7):
        elem_line = l6
        cnt_line = l7
    else:
        # 也可能 line6 就是计数（没有元素符号行）
        if COUNTS_RX.match(l6):
            cnt_line = l6
            elem_line = None

    elements = []
    if elem_line:
        elements = elem_line.split()
    # 计数
    counts = []
    if cnt_line:
        counts = [int(x) for x in cnt_line.split()]

    return elements, counts


def unique_elements_from_poscar(poscar_text: str):
    elems, _ = parse_poscar(poscar_text)
    return elems


def find_potcar_candidates(elem: str, pot_dir: Path) -> list[Path]:
    """在 pot_dir 下递归查找包含给定元素名称的 POTCAR 文件，返回候选列表。
    常见目录层级（示例）：
      PAW_PBE/Si/POTCAR  或  potcars/PBE/Si/POTCAR  或  potpaw_PBE.54/Si/POTCAR
    策略：深度<=3 的广度优先查找，目录名包含元素精确匹配。"""
    elem = elem.strip()
    max_depth = 3
    queue = [(pot_dir, 0)]
    candidates = []
    while queue:
        d, depth = queue.pop(0)
        if depth > max_depth:
            continue
        try:
            for entry in d.iterdir():
                if entry.is_dir():
                    name = entry.name
                    if name == elem:
                        pot = entry / "POTCAR"
                        if pot.exists():
                            candidates.append(pot)
                    queue.append((entry, depth + 1))
        except PermissionError:
            pass
        except FileNotFoundError:
            pass
    seen = []
    unique: list[Path] = []
    for cand in candidates:
        key = str(cand)
        if key not in seen:
            seen.append(key)
            unique.append(cand)
    return unique


def build_potcar(pot_files: list[Path], out_path: Path) -> tuple[bool, str]:
    """将 pot_files 中的 POTCAR 依序拼接到 out_path。返回 (ok, msg)。"""
    if not pot_files:
        return False, "未提供任何 POTCAR 文件。"
    try:
        with open(out_path, "wb") as fout:
            for p in pot_files:
                pp = Path(p)
                if not pp.exists():
                    return False, f"未找到 POTCAR：{pp}"
                fout.write(pp.read_bytes())
        return True, f"POTCAR 已生成：{out_path}"
    except Exception as ex:
        return False, f"生成 POTCAR 失败：{ex}"


def gen_kpoints_monkhorst(nx: int, ny: int, nz: int, gamma_center: bool) -> str:
    lines = [
        "Auto KPOINTS",
        "0",
        "Gamma" if gamma_center else "Monkhorst-Pack",
        f"{nx} {ny} {nz}",
        "0 0 0",
    ]
    return "\n".join(lines) + "\n"


def apply_style(ax, style: str) -> None:
    """Apply a lightweight journal style preset to a Matplotlib axis."""
    cfg = FIG_STYLES.get(style, FIG_STYLES["AFM"])
    font = cfg.get("font", "Arial")
    size_cfg = cfg.get("size", {})
    for label in ax.get_xticklabels():
        label.set_fontfamily(font)
        label.set_fontsize(size_cfg.get("tick", 10))
    for label in ax.get_yticklabels():
        label.set_fontfamily(font)
        label.set_fontsize(size_cfg.get("tick", 10))
    ax.tick_params(direction=cfg.get("tick_dir", "in"), length=cfg.get("tick_len", 3))
    ax.set_title(ax.get_title(), fontfamily=font, fontsize=size_cfg.get("title", 12))
    ax.set_xlabel(ax.get_xlabel(), fontfamily=font, fontsize=size_cfg.get("label", 11))
    ax.set_ylabel(ax.get_ylabel(), fontfamily=font, fontsize=size_cfg.get("label", 11))
    for spine in ax.spines.values():
        spine.set_linewidth(cfg.get("linew", 1.2))
        spine.set_visible(True)
    if not cfg.get("box", True):
        for spine in ("top", "right"):
            ax.spines[spine].set_visible(False)


# ----------------------------- GUI 组件 ------------------------------------

class SystemStatsMonitor(threading.Thread):
    """后台线程：监视 CPU/进程以及关键文件增长情况。"""

    def __init__(self, workdir: Path, watch_files: list[str] | None, on_update=None):
        super().__init__(daemon=True)
        self.workdir = Path(workdir).expanduser()
        try:
            self.workdir_resolved = self.workdir.resolve()
        except Exception:
            self.workdir_resolved = self.workdir
        self.watch_files = watch_files or []
        self.on_update = on_update  # callback(dict)
        self._stop_event = threading.Event()
        self._prev_cpu = None  # tuple(total, idle)
        self._prev_sizes: dict[Path, int] = {}

    def stop(self):
        self._stop_event.set()

        if self.is_alive():
            try:
                self.join(timeout=2.0)
            except RuntimeError:
                pass

    def run(self):
        while not self._stop_event.is_set():
            stats = self._collect_stats()
            if self.on_update:
                try:
                    self.on_update(stats)
                except Exception:
                    pass
            for _ in range(6):
                if self._stop_event.is_set():
                    break
                time.sleep(0.5)

    def _collect_stats(self) -> dict:
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
        cpu_usage = self._cpu_usage_percent()
        loadavg = self._loadavg()
        files = self._file_stats()
        procs = self._process_stats()
        run_state, run_pids, suggestions = self._run_status(procs, files)
        return {
            "timestamp": timestamp,
            "cpu_usage": cpu_usage,
            "loadavg": loadavg,
            "files": files,
            "processes": procs,
            "run_state": run_state,
            "run_pids": run_pids,
            "suggestions": suggestions,
        }

    def _cpu_usage_percent(self) -> float | None:
        proc_stat = Path("/proc/stat")
        if not proc_stat.exists():
            return None
        try:
            line = proc_stat.read_text().splitlines()[0]
        except Exception:
            return None
        parts = line.split()
        if len(parts) < 5 or parts[0] != "cpu":
            return None
        try:
            values = [float(x) for x in parts[1:]]
        except Exception:
            return None
        idle = values[3]
        total = sum(values)
        if self._prev_cpu is None:
            self._prev_cpu = (total, idle)
            return None
        prev_total, prev_idle = self._prev_cpu
        total_delta = total - prev_total
        idle_delta = idle - prev_idle
        self._prev_cpu = (total, idle)
        if total_delta <= 0:
            return None
        usage = max(0.0, min(100.0, (1.0 - idle_delta / total_delta) * 100.0))
        return usage

    def _loadavg(self) -> tuple[float, float, float] | None:
        if hasattr(os, "getloadavg"):
            try:
                return os.getloadavg()
            except OSError:
                return None
        return None

    def _file_stats(self) -> list[dict]:
        stats = []
        for name in self.watch_files:
            if not name:
                continue
            p = Path(name)
            if not p.is_absolute():
                p = self.workdir / name
            p = p.resolve()
            info = {
                "name": str(p),
                "exists": False,
                "size": 0,
                "delta": 0,
            }
            try:
                if p.exists():
                    size = p.stat().st_size
                    prev = self._prev_sizes.get(p, size)
                    info.update({
                        "exists": True,
                        "size": size,
                        "delta": size - prev,
                    })
                    self._prev_sizes[p] = size
            except Exception:
                pass
            stats.append(info)
        return stats

    def _process_stats(self) -> list[dict]:
        # 限制输出 + 超时，避免在某些系统里 ps 卡住
        try:
            out = subprocess.check_output(
                ["bash", "-lc", "ps -eo pid,%cpu,%mem,cmd --sort=-%cpu | head -n 6"],
                text=True, stderr=subprocess.DEVNULL, timeout=2.0
            )
        except Exception:
            try:
                out = subprocess.check_output(
                    ["ps", "-eo", "pid,%cpu,%mem,cmd"],
                    text=True, stderr=subprocess.DEVNULL, timeout=2.0
                )
                out = "\n".join(out.splitlines()[:6])
            except Exception:
                return []

        lines = out.strip().splitlines()
        procs = []
        for line in lines[1:6]:
            parts = line.split(None, 3)
            if len(parts) < 3:
                continue
            pid, cpu, mem = parts[0], parts[1], parts[2]
            cmd_full = parts[3] if len(parts) >= 4 else ""
            cwd = self._proc_cwd(pid)

            in_project = False
            try:
                if cwd:
                    resolved = Path(cwd).resolve()
                    in_project = (resolved == self.workdir_resolved)
                    if not in_project:
                        try:
                            resolved.relative_to(self.workdir_resolved)
                            in_project = True
                        except Exception:
                            in_project = False
            except Exception:
                in_project = False

            cmd_lower = cmd_full.lower()
            is_vasp = ("vasp" in cmd_lower) or ("mpi" in cmd_lower and "vasp" in cmd_lower)
            procs.append({
                "pid": pid, "cmd": cmd_full.strip(),
                "cpu": cpu, "mem": mem,
                "is_vasp": is_vasp, "cwd": cwd, "in_project": in_project,
            })
        return procs

    def _proc_cwd(self, pid: str) -> str | None:
        proc_path = Path("/proc") / str(pid) / "cwd"
        try:
            return os.readlink(proc_path)
        except Exception:
            return None

    def _run_status(self, procs: list[dict], files: list[dict]) -> tuple[str, list[str], list[str]]:
        run_pids: list[str] = []
        suggestions: list[str] = []
        for proc in procs:
            if proc.get("is_vasp") and proc.get("in_project"):
                run_pids.append(proc.get("pid", ""))
        run_state = "running" if run_pids else "idle"
        if run_pids:
            suggestions.append(
                f"检测到 {len(run_pids)} 个 VASP 相关进程在 {self.workdir} 运行。"
            )
        else:
            suggestions.append("未检测到项目内的 VASP 进程，可检查作业或尝试重新启动。")

        for item in files:
            short = Path(item.get("name", "")).name
            if not item.get("exists"):
                suggestions.append(f"未发现 {short}，请确认计算是否已开始输出。")
            else:
                delta = item.get("delta")
                if isinstance(delta, (int, float)) and delta <= 0 and run_pids:
                    suggestions.append(f"{short} 暂未增长，可稍后再次检查。")
        if len(suggestions) > 5:
            suggestions = suggestions[:5]
        return run_state, run_pids, suggestions

    @classmethod
    def snapshot(cls, workdir: Path, watch_files: list[str] | None) -> dict:
        monitor = cls(workdir, watch_files, on_update=None)
        return monitor._collect_stats()


class EnergyMonitor(threading.Thread):
    """后台线程：周期性解析 OSZICAR，提取 F/E0 能量，供主线程绘图。"""
    def __init__(self, workdir: Path, on_update):
        super().__init__(daemon=True)
        self.workdir = workdir
        self.on_update = on_update  # callback(steps:list[int], energies:list[float])
        self._stop_event = threading.Event()
        self.steps = []
        self.energies = []
        self._last_size = 0
        self._last_pos = 0

    def stop(self):
        self._stop_event.set()
        if self.is_alive():
            try:
                self.join(timeout=2.0)
            except RuntimeError:
                pass

    def run(self):
        osz = self.workdir / "OSZICAR"
        outcar = self.workdir / "OUTCAR"
        while not self._stop_event.is_set():
            try:
                target = None
                if osz.exists() and osz.stat().st_size > 0:
                    target = osz
                elif outcar.exists() and outcar.stat().st_size > 0:
                    target = outcar
                if target:
                    size = target.stat().st_size
                    reset = False
                    if size < self._last_size:
                        reset = True
                        self._last_pos = 0
                        self._last_size = 0
                        self.steps = [];
                        self.energies = []
                    if reset or size > self._last_size:
                        self._parse(target, reset)
                        self._last_size = size
                        if self.on_update:
                            self.on_update(self.steps, self.energies)
            except Exception:
                pass
            time.sleep(1.0)

    def _parse(self, path: Path, reset: bool):
        try:
            with path.open("r", encoding="utf-8", errors="ignore") as f:
                if not reset and self._last_pos:
                    f.seek(self._last_pos)
                else:
                    self.steps = []
                    self.energies = []
                new_pts = 0
                for line in f:
                    val = None
                    m = ENERGY_RX.search(line)
                    if m:
                        val = m.group(1) or m.group(2)
                    else:
                        # 若传入的是 OUTCAR，尝试 TOTEN 兜底
                        m2 = TOTEN_RX.search(line)
                        if m2:
                            val = m2.group(1)
                    if val is not None:
                        try:
                            # Fortran 指数 D 替换为 E
                            e = float(val.replace("D", "E").replace("d", "E"))
                            self.steps.append(len(self.steps) + 1)
                            self.energies.append(e)
                            new_pts += 1
                        except Exception:
                            pass
                self._last_pos = f.tell()
        except Exception:
            return


class VaspGUI(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title(f"{APP_NAME} v{APP_VER}")
        self.geometry("1200x800")
        if HAS_TTKBOOTSTRAP and tb is not None:
            try:
                tb.Style("cosmo")
            except Exception:
                pass

        self.project_dir = Path.cwd()
        self.proc = None  # subprocess.Popen or None
        self.monitor = None  # EnergyMonitor
        self.sys_monitor = None  # SystemStatsMonitor
        self.run_status_var = tk.StringVar(value="⚪ 未检测")
        self.figure_style_var = tk.StringVar(value="AFM")
        self.emit_report_var = tk.BooleanVar(value=True)
        self.run_suggestion_widgets: list[tk.Text] = []
        self.overview_items = [
            ("__project__", "项目目录"),
            ("INCAR", "INCAR"),
            ("POSCAR", "POSCAR"),
            ("KPOINTS", "KPOINTS"),
            ("POTCAR", "POTCAR"),
            ("CONTCAR", "CONTCAR"),
            ("vasp.out", "vasp.out"),
            ("OSZICAR", "OSZICAR"),
            ("OUTCAR", "OUTCAR"),
        ]
        self.overview_label_map = {k: label for k, label in self.overview_items}
        self.overview_key_map = {k.lower(): k for k, _ in self.overview_items}

        self._build_ui()
        self.set_project(self.project_dir)

        # 加载历史配置（若存在）
        try:
            self.load_config()
        except Exception:
            pass

    # ------------------------- UI 构建 ----------------------------------
    def _build_ui(self):
        # 顶部工具栏
        toolbar = ttk.Frame(self)
        toolbar.pack(side=tk.TOP, fill=tk.X)

        ttk.Label(toolbar, text="项目目录:").pack(side=tk.LEFT, padx=6)
        self.project_var = tk.StringVar(value=str(self.project_dir))
        self.project_entry = ttk.Entry(toolbar, textvariable=self.project_var, width=80)
        self.project_entry.pack(side=tk.LEFT, padx=4)
        ttk.Button(toolbar, text="选择…", command=self.choose_project).pack(side=tk.LEFT)
        ttk.Button(toolbar, text="新建项目", command=self.create_project).pack(side=tk.LEFT, padx=4)
        ttk.Button(toolbar, text="首次向导", command=self.launch_first_time_wizard).pack(side=tk.LEFT, padx=4)
        ttk.Button(toolbar, text="创建示例项目", command=self.on_create_example_project).pack(side=tk.LEFT, padx=4)

        # Notebook
        self.nb = ttk.Notebook(self)
        self.nb.pack(fill=tk.BOTH, expand=True)

        self.page_inputs = self._build_inputs_page(self.nb)

        # 先把 workflow 会引用到的页面都建好
        self.page_run = self._build_run_page(self.nb)
        self.page_monitor = self._build_monitor_page(self.nb)
        self.page_post = self._build_post_page(self.nb)

        # 最后再建 workflow（里面会引用上面三个）
        self.page_workflow = self._build_workflow_page(self.nb)

        self.nb.add(self.page_inputs, text="输入 / POTCAR / K 点")
        self.nb.add(self.page_workflow, text="流程助手")
        self.nb.add(self.page_run, text="运行 / 提交")
        self.nb.add(self.page_monitor, text="监视")
        self.nb.add(self.page_post, text="后处理")

        # === CODEX BEGIN: add twist/shift tab ===
        self.page_twist = self._build_twistshift_page(self.nb)
        self.nb.add(self.page_twist, text="二维材料·滑移/扭转")
        # === CODEX END: add twist/shift tab ===

        self.protocol("WM_DELETE_WINDOW", self.on_close)

    # ------------------------- 页面：输入文件 -----------------------------
    def _build_inputs_page(self, parent):
        frame = ttk.Frame(parent)

        # 外层滚动容器，确保内容较多时仍可完整浏览
        canvas = tk.Canvas(frame, highlightthickness=0)
        vscroll = ttk.Scrollbar(frame, orient=tk.VERTICAL, command=canvas.yview)
        canvas.configure(yscrollcommand=vscroll.set)
        canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        vscroll.pack(side=tk.RIGHT, fill=tk.Y)

        inner = ttk.Frame(canvas)
        inner_id = canvas.create_window((0, 0), window=inner, anchor="nw")

        def _update_scrollregion(event=None):
            canvas.configure(scrollregion=canvas.bbox("all"))

        def _sync_inner_width(event):
            canvas.itemconfigure(inner_id, width=event.width)

        inner.bind("<Configure>", _update_scrollregion)
        canvas.bind("<Configure>", _sync_inner_width)

        def _on_mousewheel(event):
            if isinstance(event.widget, tk.Text):
                return
            delta = 0
            if event.delta:
                delta = -int(event.delta / 120)
            elif getattr(event, "num", None) in (4, 5):
                delta = -1 if event.num == 4 else 1
            if delta:
                canvas.yview_scroll(delta, "units")

        def _bind_mousewheel(widget):
            def _on_enter(_event):
                canvas.bind_all("<MouseWheel>", _on_mousewheel)
                canvas.bind_all("<Button-4>", _on_mousewheel)
                canvas.bind_all("<Button-5>", _on_mousewheel)

            def _on_leave(_event):
                canvas.unbind_all("<MouseWheel>")
                canvas.unbind_all("<Button-4>")
                canvas.unbind_all("<Button-5>")

            widget.bind("<Enter>", _on_enter)
            widget.bind("<Leave>", _on_leave)

        _bind_mousewheel(inner)

        paned = ttk.PanedWindow(inner, orient=tk.HORIZONTAL)
        paned.pack(fill=tk.BOTH, expand=True, padx=8, pady=8)

        # 左边：INCAR 模板
        left = ttk.Frame(paned, padding=8)
        paned.add(left, weight=1)

        ttk.Label(left, text="INCAR 模板与编辑").pack(anchor=tk.W)
        temp_bar = ttk.Frame(left)
        temp_bar.pack(fill=tk.X, pady=4)
        self.incar_template = tk.StringVar(value="relax")
        for key, txt in [
            ("relax", "几何优化"),
            ("static", "静态自洽"),
            ("dos", "态密度"),
            ("bands", "能带预设"),
        ]:
            ttk.Radiobutton(temp_bar, text=txt, value=key, variable=self.incar_template, command=self.load_incar_template).pack(side=tk.LEFT)
        ttk.Button(temp_bar, text="加载模板到编辑器", command=self.load_incar_template).pack(side=tk.RIGHT)

        # INCAR 简单面板
        simple_box = ttk.LabelFrame(left, text="INCAR 简单面板")
        simple_box.pack(fill=tk.X, pady=4)
        self.incar_simple_vars: dict[str, tk.StringVar] = {}
        simple_items = [
            ("ENCUT", "ENCUT (eV)"),
            ("EDIFF", "EDIFF"),
            ("EDIFFG", "EDIFFG"),
            ("ISMEAR", "ISMEAR"),
            ("SIGMA", "SIGMA"),
            ("KSPACING", "KSPACING"),
            ("NSW", "NSW"),
        ]
        for idx, (key, label) in enumerate(simple_items):
            row = idx // 2
            col = idx % 2
            frame_cell = ttk.Frame(simple_box)
            frame_cell.grid(row=row, column=col, sticky="ew", padx=4, pady=2)
            ttk.Label(frame_cell, text=label + ":").pack(side=tk.LEFT)
            var = tk.StringVar()
            self.incar_simple_vars[key] = var
            entry = ttk.Entry(frame_cell, textvariable=var, width=12)
            entry.pack(side=tk.LEFT, padx=4)
        for i in range(2):
            simple_box.grid_columnconfigure(i, weight=1)
        btn_row = ttk.Frame(simple_box)
        btn_row.grid(row=(len(simple_items)+1)//2, column=0, columnspan=2, sticky="ew", pady=(4, 0))
        ttk.Button(btn_row, text="从编辑器读取", command=self.refresh_incar_simple_panel).pack(side=tk.LEFT)
        ttk.Button(btn_row, text="写入到编辑器", command=self.apply_incar_simple_panel).pack(side=tk.LEFT, padx=6)

        self.incar_text = ScrolledText(left, height=20, undo=True, wrap="none")
        self.incar_text.pack(fill=tk.BOTH, expand=True)
        btns = ttk.Frame(left)
        btns.pack(fill=tk.X, pady=4)
        ttk.Button(btns, text="打开现有 INCAR", command=lambda: self.open_into_editor("INCAR", self.incar_text)).pack(side=tk.LEFT)
        ttk.Button(btns, text="保存到项目", command=lambda: self.save_from_editor("INCAR", self.incar_text)).pack(side=tk.LEFT, padx=6)

        # 右边：POSCAR & KPOINTS 编辑
        right = ttk.Frame(paned, padding=8)
        paned.add(right, weight=1)

        ttk.Label(right, text="POSCAR 编辑").pack(anchor=tk.W)
        self.poscar_text = ScrolledText(right, height=10, undo=True, wrap="none")
        self.poscar_text.pack(fill=tk.BOTH, expand=True)
        row = ttk.Frame(right)
        row.pack(fill=tk.X, pady=4)
        ttk.Button(row, text="打开 POSCAR", command=lambda: self.open_into_editor("POSCAR", self.poscar_text)).pack(side=tk.LEFT)
        ttk.Button(row, text="保存 POSCAR", command=lambda: self.save_from_editor("POSCAR", self.poscar_text)).pack(side=tk.LEFT, padx=6)
        ttk.Button(row, text="从 POSCAR 解析元素", command=self.show_poscar_elements).pack(side=tk.LEFT, padx=6)

        ttk.Separator(right, orient=tk.HORIZONTAL).pack(fill=tk.X, pady=6)

        ttk.Label(right, text="KPOINTS 编辑（可在K 点生成页自动生成）").pack(anchor=tk.W)
        self.kpoints_text = ScrolledText(right, height=10, undo=True, wrap="none")
        self.kpoints_text.pack(fill=tk.BOTH, expand=True)
        row2 = ttk.Frame(right)
        row2.pack(fill=tk.X, pady=4)
        ttk.Button(row2, text="打开 KPOINTS", command=lambda: self.open_into_editor("KPOINTS", self.kpoints_text)).pack(side=tk.LEFT)
        ttk.Button(row2, text="保存 KPOINTS", command=lambda: self.save_from_editor("KPOINTS", self.kpoints_text)).pack(side=tk.LEFT, padx=6)

        ttk.Separator(inner, orient=tk.HORIZONTAL).pack(fill=tk.X, padx=8, pady=6)

        potcar_box = ttk.LabelFrame(inner, text="POTCAR 赝势")
        potcar_box.pack(fill=tk.BOTH, expand=False, padx=8, pady=4)
        self._populate_potcar_section(potcar_box)

        ttk.Separator(inner, orient=tk.HORIZONTAL).pack(fill=tk.X, padx=8, pady=6)

        kpoints_box = ttk.LabelFrame(inner, text="K 点生成")
        kpoints_box.pack(fill=tk.BOTH, expand=False, padx=8, pady=4)
        self._populate_kpoints_section(kpoints_box)

        # 默认加载模板并同步简单面板
        self.load_incar_template()
        self.refresh_incar_simple_panel()
        return frame

    def load_incar_template(self):
        tpl = self.incar_template.get()
        presets = {
            "relax": (
                """# ==== 几何优化（PBE）====\nSYSTEM = relax\nENCUT = 520\nPREC  = Accurate\nEDIFF = 1e-6\nEDIFFG = -0.02\nISMEAR = 0\nSIGMA  = 0.05\nIBRION = 2\nISIF   = 3\nNSW    = 100\nISPIN  = 1\nLREAL  = Auto\n# 可选：KSPACING = 0.22\n"""
            ),
            "static": (
                """# ==== 静态自洽（SCF）====\nSYSTEM = scf\nENCUT = 520\nPREC  = Accurate\nEDIFF = 1e-6\nISMEAR = 0\nSIGMA  = 0.05\nIBRION = -1\nNSW    = 0\nLREAL  = Auto\nLWAVE  = .FALSE.\nLCHARG = .TRUE.\n# 可选：KSPACING = 0.22\n"""
            ),
            "dos": (
                """# ==== DOS 计算（在已收敛电荷上）====\nSYSTEM = dos\nENCUT = 520\nPREC  = Accurate\nEDIFF = 1e-6\nISMEAR = 0\nSIGMA  = 0.05\nIBRION = -1\nNSW    = 0\nLORBIT = 11\nNEDOS  = 2000\nLCHARG = .TRUE.\nLWAVE  = .FALSE.\n# 可选：KSPACING = 0.18\n"""
            ),
            "bands": (
                """# ==== 能带预设（非自洽）====\nSYSTEM = bands\nENCUT = 520\nPREC  = Accurate\nEDIFF = 1e-6\nISMEAR = 0\nSIGMA  = 0.05\nIBRION = -1\nNSW    = 0\nICHARG = 11\nLORBIT = 11\nLCHARG = .FALSE.\nLWAVE  = .TRUE.\n# KPOINTS 请使用路径方式或外部生成器\n"""
            ),
        }
        self.incar_text.delete("1.0", tk.END)
        self.incar_text.insert("1.0", presets.get(tpl, presets["relax"]))
        self.refresh_incar_simple_panel()

    def refresh_incar_simple_panel(self):
        if not hasattr(self, "incar_simple_vars"):
            return
        text = self.incar_text.get("1.0", tk.END)
        values: dict[str, str] = {}
        for line in text.splitlines():
            stripped = line.strip()
            if not stripped or stripped.startswith("#"):
                continue
            m = re.match(r"([A-Za-z0-9_+-]+)\s*=\s*(.+)", stripped)
            if m:
                key = m.group(1).upper()
                values[key] = m.group(2).strip()
        for key, var in self.incar_simple_vars.items():
            var.set(values.get(key, ""))

    def apply_incar_simple_panel(self):
        if not hasattr(self, "incar_simple_vars"):
            return
        updates = {}
        for key, var in self.incar_simple_vars.items():
            val = var.get().strip()
            updates[key] = val
        text = self.incar_text.get("1.0", tk.END)
        new_text = self._update_incar_text(text, updates)
        self.incar_text.delete("1.0", tk.END)
        self.incar_text.insert("1.0", new_text)
        self.refresh_incar_simple_panel()

    @staticmethod
    def _update_incar_text(text: str, updates: dict[str, str]) -> str:
        keys = {k.upper(): v for k, v in updates.items()}
        lines = text.splitlines()
        new_lines: list[str] = []
        handled: set[str] = set()
        for line in lines:
            stripped = line.strip()
            if not stripped or stripped.startswith("#"):
                new_lines.append(line)
                continue
            m = re.match(r"([A-Za-z0-9_+-]+)\s*=", stripped)
            if m:
                key = m.group(1).upper()
                if key in keys:
                    val = keys[key]
                    if val:
                        new_lines.append(f"{key} = {val}")
                    handled.add(key)
                    continue
            new_lines.append(line)
        for key, val in keys.items():
            if not val or key in handled:
                continue
            new_lines.append(f"{key} = {val}")
        result = "\n".join(new_lines)
        if result and not result.endswith("\n"):
            result += "\n"
        return result

    def launch_first_time_wizard(self):
        profile = self.run_first_time_wizard()
        if profile:
            self.apply_profile_to_project(profile)

    def run_first_time_wizard(self) -> WizardProfile | None:
        dialog = FirstTimeWizard(self)
        self.wait_window(dialog)
        return getattr(dialog, "result", None)

    def apply_profile_to_project(self, profile: WizardProfile, project_path: Path | None = None) -> None:
        proj = self.current_project_path() if project_path is None else Path(project_path)
        try:
            proj = proj.expanduser()
        except Exception:
            proj = Path(proj)
        proj.mkdir(parents=True, exist_ok=True)
        self._ensure_project_scaffold(proj)

        smear_defaults = {"metal": (1, 0.2), "semiconductor": (0, 0.05), "insulator": (0, 0.05)}
        isme, sigma = smear_defaults.get(profile.system_type, (0, 0.05))
        encut_value = profile.encut_value or 520
        encut_comment = ""
        if profile.encut_strategy == "auto" and profile.encut_value is None:
            encut_comment = "# ENCUT ≈ 1.3×ENMAX_max，已使用默认值 520"

        incar_lines = [
            "# === Generated by wizard ===",
            f"# Workflow: {profile.workflow}",
        ]
        if encut_comment:
            incar_lines.append(encut_comment)
        incar_lines.extend([
            f"SYSTEM = {proj.name}",
            f"ENCUT = {encut_value}",
            "PREC  = Accurate",
            "EDIFF = 1e-6",
        ])
        if profile.workflow.startswith("relax"):
            incar_lines.extend(["IBRION = 2", "ISIF   = 3", "NSW    = 80"])
        else:
            incar_lines.extend(["IBRION = -1", "NSW    = 0"])
        incar_lines.extend([
            f"ISMEAR = {isme}",
            f"SIGMA  = {sigma}",
            "LREAL  = Auto",
            "LWAVE  = .FALSE.",
            "LCHARG = .TRUE.",
        ])

        if profile.k_mode == "kspacing":
            kspacing = profile.kspacing or 0.22
            incar_lines.append(f"KSPACING = {kspacing}")
            kpoints_text = (
                f"# 使用 KSPACING = {kspacing}\n"
                "# 若需 Monkhorst 网格请替换为标准 KPOINTS 文件\n"
            )
        else:
            grid = profile.kgrid or (6, 6, 6)
            kpoints_text = gen_kpoints_monkhorst(grid[0], grid[1], grid[2], True)

        write_text(proj / "INCAR", "\n".join(filter(None, incar_lines)) + "\n")
        if not (proj / "POSCAR").exists():
            write_text(proj / "POSCAR", DEFAULT_POSCAR_TEMPLATE)
        write_text(proj / "KPOINTS", kpoints_text)

        self.figure_style_var.set(profile.figure_style)
        self.emit_report_var.set(bool(profile.emit_report))
        try:
            self.mpi_np.set(int(profile.np))
        except Exception:
            pass

        self.run_mode.set("slurm" if profile.use_slurm else "local")
        slurm_cfg = profile.slurm or {}
        self.slurm_part.set(slurm_cfg.get("partition", self.slurm_part.get()))
        self.slurm_time.set(slurm_cfg.get("time", self.slurm_time.get()))
        try:
            self.slurm_nodes.set(int(slurm_cfg.get("nodes", self.slurm_nodes.get())))
        except Exception:
            pass
        try:
            ntasks = int(slurm_cfg.get("ntasks", profile.np))
            self.slurm_ntasks.set(ntasks)
        except Exception:
            pass
        self.slurm_account.set(slurm_cfg.get("account", self.slurm_account.get()))

        self.last_wizard_profile = profile
        self.set_project(proj)
        try:
            self.write_job_script()
        except Exception:
            pass
        try:
            self.save_config()
        except Exception:
            pass

    def create_example_project(self, name: str = "example_Si") -> Path:
        root = Path.home() / "vasp_gui_projects"
        root.mkdir(parents=True, exist_ok=True)
        candidate = root / name
        idx = 1
        while candidate.exists():
            candidate = root / f"{name}_{idx:02d}"
            idx += 1
        style = self.figure_style_var.get() or "AFM"
        profile = WizardProfile(
            system_type="semiconductor",
            workflow="relax_scf_dos",
            encut_strategy="auto",
            encut_value=None,
            k_mode="kpoints",
            kspacing=None,
            kgrid=(6, 6, 6),
            use_slurm=False,
            np=max(1, self._int_from_var(self.mpi_np, 8)),
            slurm={},
            figure_style=style,
            emit_report=True,
        )
        self.apply_profile_to_project(profile, project_path=candidate)
        write_text(candidate / "POSCAR", EXAMPLE_SI_POSCAR)
        write_text(candidate / "INCAR", EXAMPLE_SI_INCAR)
        write_text(candidate / "KPOINTS", EXAMPLE_SI_KPOINTS)
        self.load_project_inputs()
        self._create_example_figures(candidate, style)
        return candidate

    def on_create_example_project(self):
        try:
            path = self.create_example_project()
        except Exception as exc:
            messagebox.showerror(APP_NAME, f"示例项目创建失败：{exc}")
            return
        messagebox.showinfo(APP_NAME, f"示例项目已创建：{path}")

    def _create_example_figures(self, proj: Path, style: str) -> None:
        fig_dir = proj / "figures"
        plots_dir = proj / "plots"
        fig_dir.mkdir(parents=True, exist_ok=True)
        plots_dir.mkdir(parents=True, exist_ok=True)

        energies = [i * 0.1 for i in range(-40, 41)]
        dos_vals = [max(0.0, 6.0 * math.exp(-((e) / 0.9) ** 2) - 0.15) for e in energies]
        fig = Figure(figsize=(4.0, 3.0), dpi=150)
        ax = fig.add_subplot(111)
        lw = FIG_STYLES.get(style, FIG_STYLES["AFM"]).get("linew", 1.2)
        ax.plot(energies, dos_vals, color="#1f77b4", linewidth=lw)
        ax.axvline(0.0, color="#444444", linestyle="--", linewidth=0.9)
        ax.set_xlabel("Energy (eV)")
        ax.set_ylabel("Total DOS (states/eV)")
        ax.set_title("Example DOS")
        apply_style(ax, style)
        fig.tight_layout()
        dos_png = fig_dir / "dos_demo.png"
        dos_svg = fig_dir / "dos_demo.svg"
        fig.savefig(dos_png, dpi=300)
        fig.savefig(dos_svg)
        with (fig_dir / "dos_demo.csv").open("w", encoding="utf-8") as f:
            f.write("energy_eV,total_dos\n")
            for e, d in zip(energies, dos_vals):
                f.write(f"{e:.3f},{d:.6f}\n")

        k_points = [i / 10 for i in range(11)]
        valence = [-0.5 + 0.25 * math.cos(math.pi * x) for x in k_points]
        conduction = [0.5 + 0.35 * math.cos(math.pi * x) for x in k_points]
        gap = min(conduction) - max(valence)
        fig2 = Figure(figsize=(4.0, 3.0), dpi=150)
        ax2 = fig2.add_subplot(111)
        ax2.plot(k_points, valence, color="#d62728", linewidth=lw)
        ax2.plot(k_points, conduction, color="#2ca02c", linewidth=lw)
        ax2.fill_between(k_points, valence, conduction, where=[c > v for c, v in zip(conduction, valence)], color="#cccccc", alpha=0.3)
        ax2.set_xlabel("k-path (arb.)")
        ax2.set_ylabel("Energy (eV)")
        ax2.set_title("Example Bands")
        ax2.text(0.02, 0.9, f"Gap ≈ {gap:.2f} eV", transform=ax2.transAxes)
        ax2.axhline(0.0, color="#444444", linestyle="--", linewidth=0.9)
        apply_style(ax2, style)
        fig2.tight_layout()
        band_png = fig_dir / "bands_demo.png"
        band_svg = fig_dir / "bands_demo.svg"
        fig2.savefig(band_png, dpi=300)
        fig2.savefig(band_svg)
        with (fig_dir / "bands_demo.csv").open("w", encoding="utf-8") as f:
            f.write("k_index,valence_eV,conduction_eV\n")
            for idx, (k, v, c) in enumerate(zip(k_points, valence, conduction)):
                f.write(f"{idx},{v:.6f},{c:.6f}\n")

        try:
            shutil.copyfile(dos_png, plots_dir / dos_png.name)
        except Exception:
            pass
        try:
            shutil.copyfile(band_png, plots_dir / band_png.name)
        except Exception:
            pass

        manifest = {"figures": [
            {"name": "dos_demo", "files": {"png": dos_png.name, "svg": dos_svg.name, "csv": "dos_demo.csv"}},
            {"name": "bands_demo", "files": {"png": band_png.name, "svg": band_svg.name, "csv": "bands_demo.csv"}},
        ]}
        (fig_dir / "manifest.json").write_text(json.dumps(manifest, ensure_ascii=False, indent=2), encoding="utf-8")

    def _ensure_project_scaffold(self, proj: Path) -> None:
        for name in ("plots", "snapshots", "figures", "reports"):
            try:
                (proj / name).mkdir(parents=True, exist_ok=True)
            except Exception:
                pass

    def open_into_editor(self, name: str, editor: tk.Text):
        proj = self.current_project_path()
        candidate = proj / name
        path = None
        if candidate.exists():
            path = candidate
        else:
            p = filedialog.askopenfilename(
                initialdir=self.project_dir,
                title=f"打开 {name}",
                filetypes=[(name, name), ("全部", "*")],
            )
            if not p:
                return
            path = Path(p)
        if path is None:
            path = candidate
        try:
            s = read_text(path)
            editor.delete("1.0", tk.END)
            editor.insert("1.0", s)
            if editor is getattr(self, "incar_text", None):
                self.refresh_incar_simple_panel()
        except Exception as e:
            messagebox.showerror(APP_NAME, f"读取失败：{e}")

    def save_from_editor(self, name: str, editor: tk.Text):
        proj = self.current_project_path()
        proj.mkdir(parents=True, exist_ok=True)
        p = proj / name
        try:
            write_text(p, editor.get("1.0", tk.END))
            messagebox.showinfo(APP_NAME, f"已保存 {name} -> {p}")
            self.refresh_project_overview()
        except Exception as e:
            messagebox.showerror(APP_NAME, f"保存失败：{e}")

    def show_poscar_elements(self):
        s = self.poscar_text.get("1.0", tk.END)
        elems = unique_elements_from_poscar(s)
        if elems:
            messagebox.showinfo(APP_NAME, f"POSCAR 元素：{', '.join(elems)}")
        else:
            messagebox.showwarning(APP_NAME, "未解析到元素，请检查第6/7行。")

    # ------------------------- 页面：POTCAR --------------------------------
    def _populate_potcar_section(self, container):
        row1 = ttk.Frame(container)
        row1.pack(fill=tk.X, padx=8, pady=8)
        ttk.Label(row1, text="赝势库根目录：").pack(side=tk.LEFT)
        self.pot_dir_var = tk.StringVar(value=str(Path.home() / "potcars"))
        ttk.Entry(row1, textvariable=self.pot_dir_var, width=80).pack(side=tk.LEFT, padx=6)
        ttk.Button(row1, text="选择…", command=self.choose_pot_dir).pack(side=tk.LEFT)
        ttk.Button(row1, text="探测赝势库", command=self.detect_pot_roots).pack(side=tk.LEFT, padx=6)

        row2 = ttk.Frame(container)
        row2.pack(fill=tk.X, padx=8, pady=4)
        ttk.Label(row2, text="从 POSCAR 自动解析元素并生成 POTCAR：").pack(side=tk.LEFT)
        ttk.Button(row2, text="生成 POTCAR", command=self.do_build_potcar).pack(side=tk.LEFT, padx=8)

        self.pot_msg = ScrolledText(container, height=12, wrap="word")
        self.pot_msg.pack(fill=tk.BOTH, expand=True, padx=8, pady=8)

        return container

    def _build_potcar_page(self, parent):
        frame = ttk.Frame(parent)
        self._populate_potcar_section(frame)
        return frame

    def choose_pot_dir(self):
        d = filedialog.askdirectory(initialdir=self.pot_dir_var.get(), title="选择赝势库根目录")
        if d:
            self.pot_dir_var.set(d)

    def do_build_potcar(self):
        proj = self.current_project_path()
        pos = proj / "POSCAR"
        if not pos.exists():
            # 尝试从编辑器
            s = self.poscar_text.get("1.0", tk.END).strip()
            if s:
                write_text(pos, s)
            else:
                messagebox.showwarning(APP_NAME, "项目目录中不存在 POSCAR，且编辑器为空。")
                return
        elems, _ = parse_poscar(read_text(pos))
        if not elems:
            messagebox.showwarning(APP_NAME, "未从 POSCAR 解析到元素。")
            return
        pot_base = Path(self.pot_dir_var.get())
        selections: list[Path] = []
        for e in elems:
            cands = find_potcar_candidates(e, pot_base)
            if not cands:
                msg = f"未找到元素 {e} 的 POTCAR（在 {pot_base} 下）。"
                self.pot_msg.insert(tk.END, msg + "\n")
                messagebox.showerror(APP_NAME, msg)
                return
            if len(cands) == 1:
                selected = cands[0]
            else:
                options = [str(p) for p in cands]
                sel = self.select_from_list(f"选择 {e} 的 POTCAR", options)
                if not sel:
                    cancel_msg = f"已取消 {e} 的 POTCAR 选择，终止生成。"
                    self.pot_msg.insert(tk.END, cancel_msg + "\n")
                    messagebox.showinfo(APP_NAME, cancel_msg)
                    return
                selected = Path(sel)
            selections.append(selected)
            self.pot_msg.insert(tk.END, f"{e}: 使用 {selected}\n")
            self.pot_msg.see(tk.END)
        ok, msg = build_potcar(selections, proj / "POTCAR")
        self.pot_msg.insert(tk.END, (msg + "\n"))
        self.pot_msg.see(tk.END)
        if not ok:
            messagebox.showerror(APP_NAME, msg)
        else:
            messagebox.showinfo(APP_NAME, msg)
            self.refresh_project_overview()

    # --------- 赝势库探测与选择 ---------
    def detect_pot_roots(self):
        cands = self.scan_pot_roots(limit=30)
        if not cands:
            messagebox.showwarning(APP_NAME, "未在常见位置发现赝势库候选。你也可以手动选择根目录。")
            return
        if len(cands) == 1:
            self.pot_dir_var.set(cands[0])
            messagebox.showinfo(APP_NAME, f"已设置赝势库根目录：\n{cands[0]}")
            return
        sel = self.select_from_list("选择赝势库根目录", cands)
        if sel:
            self.pot_dir_var.set(sel)

    def select_from_list(self, title, items):
        top = tk.Toplevel(self)
        top.title(title)
        top.geometry("720x380")
        lb = tk.Listbox(top, selectmode=tk.SINGLE)
        for it in items:
            lb.insert(tk.END, it)
        lb.pack(fill=tk.BOTH, expand=True, padx=8, pady=8)
        sel = {"val": None}
        def ok():
            try:
                i = lb.curselection()
                sel["val"] = items[i[0]] if i else None
            except Exception:
                sel["val"] = None
            top.destroy()
        ttk.Button(top, text="使用选中", command=ok).pack(pady=6)
        top.transient(self); top.grab_set(); self.wait_window(top)
        return sel["val"]

    def scan_pot_roots(self, limit=20):
        bases = []
        # 当前设置与常见路径为起点
        try:
            bases.append(Path(self.pot_dir_var.get()).expanduser())
        except Exception:
            pass
        for p in [Path.home()/"potcars", Path.home()/"vasp", Path.home()/"apps", Path.home()/"Downloads", Path.home()/"下载", Path("/opt/vasp"), Path("/usr/local/share/vasp"), Path("/mnt/c/Users")]:
            if p.exists():
                bases.append(p)
        seen = set(); cands = []
        def looks_like_root(d: Path):
            try:
                cnt = 0
                for child in d.iterdir():
                    if child.is_dir() and (child/"POTCAR").exists():
                        cnt += 1
                        if cnt >= 3:
                            return True
                return False
            except Exception:
                return False
        # BFS 限深 3
        from collections import deque
        for base in list(dict.fromkeys(bases)):
            if not base.exists():
                continue
            q = deque([(base, 0)])
            while q and len(cands) < limit:
                cur, dep = q.popleft()
                try:
                    key = str(cur.resolve())
                except Exception:
                    key = str(cur)
                if key in seen:
                    continue
                seen.add(key)
                if looks_like_root(cur):
                    cands.append(key)
                if dep < 3:
                    try:
                        for ch in cur.iterdir():
                            if ch.is_dir():
                                q.append((ch, dep+1))
                    except Exception:
                        pass
        # 去重与排序（包含关键词的优先）
        def score(path):
            name = path.lower(); s = 0
            for kw in ("potpaw","paw","pbe","lda","potential","psp"):
                if kw in name:
                    s += 1
            return (-s, len(path))
        cands = sorted(list(dict.fromkeys(cands)), key=score)
        return cands[:limit]

    # ------------------------- 页面：KPOINTS -------------------------------
    def _populate_kpoints_section(self, container):
        box = ttk.LabelFrame(container, text="Monkhorst-Pack 网格")
        box.pack(fill=tk.X, padx=8, pady=8)

        self.k_nx = tk.IntVar(value=5)
        self.k_ny = tk.IntVar(value=5)
        self.k_nz = tk.IntVar(value=5)
        self.k_gamma = tk.BooleanVar(value=True)

        row = ttk.Frame(box)
        row.pack(fill=tk.X, pady=4)
        ttk.Label(row, text="Nx").pack(side=tk.LEFT)
        ttk.Spinbox(row, from_=1, to=50, textvariable=self.k_nx, width=5).pack(side=tk.LEFT, padx=6)
        ttk.Label(row, text="Ny").pack(side=tk.LEFT)
        ttk.Spinbox(row, from_=1, to=50, textvariable=self.k_ny, width=5).pack(side=tk.LEFT, padx=6)
        ttk.Label(row, text="Nz").pack(side=tk.LEFT)
        ttk.Spinbox(row, from_=1, to=50, textvariable=self.k_nz, width=5).pack(side=tk.LEFT, padx=6)
        ttk.Checkbutton(box, text="Gamma 中心", variable=self.k_gamma).pack(anchor=tk.W, padx=8)

        btns = ttk.Frame(container)
        btns.pack(fill=tk.X, padx=8, pady=4)
        ttk.Button(btns, text="生成到编辑器", command=self.kpoints_to_editor).pack(side=tk.LEFT)
        ttk.Button(btns, text="保存到项目(KPOINTS)", command=self.kpoints_save).pack(side=tk.LEFT, padx=8)

        tip = ttk.Label(container, text="提示：也可在 INCAR 使用 KSPACING，省去 KPOINTS（VASP 5.4.4+）")
        tip.pack(anchor=tk.W, padx=12, pady=4)

        return container

    def _build_kpoints_page(self, parent):
        frame = ttk.Frame(parent)
        self._populate_kpoints_section(frame)
        return frame

    # === CODEX BEGIN: twist/shift page UI ===
    def _build_twistshift_page(self, parent):
        frame = ttk.Frame(parent)

        # 左栏：输入与控制（带滚动条）
        left_container = ttk.Frame(frame)
        left_container.pack(side=tk.LEFT, fill=tk.Y)
        left_canvas = tk.Canvas(left_container, borderwidth=0, highlightthickness=0, width=420)
        left_scroll = ttk.Scrollbar(left_container, orient=tk.VERTICAL, command=left_canvas.yview)
        left_canvas.configure(yscrollcommand=left_scroll.set)
        left_canvas.pack(side=tk.LEFT, fill=tk.Y, expand=False)
        left_scroll.pack(side=tk.RIGHT, fill=tk.Y)

        left = ttk.Frame(left_canvas, padding=8)
        left_window = left_canvas.create_window((0, 0), window=left, anchor="nw")

        def _sync_scrollregion(event):
            left_canvas.configure(scrollregion=left_canvas.bbox("all"))

        def _match_width(event):
            left_canvas.itemconfigure(left_window, width=event.width)

        left.bind("<Configure>", _sync_scrollregion)
        left_canvas.bind("<Configure>", _match_width)

        def _on_mousewheel(event):
            delta = 0
            if event.delta:
                delta = -int(event.delta / 120)
            elif event.num in (4, 5):
                delta = -1 if event.num == 4 else 1
            if delta:
                left_canvas.yview_scroll(delta, "units")
                return "break"

        for widget in (left_canvas, left):
            widget.bind("<MouseWheel>", _on_mousewheel)
            widget.bind("<Button-4>", _on_mousewheel)
            widget.bind("<Button-5>", _on_mousewheel)
        ttk.Label(left, text="二维材料扭转/滑移 | 生成批量 POSCAR 与扫参任务").pack(anchor=tk.W, pady=(0,6))

        # 路径选择
        self.tw_top_path = tk.StringVar()
        self.tw_bot_path = tk.StringVar()

        row = ttk.Frame(left); row.pack(fill=tk.X, pady=2)
        ttk.Label(row, text="上层 POSCAR:").pack(side=tk.LEFT)
        ttk.Entry(row, textvariable=self.tw_top_path, width=44).pack(side=tk.LEFT, padx=4)
        ttk.Button(row, text="选择…", command=lambda: self._tw_pick_poscar(self.tw_top_path)).pack(side=tk.LEFT)

        row = ttk.Frame(left); row.pack(fill=tk.X, pady=2)
        ttk.Label(row, text="下层 POSCAR:").pack(side=tk.LEFT)
        ttk.Entry(row, textvariable=self.tw_bot_path, width=44).pack(side=tk.LEFT, padx=4)
        ttk.Button(row, text="选择…", command=lambda: self._tw_pick_poscar(self.tw_bot_path)).pack(side=tk.LEFT)

        info1 = textwrap.dedent("""
            1) 上/下层 POSCAR

            分别选择两层的 POSCAR（底层记作 B，上层记作 T）。程序假定：

            c 轴（第三个晶格向量）近似垂直层面；若不是，会先把法向对齐到 z。

            读取元素和原子层标签后，会把“上层”整体当作一个刚体进行旋转/平移（默认不开原子内形变）。

            预览/生成时会将上层加到下层之上，层间距由“真空”与你后续设置共同决定。

            更多细节可参阅用户手册中的结构准备章节。
        """).strip()
        ttk.Label(left, text=info1, justify=tk.LEFT, wraplength=360, foreground="#555").pack(anchor=tk.W, pady=(4, 8))

        ttk.Separator(left, orient=tk.HORIZONTAL).pack(fill=tk.X, pady=6)

        # 基本几何参数
        self.tw_vacuum = tk.DoubleVar(value=20.0)     # 目标真空 (Å)
        self.tw_allow_strain = tk.DoubleVar(value=0.8)  # 允许等效小应变（%）
        self.tw_gamma_atom_threshold = tk.IntVar(value=500)  # 超大超胞→Gamma-only
        self.tw_enable_twist = tk.BooleanVar(value=True)
        self.tw_enable_slide = tk.BooleanVar(value=True)

        row = ttk.Frame(left); row.pack(fill=tk.X, pady=2)
        ttk.Label(row, text="真空(Å):").pack(side=tk.LEFT); ttk.Entry(row, textvariable=self.tw_vacuum, width=7).pack(side=tk.LEFT, padx=4)
        ttk.Label(row, text="容许应变(%)").pack(side=tk.LEFT, padx=(8,0)); ttk.Entry(row, textvariable=self.tw_allow_strain, width=7).pack(side=tk.LEFT, padx=4)

        info2 = textwrap.dedent("""
            2) 真空 (Å) 与 容许应变 (%)

            真空：设置 c 方向晶格长度（层间 + 真空）。对 2D 建议 ≥ 15–20 Å；如做偶极校正（LDIPOL=.TRUE., IDIPOL=3）更稳。

            容许应变 ε（百分比）：允许对两层在 面内 进行极小各向同性拉伸/压缩，使超胞达到近共格。

            内部会做一个“最小公倍格”搜索：寻找两个整数矩阵 Mᵦ, Mₜ 使得
            | Mᵦ·Aᵦ – R(θ)·Mₜ·Aₜ | / |·| ≤ ε，
            其中 Aᵦ/Aₜ 是 2×2 面内基矢矩阵，R(θ) 是绕 z 的旋转矩阵。

            若找不到满足阈值的解，会提示“角度太挑剔或 ε 太小”。常用 ε：0.5–1.0%。

            小贴士：莫尔超胞原子数 ~ 1/θ²（弧度），θ 很小时会“爆表”。面板下方“任务上限”就是用来兜底的。

            容许应变的进一步讨论可参考用户手册中的容许应变章节。
        """).strip()
        ttk.Label(left, text=info2, justify=tk.LEFT, wraplength=360, foreground="#555").pack(anchor=tk.W, pady=(4, 8))

        dim_frame = ttk.LabelFrame(left, text="扫描维度")
        dim_frame.pack(fill=tk.X, pady=4)
        ttk.Checkbutton(dim_frame, text="启用扭转角扫描", variable=self.tw_enable_twist).pack(anchor=tk.W, padx=6, pady=2)
        ttk.Checkbutton(dim_frame, text="启用滑移网格扫描", variable=self.tw_enable_slide).pack(anchor=tk.W, padx=6, pady=2)
        ttk.Label(dim_frame, text="可按需只做扭转或只做滑移，两者都开时则全量组合。", wraplength=340, justify=tk.LEFT, foreground="#555").pack(anchor=tk.W, padx=6, pady=(0, 4))

        ttk.Separator(left, orient=tk.HORIZONTAL).pack(fill=tk.X, pady=6)

        # 扭转角扫描
        ttk.Label(left, text="扭转角 θ (度)：").pack(anchor=tk.W)
        self.tw_theta_a = tk.DoubleVar(value=0.0)
        self.tw_theta_b = tk.DoubleVar(value=10.0)
        self.tw_theta_step = tk.DoubleVar(value=2.0)
        r=ttk.Frame(left); r.pack(fill=tk.X, pady=2)
        ttk.Label(r, text="起").pack(side=tk.LEFT); ttk.Entry(r, textvariable=self.tw_theta_a, width=7).pack(side=tk.LEFT, padx=4)
        ttk.Label(r, text="止").pack(side=tk.LEFT); ttk.Entry(r, textvariable=self.tw_theta_b, width=7).pack(side=tk.LEFT, padx=4)
        ttk.Label(r, text="步").pack(side=tk.LEFT); ttk.Entry(r, textvariable=self.tw_theta_step, width=7).pack(side=tk.LEFT, padx=4)
        ttk.Label(left, text="注：六角晶格通常只需 0–60° 区间。", foreground="#666").pack(anchor=tk.W, pady=(0,4))

        info3 = textwrap.dedent("""
            3) 扭转角 θ（度）

            三个框：起/止/步，都按闭区间处理（包含起点与终点；若 (止-起) 不是步长整数倍，会截断到 ≤止 的最后一个点）。

            对六角/三角晶格，0–60° 覆盖所有独立堆垛（60° 以上由对称性等价）。异质材料也通常在 0–60° 内扫描。

            任务数中的角度个数：
            Nθ = floor((止 − 起)/步) + 1。

            θ 列表的示例计算可参见使用指南中的附录。
        """).strip()
        ttk.Label(left, text=info3, justify=tk.LEFT, wraplength=360, foreground="#555").pack(anchor=tk.W, pady=(0, 8))

        # 滑移扫描（分数坐标）
        ttk.Label(left, text="滑移 (分数坐标 u_x,u_y)：").pack(anchor=tk.W)
        self.tw_ux_steps = tk.IntVar(value=5)
        self.tw_uy_steps = tk.IntVar(value=5)
        r=ttk.Frame(left); r.pack(fill=tk.X, pady=2)
        ttk.Label(r, text="u_x 步数").pack(side=tk.LEFT); ttk.Spinbox(r, from_=1, to=32, textvariable=self.tw_ux_steps, width=6).pack(side=tk.LEFT, padx=4)
        ttk.Label(r, text="u_y 步数").pack(side=tk.LEFT, padx=(8,0)); ttk.Spinbox(r, from_=1, to=32, textvariable=self.tw_uy_steps, width=6).pack(side=tk.LEFT, padx=4)
        ttk.Label(left, text="网格覆盖 [0,1)×[0,1)，自动等间隔。", foreground="#666").pack(anchor=tk.W)

        info4 = textwrap.dedent("""
            4) 滑移 (分数坐标 uₓ,uᵧ)

            定义：上层整体平移向量 t = uₓ·a₁ + uᵧ·a₂，其中 a₁,a₂ 是下层（底层）的面内基矢。这是晶体学上标准而严谨的定义。

            网格：在 [0,1)×[0,1) 上均匀取点。

            “uₓ 步数 = nₓ、uᵧ 步数 = nᵧ” 代表 nₓ×nᵧ 个滑移点：
            uₓ ∈ {0, 1/nₓ, …, (nₓ−1)/nₓ}（uᵧ 同理）。

            由于原胞周期性，u=1 与 u=0 等价，所以开区间右端是严格的。

            对六角晶格，(uₓ,uᵧ) 的对称等价点会被自动去重（若启用“等价裁剪”，否则就全保留以便做摩擦路径）。

            5×5 网格的示例列表可在文档附录中查看。
        """).strip()
        ttk.Label(left, text=info4, justify=tk.LEFT, wraplength=360, foreground="#555").pack(anchor=tk.W, pady=(0, 8))

        ttk.Separator(left, orient=tk.HORIZONTAL).pack(fill=tk.X, pady=6)

        # 计算与并行策略
        self.tw_kspacing = tk.DoubleVar(value=0.22)
        self.tw_max_tasks = tk.IntVar(value=200)
        self.tw_autorun = tk.BooleanVar(value=False)  # 可选：生成后立刻运行（默认关）

        r=ttk.Frame(left); r.pack(fill=tk.X, pady=2)
        ttk.Label(r, text="KSPACING").pack(side=tk.LEFT); ttk.Entry(r, textvariable=self.tw_kspacing, width=7).pack(side=tk.LEFT, padx=4)
        ttk.Label(r, text="任务上限").pack(side=tk.LEFT, padx=(8,0)); ttk.Entry(r, textvariable=self.tw_max_tasks, width=7).pack(side=tk.LEFT, padx=4)
        ttk.Checkbutton(left, text="生成后自动运行（试验性）", variable=self.tw_autorun).pack(anchor=tk.W, pady=(2,4))

        info5 = textwrap.dedent("""
            5) KSPACING 与 任务上限

            KSPACING：用于生成每个任务的 k 网密度（优先写入 INCAR；如你已有 KPOINTS，将按你的 KPOINTS 执行）。

            建议：小原胞/金属 0.18–0.22，半导体 0.22–0.30；大莫尔超胞可先 Γ-only 预筛（KPOINTS 留空或 KSPACING 放宽到 ~0.35）。

            任务上限：限制本次 sweep 的总任务数，防止角度×滑移网格把集群“点爆”。

            预计任务数：N_tot = Nθ × nₓ × nᵧ。超限时会让你缩小参数或增大上限。

            可按该公式自行评估 N_tot 以确认任务规模。
        """).strip()
        ttk.Label(left, text=info5, justify=tk.LEFT, wraplength=360, foreground="#555").pack(anchor=tk.W, pady=(0, 8))

        # 操作按钮
        btns = ttk.Frame(left); btns.pack(fill=tk.X, pady=8)
        ttk.Button(btns, text="预览当前(θ,u)几何", command=self._tw_preview_once).pack(side=tk.LEFT)
        ttk.Button(btns, text="生成单例 POSCAR", command=lambda: self._tw_generate(single=True)).pack(side=tk.LEFT, padx=6)
        ttk.Button(btns, text="批量遍历并生成", command=lambda: self._tw_generate(single=False)).pack(side=tk.LEFT)

        info6 = textwrap.dedent("""
            6) 选项与按钮

            生成后自动运行（试验性）
            勾选后，“批量遍历并生成”会在每个任务目录下写 INCAR/KPOINTS/POSCAR/POTCAR 与 run_*.sh，然后按你在“运行/提交”页的模式触发 mpirun 或 sbatch。建议先不勾，确认 POSCAR/任务规模正确再统一提交。

            预览当前 (θ,u) 几何
            不落盘，实时构造该扭转+滑移构型，显示原子散点+胞矢信息，便于肉眼检查“角度对不对、滑移是否如预期”。

            生成单例 POSCAR
            仅用当前 θ 与 (uₓ,uᵧ) 落盘到当前项目（便于手工跑一发或调参）。

            批量遍历并生成
            对 θ ∈ grid(起,止,步) 与 (uₓ,uᵧ) ∈ [0,1)×[0,1) 网格逐一构造近共格超胞，写入任务目录与脚本。

            目录命名（示例）：
            sweep/θ_10.00/u_0.20_0.40/
            sweep/θ_12.00/u_0.60_0.00/

            同时生成 meta.json 记录：theta_deg, ux, uy, natoms, strain_top/bottom, area, a1,a2,c, stack_tag 等，便于溯源。

            解析 sweep 结果 → CSV
            在每个任务目录抓取 OSZICAR/OUTCAR/EIGENVAL/DOSCAR，汇总为一张表：theta_deg, ux, uy, natoms, strain%, Etot_eV, dE_meV_per_atom, gap_PBE_eV, Efermi, conv_steps, status。
            这一步只做解析与统计；若你启用“自动运行”，它还能附带标记已完成/失败任务。

            各按钮的职责如上所述，完整操作流程可参考用户指南。
        """).strip()
        ttk.Label(left, text=info6, justify=tk.LEFT, wraplength=360, foreground="#555").pack(anchor=tk.W, pady=(0, 8))

        ttk.Separator(left, orient=tk.HORIZONTAL).pack(fill=tk.X, pady=6)
        ttk.Button(left, text="解析 sweep 结果 → CSV", command=self._tw_collect_results).pack(anchor=tk.W)

        info7 = textwrap.dedent("""
            7) 计算与物理的“默认值”建议（可直接照抄）

            真空：20 Å；LDIPOL=.TRUE., IDIPOL=3 勾上。

            容许应变：0.5–0.8%；若角度很小又想控原子数，短期可放到 1.0%。

            θ 网：六角体系先扫 0–10° 每 2°；发现有趣点再细化到 0.5°/0.2°。

            (uₓ,uᵧ) 网：5×5 或 7×7 起步；摩擦/势垒地图可加密到 15×15。

            KSPACING：0.22；超大胞先 Γ-only 预筛，命中后再密网复算。

            出图/带隙：SCF/DOS 步 ISMEAR=0, SIGMA=0.05；Relax/金属步可 ISMEAR=1, SIGMA=0.2 提速。

            vdW：IVDW=12（D3(BJ)）或用 rVV10，二者择一保持一致性。

            以上默认值可视项目需要作为起点并在后续调整。
        """).strip()
        ttk.Label(left, text=info7, justify=tk.LEFT, wraplength=360, foreground="#555").pack(anchor=tk.W, pady=(8, 8))

        info8 = textwrap.dedent("""
            8) 典型坑位与正确做法

            θ 很小 → 原子数暴涨：先设任务上限，并用 Γ-only 预筛；必要时提高 ε（容许应变）或者限制最小胞边长。

            滑移定义混淆：本面板严格用底层基矢的分数坐标；预览里会显示 t = ux·a1 + uy·a2 供核对。

            端点重合：滑移用 [0,1) 去掉 1；θ 扫描包含止点要注意步长整除。

            解析带隙：PBE 会低估；想更可信，请对代表点加做 HSE 或 scGW 小样本标定，在 CSV 后处理里做“多保真校正”。

            更多命名规范与目录结构示例可在项目文档中查阅。
        """).strip()
        ttk.Label(left, text=info8, justify=tk.LEFT, wraplength=360, foreground="#555").pack(anchor=tk.W, pady=(0, 8))

        # 右栏：俯视预览
        right = ttk.Frame(frame, padding=8); right.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True)
        self.fig_tw = Figure(figsize=(6.0,4.5), dpi=100)
        self.ax_tw = self.fig_tw.add_subplot(111)
        self.ax_tw.set_title("Top view preview")
        self.ax_tw.set_xlabel("x (Å)"); self.ax_tw.set_ylabel("y (Å)")
        self.canvas_tw = FigureCanvasTkAgg(self.fig_tw, master=right)
        self.canvas_tw.draw(); self.canvas_tw.get_tk_widget().pack(fill=tk.BOTH, expand=True)

        return frame
    # === CODEX END: twist/shift page UI ===

    # === CODEX BEGIN: twist/shift geometry core ===
    def _tw_pick_poscar(self, var):
        p = filedialog.askopenfilename(title="选择 POSCAR", filetypes=[("POSCAR","POSCAR*"),("All","*")])
        if p: var.set(p)

    def _tw_preview_once(self):
        """使用当前 θ = theta_a、u=(0,0) 快速构造一次并俯视预览。"""
        try:
            st, meta = self._tw_build_structure(
                Path(self.tw_top_path.get()), Path(self.tw_bot_path.get()),
                theta_deg=float(self.tw_theta_a.get()), ux=0.0, uy=0.0,
                vacuum=float(self.tw_vacuum.get()),
                allow_strain=float(self.tw_allow_strain.get())/100.0,
                search_limit=8
            )
        except Exception as e:
            messagebox.showerror(APP_NAME, f"预览失败：{e}")
            return
        self._tw_draw_topview(st, meta)

    def _tw_draw_topview(self, st, meta):
        """简单俯视：投影到 x-y，按层分色。"""
        try:
            from pymatgen.core import Structure  # noqa: F401
        except Exception:
            messagebox.showerror(APP_NAME, "未安装 pymatgen，无法预览结构。")
            return
        self.ax_tw.clear()
        # 取原子与层标签（site.properties.get("layer")）
        xs0, ys0, xs1, ys1 = [], [], [], []
        for site in st.sites:
            x,y,z = site.coords
            if site.properties.get("layer","bot") == "top":
                xs1.append(x); ys1.append(y)
            else:
                xs0.append(x); ys0.append(y)
        self.ax_tw.scatter(xs0, ys0, s=14, alpha=0.8, label="bottom")
        self.ax_tw.scatter(xs1, ys1, s=14, alpha=0.6, label="top")
        # 画边框（新晶格）
        M = st.lattice.matrix
        import numpy as _np
        a = _np.array(M[0]); b = _np.array(M[1])
        poly = _np.array([[0,0],[a[0],a[1]],[a[0]+b[0],a[1]+b[1]],[b[0],b[1]],[0,0]])
        self.ax_tw.plot(poly[:,0], poly[:,1], linestyle="--", linewidth=1.0)
        self.ax_tw.set_aspect("equal", adjustable="datalim")
        self.ax_tw.grid(True, linestyle=":", linewidth=0.6)
        self.ax_tw.legend()
        tdeg = meta.get("theta_deg")
        ux,uy = meta.get("ux"), meta.get("uy")
        self.ax_tw.set_title(f"θ={tdeg:.3f}°, u=({ux:.3f},{uy:.3f}), atoms={len(st)}")
        self.canvas_tw.draw_idle()

    def _tw_find_match(self, A_top_rot, A_bot, allow_strain: float, search_limit: int):
        """返回最优匹配 dict(n1,m1,n2,m2,s,resid,area,atoms)。"""
        import numpy as np

        best: Optional[Dict[str, float]] = None
        # 优先使用 ZSL（若可用），失败则自动回退
        if HAS_ZSL:
            try:
                zsl = ZSLGenerator(
                    max_area_ratio=(1.0 + allow_strain),
                    max_misfit=allow_strain,
                    max_angle_diff=allow_strain * 10.0,
                )

                def to3(mat):
                    return np.array(
                        [
                            [mat[0, 0], mat[0, 1], 0.0],
                            [mat[1, 0], mat[1, 1], 0.0],
                            [0.0, 0.0, 1.0],
                        ],
                        dtype=float,
                    )

                matches = zsl.get_zsl_matches(to3(A_top_rot), to3(A_bot), max_search=search_limit)
                for m in matches:
                    S1 = np.array(m.get("matrix_1"), dtype=float)[:2, :2]
                    S2 = np.array(m.get("matrix_2"), dtype=float)[:2, :2]
                    # 当前构建流程只支持对角超胞，若出现非对角项则跳过
                    if not np.allclose(S1, np.diag(np.diag(S1))) or not np.allclose(
                        S2, np.diag(np.diag(S2))
                    ):
                        continue
                    S1 = np.diag(np.diag(S1)).astype(int)
                    S2 = np.diag(np.diag(S2)).astype(int)
                    T = A_top_rot @ S1
                    B = A_bot @ S2
                    denom = float(np.trace(T.T @ T))
                    if denom <= 0:
                        continue
                    s_star = float(np.trace(T.T @ B) / denom)
                    resid = np.linalg.norm(B - s_star * T, ord="fro") / max(
                        1.0, np.linalg.norm(B, ord="fro")
                    )
                    area = abs(float(np.linalg.det(B)))
                    cand = dict(
                        n1=int(S1[0, 0]),
                        m1=int(S1[1, 1]),
                        n2=int(S2[0, 0]),
                        m2=int(S2[1, 1]),
                        s=s_star,
                        resid=resid,
                        area=area,
                        atoms=-1,
                    )
                    if best is None or (resid, area) < (best["resid"], best["area"]):
                        best = cand
                if best is not None:
                    return best
            except Exception:
                pass

        # 回退到对角穷举
        best = None
        for n1 in range(1, search_limit + 1):
            for m1 in range(1, search_limit + 1):
                T = A_top_rot @ np.array([[n1, 0], [0, m1]], dtype=int)
                denom = float(np.trace(T.T @ T))
                if denom <= 0:
                    continue
                for n2 in range(1, search_limit + 1):
                    for m2 in range(1, search_limit + 1):
                        B = A_bot @ np.array([[n2, 0], [0, m2]], dtype=int)
                        s_star = float(np.trace(T.T @ B) / denom)
                        if not (1.0 - allow_strain <= s_star <= 1.0 + allow_strain):
                            continue
                        resid = np.linalg.norm(B - s_star * T, ord="fro") / max(
                            1.0, np.linalg.norm(B, ord="fro")
                        )
                        area = abs(float(np.linalg.det(B)))
                        cand = dict(
                            n1=n1,
                            m1=m1,
                            n2=n2,
                            m2=m2,
                            s=s_star,
                            resid=resid,
                            area=area,
                            atoms=-1,
                        )
                        if best is None or (resid, area) < (best["resid"], best["area"]):
                            best = cand
        return best

    def _estimate_atoms(self, st_top, st_bot, best):
        return len(st_top) * (best["n1"] * best["m1"]) + len(st_bot) * (best["n2"] * best["m2"])

    def _tw_build_structure(self, top_path: Path, bot_path: Path,
                            theta_deg: float, ux: float, uy: float,
                            vacuum: float, allow_strain: float,
                            search_limit: int = 8):
        """
        构造扭转(θ) + 滑移(u_x,u_y) 的双层结构，并尽量用对角超胞近似共格。
        返回 (Structure, meta)；如果找不到低应变解，抛出异常。
        """
        if not HAS_PYMATGEN or not HAS_NUMPY:
            raise RuntimeError("需要 pymatgen + numpy")
        from pymatgen.core import Structure, Lattice
        import numpy as np

        if not top_path.exists() or not bot_path.exists():
            raise FileNotFoundError("POSCAR 路径不存在")

        st_top = Structure.from_file(str(top_path))
        st_bot = Structure.from_file(str(bot_path))

        # 取 in-plane 基矢（假定 z 为法向；若用户 POSCAR 不是这样，应先在外部对齐）
        A_bot = np.array(st_bot.lattice.matrix[:2, :2])  # (2,2)
        A_top = np.array(st_top.lattice.matrix[:2, :2])  # (2,2)

        # 绕 z 旋转上层 in-plane 基矢
        th = np.deg2rad(theta_deg)
        Rz = np.array([[np.cos(th), -np.sin(th)],
                       [np.sin(th),  np.cos(th)]], dtype=float)
        A_top_rot = Rz @ A_top  # (2,2)

        best = self._tw_find_match(A_top_rot, A_bot, allow_strain, search_limit)

        if best is None:
            raise RuntimeError("在给定容许应变与搜索限内未找到可接受的对角超胞匹配。")

        atom_est = self._estimate_atoms(st_top, st_bot, best)
        best["atoms"] = atom_est
        gamma_limit = int(self.tw_gamma_atom_threshold.get()) if hasattr(self, "tw_gamma_atom_threshold") else 500
        if atom_est > gamma_limit * 8:
            raise RuntimeError(
                f"预计原子数≈{atom_est}，过大；请调大步长或缩小角度/网格。"
            )

        # 构造下层超胞
        S_bot = np.eye(3, dtype=int)
        S_bot[0,0] = best["n2"]; S_bot[1,1] = best["m2"]
        bot_sc = st_bot.copy()
        bot_sc.make_supercell(S_bot)

        # 构造上层超胞 + 旋转 + 等比例变形
        S_top = np.eye(3, dtype=int)
        S_top[0,0] = best["n1"]; S_top[1,1] = best["m1"]
        top_sc = st_top.copy()
        top_sc.make_supercell(S_top)

        # 先设一个临时晶格做笛卡尔变换
        # 上层：旋转 + in-plane 等比例 s
        s = float(best["s"])
        # 取上层原笛卡尔 → 应用 Rz 与 s
        t_cart = np.array([site.coords for site in top_sc.sites])  # (Nt,3)
        t_cart[:,:2] = (Rz @ t_cart[:,:2].T).T * s

        # 最终公共 in-plane 晶格使用 B（下层超胞矩阵 B）
        B = A_bot @ np.array([[best["n2"],0],[0,best["m2"]]], dtype=int)
        # 组 3×3 晶格矩阵：c 轴重置为目标真空
        c_len = float(vacuum)
        L_final = np.array([[B[0,0], B[0,1], 0.0],
                            [B[1,0], B[1,1], 0.0],
                            [0.0,    0.0,    c_len]], dtype=float)

        # 把上下层点坐标映射到最终晶格分数坐标
        def cart_to_frac(L, r):
            return np.linalg.solve(L.T, r.T).T  # (N,3)

        b_cart = np.array([site.coords for site in bot_sc.sites])
        # 先把下层坐标重映射到以 B 为 in-plane 的晶格（原 in-plane 已经是 A_bot*n2,m2；z 保持）
        # bot_sc 现有晶格：
        # 先把它的 frac → cart（已是 cart），我们只需要映射到 L_final 的 frac：
        b_frac_final = cart_to_frac(L_final, b_cart)
        t_frac_final = cart_to_frac(L_final, t_cart)

        # 施加滑移（分数坐标，沿 a1,a2）
        t_frac_final[:,0] = (t_frac_final[:,0] + ux) % 1.0
        t_frac_final[:,1] = (t_frac_final[:,1] + uy) % 1.0

        # 分层放置在 z（0.4 与 0.6）
        b_frac_final[:,2] = 0.40
        t_frac_final[:,2] = 0.60

        # 合并为一个 Structure
        species = []
        frac = []
        props = []
        for site, f in zip(bot_sc.sites, b_frac_final):
            species.append(site.species)
            frac.append(f.tolist())
            props.append({"layer":"bot"})
        for site, f in zip(top_sc.sites, t_frac_final):
            species.append(site.species)
            frac.append(f.tolist())
            props.append({"layer":"top"})

        st_final = Structure(Lattice(L_final), species, frac, site_properties=props)

        meta = dict(theta_deg=float(theta_deg), ux=float(ux), uy=float(uy),
                    atoms=len(st_final), n1=best["n1"], m1=best["m1"],
                    n2=best["n2"], m2=best["m2"], strain_scale=s,
                    resid=best["resid"])
        return st_final, meta
    # === CODEX END: twist/shift geometry core ===

    # === CODEX BEGIN: generate twist/shift tasks ===
    def _tw_canonical_registry(self, ux: float, uy: float, lattice2x2):
        """规约 (ux, uy) 到具有代表性的等价点以减少重复。"""
        try:
            import numpy as _np
            import math as _math
        except Exception:
            return (float(ux % 1.0), float(uy % 1.0))

        vec_a = _np.asarray(lattice2x2)[:, 0]
        vec_b = _np.asarray(lattice2x2)[:, 1]
        if vec_a.shape[0] != 2 or vec_b.shape[0] != 2:
            return (float(ux % 1.0), float(uy % 1.0))

        a_len = _np.linalg.norm(vec_a)
        b_len = _np.linalg.norm(vec_b)
        if a_len == 0 or b_len == 0:
            return (float(ux % 1.0), float(uy % 1.0))

        cosang = _np.clip(_np.dot(vec_a, vec_b) / (a_len * b_len), -1.0, 1.0)
        ang = _math.degrees(_math.acos(cosang))

        ux_mod = float(ux % 1.0)
        uy_mod = float(uy % 1.0)

        def _rotate_candidates(order):
            cands = []
            for k in range(order):
                th = 2 * _math.pi * k / order
                rot = _np.array([[_math.cos(th), -_math.sin(th)], [_math.sin(th), _math.cos(th)]])
                u = (rot @ _np.array([ux_mod, uy_mod])) % 1.0
                cands.append((float(u[0]), float(u[1])))
            return min(cands)

        if abs(a_len - b_len) / max(a_len, b_len) < 0.02:
            if abs(ang - 60.0) < 2.0:
                return _rotate_candidates(6)
            if abs(ang - 90.0) < 2.0:
                return _rotate_candidates(4)

        return (ux_mod, uy_mod)

    def _tw_generate(self, single: bool):
        """生成单例或批量遍历任务目录与 POSCAR/INCAR。"""
        try:
            theta_a = float(self.tw_theta_a.get())
            theta_b = float(self.tw_theta_b.get())
            theta_step = float(self.tw_theta_step.get())
            vacuum = float(self.tw_vacuum.get())
            allow_strain = float(self.tw_allow_strain.get())/100.0
            kspacing = float(self.tw_kspacing.get())
            ux_steps = int(self.tw_ux_steps.get())
            uy_steps = int(self.tw_uy_steps.get())
            max_tasks = int(self.tw_max_tasks.get())
        except Exception as e:
            messagebox.showerror(APP_NAME, f"参数错误：{e}")
            return

        twist_enabled = bool(self.tw_enable_twist.get()) if hasattr(self, "tw_enable_twist") else True
        slide_enabled = bool(self.tw_enable_slide.get()) if hasattr(self, "tw_enable_slide") else True
        if slide_enabled:
            slide_enabled = slide_enabled and ux_steps > 0 and uy_steps > 0

        top_p = Path(self.tw_top_path.get()); bot_p = Path(self.tw_bot_path.get())
        if not top_p.exists() or not bot_p.exists():
            messagebox.showwarning(APP_NAME, "请先选择上/下层 POSCAR")
            return

        # 任务组合
        if single or not twist_enabled:
            thetas = [theta_a]
        else:
            thetas = self._tw_linspace(theta_a, theta_b, step=theta_step)

        if single or not slide_enabled:
            uxs = [0.0]
            uys = [0.0]
        else:
            uxs = [i / ux_steps for i in range(ux_steps)]
            uys = [j / uy_steps for j in range(uy_steps)]

        lattice2x2 = None
        if (not single) and slide_enabled and HAS_PYMATGEN and HAS_NUMPY:
            try:
                from pymatgen.core import Structure as _Structure

                st_bot_sample = _Structure.from_file(str(bot_p))
                lattice2x2 = np.array(st_bot_sample.lattice.matrix[:2, :2])
            except Exception:
                lattice2x2 = None

        combos = []
        seen = set()
        for th in thetas:
            for ux in uxs:
                for uy in uys:
                    if slide_enabled and lattice2x2 is not None:
                        cu = self._tw_canonical_registry(ux, uy, lattice2x2)
                    else:
                        cu = (float(ux % 1.0), float(uy % 1.0))
                    key = (round(th, 6), round(cu[0], 6), round(cu[1], 6))
                    if key in seen:
                        continue
                    seen.add(key)
                    combos.append((th, float(cu[0]), float(cu[1])))

        if len(combos) > max_tasks:
            messagebox.showwarning(APP_NAME, f"任务数 {len(combos)} > 上限 {max_tasks}，请降低分辨率或步长")
            return

        proj = self.current_project_path()
        root = proj / "twist_sweep"
        root.mkdir(parents=True, exist_ok=True)

        made = 0; skipped = 0
        for th, ux, uy in combos:
            name = f"theta_{th:+06.2f}_ux_{ux:0.3f}_uy_{uy:0.3f}".replace("+","")
            w = root / name
            w.mkdir(parents=True, exist_ok=True)
            try:
                st, meta = self._tw_build_structure(top_p, bot_p, th, ux, uy, vacuum, allow_strain, search_limit=8)
            except Exception as e:
                # 写个失败标记
                write_text(w / "FAILED.txt", f"{e}\n")
                skipped += 1
                continue
            # 写 POSCAR
            try:
                st.to(fmt="poscar", filename=str(w / "POSCAR"))
            except Exception as e:
                write_text(w / "FAILED.txt", f"写 POSCAR 失败: {e}\n")
                skipped += 1
                continue

            # 准备 INCAR：从项目拷贝或用当前编辑器，补丁 2D 设置 + ISYM=0 + KSPACING
            incar_src = proj / "INCAR"
            if incar_src.exists():
                incar_text = read_text(incar_src)
            else:
                incar_text = self.incar_text.get("1.0", tk.END)

            patch = {
                "ISYM": "0",
                "KSPACING": f"{kspacing}",
                "LWAVE": ".FALSE.",
                "LCHARG": ".TRUE.",
            }
            # 2D 建议：去极化/偶极修正
            more2d = {"LDIPOL": ".TRUE.", "IDIPOL": "3"}
            patch.update(more2d)

            incar_new = self._update_incar_text(incar_text, patch)
            write_text(w / "INCAR", incar_new)

            # KPOINTS：建议不写（让 KSPACING 生效）。若用户执意存在 KPOINTS，可忽略或提示
            # POTCAR：若项目下已有则复制
            pot = proj / "POTCAR"
            if pot.exists():
                try:
                    shutil.copyfile(pot, w / "POTCAR")
                except Exception:
                    pass

            # 记录元数据
            meta_path = w / "meta.json"
            meta2 = dict(meta); meta2.update(dict(path=str(w)))
            (w / "meta.json").write_text(json.dumps(meta2, ensure_ascii=False, indent=2), encoding="utf-8")

            made += 1

            # 可选：自动运行（实验性，依赖你的 run_local.sh 逻辑）
            if self.tw_autorun.get():
                # 简化：在该子目录下直接调用项目的 run_local.sh（需要 vasp 命令可用）
                try:
                    # 复制 run 脚本
                    for script in ("run_local.sh","run_slurm.sh"):
                        if (proj / script).exists():
                            shutil.copyfile(proj / script, w / script)
                            os.chmod(w / script, 0o755)
                    # 后台起本地
                    if (w / "run_local.sh").exists():
                        subprocess.Popen(["bash","-lc", f"cd '{w}' && ./run_local.sh"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, start_new_session=True)
                except Exception:
                    pass

        messagebox.showinfo(APP_NAME, f"生成完成：成功 {made}，跳过 {skipped}（详见各子目录）。输出根目录：{root}")
        # 刷新概览
        self.refresh_project_overview()

    def _tw_linspace(self, a: float, b: float, step: float) -> list:
        if step <= 0: return [a]
        out = []
        x = a
        if b >= a:
            while x <= b + 1e-9:
                out.append(round(x, 10)); x += step
        else:
            while x >= b - 1e-9:
                out.append(round(x, 10)); x -= step
        # 防止小数误差重复
        return sorted(list(dict.fromkeys(out)))
    # === CODEX END: generate twist/shift tasks ===

    # === CODEX BEGIN: collect sweep results ===
    def _tw_collect_results(self):
        """遍历 twist_sweep/* 子目录，收集 gap / total energy / 备注，导出 CSV。"""
        root = self.current_project_path() / "twist_sweep"
        if not root.exists():
            messagebox.showwarning(APP_NAME, "未找到 twist_sweep 目录。")
            return
        rows = []
        for sub in sorted(root.iterdir()):
            if not sub.is_dir(): continue
            theta = ux = uy = None
            try:
                # 从目录名回读参数
                m = re.search(r"theta_([0-9.]+)_ux_([0-9.]+)_uy_([0-9.]+)", sub.name)
                if m:
                    theta = float(m.group(1))
                    ux = float(m.group(2))
                    uy = float(m.group(3))
            except Exception:
                pass

            note = ""
            failf = sub / "FAILED.txt"
            if failf.exists():
                note = ("FAILED: " + read_text(failf).strip().splitlines()[0][:120])

            gap_eV = None
            totalE = None
            # 1) vasprun.xml
            vxml = sub / "vasprun.xml"
            if vxml.exists():
                try:
                    from pymatgen.io.vasp.outputs import Vasprun
                    v = Vasprun(str(vxml), parse_eigen=True, parse_projected_eigen=False)
                    bg = v.get_band_structure().get_band_gap()
                    gap_eV = float(bg.get("energy")) if bg else None
                    # 尝试总能
                    totalE = float(v.final_energy) if v.final_energy is not None else None
                except Exception as e:
                    if not note: note = f"vasprun parse err: {e}"
            # 2) EIGENVAL 兜底
            if gap_eV is None:
                gap_est, _ = self._tw_gap_from_eigenval(sub / "EIGENVAL", sub / "OUTCAR")
                if gap_est is not None: gap_eV = gap_est
            # 3) TOTEN 兜底
            if totalE is None:
                try:
                    outcar = read_text(sub / "OUTCAR")
                    mt = re.search(r"free\s+energy\s+TOTEN\s*=\s*([-\d.Ee+]+)", outcar, flags=re.I)
                    if mt: totalE = float(mt.group(1))
                except Exception:
                    pass

            rows.append(dict(path=sub.name, theta=theta, ux=ux, uy=uy, gap_eV=gap_eV, totalE=totalE, note=note))

        # 写 CSV
        csv_path = root / "results.csv"
        with csv_path.open("w", encoding="utf-8") as f:
            f.write("path,theta,ux,uy,gap_eV,totalE_eV,note\n")
            for r in rows:
                def _fmt(v):
                    if v is None: return ""
                    if isinstance(v, float): return f"{v:.6f}"
                    return str(v)
                f.write(",".join([r["path"], _fmt(r["theta"]), _fmt(r["ux"]), _fmt(r["uy"]), _fmt(r["gap_eV"]), _fmt(r["totalE"]), (r["note"] or "").replace(",",";")]) + "\n")

        messagebox.showinfo(APP_NAME, f"已导出汇总：{csv_path}")

    def _tw_gap_from_eigenval(self, eig_path: Path, outcar_path: Path):
        """非常规兜底：从 EIGENVAL + OUTCAR(E_F) 粗略估算带隙。返回 (gap, is_direct?)；失败返回 (None,None)。"""
        try:
            if not eig_path.exists(): return (None, None)
            ef = None
            try:
                txt = read_text(outcar_path)
                m = re.search(r"(?mi)E-fermi\s*:\s*([-\d.Ee+]+)", txt)
                if m: ef = float(m.group(1))
            except Exception:
                pass
            lines = read_text(eig_path).splitlines()
            # 第6行包含 NKPTS, NBANDS
            nk, nb = map(int, lines[5].split()[:2])
            i = 6
            energies = []
            occs = []
            for _ in range(nk):
                # 跳 k 行前的空行
                while i < len(lines) and not lines[i].strip():
                    i += 1
                i += 1  # 跳 kx ky kz w
                ks = []
                os = []
                for b in range(nb):
                    parts = lines[i].split()
                    e = float(parts[1])
                    o = float(parts[2]) if len(parts) > 2 else 0.0
                    ks.append(e); os.append(o); i += 1
                energies.append(ks); occs.append(os)
            # 估计 VBM/CBM（以占据 0.5 为界，若有 EF 则先减 EF）
            if ef is not None:
                energies = [[e-ef for e in ks] for ks in energies]
            vbm = max(max(e for e,o in zip(ks,os) if o > 0.5) for ks,os in zip(energies,occs))
            cbm = min(min(e for e,o in zip(ks,os) if o < 0.5) for ks,os in zip(energies,occs))
            gap = max(0.0, cbm - vbm)
            return (gap, None)
        except Exception:
            return (None, None)
    # === CODEX END: collect sweep results ===

    # ------------------------- 页面：流程助手 ------------------------------
    def _build_workflow_page(self, parent):
        frame = ttk.Frame(parent)

        intro = ttk.Label(
            frame,
            text="按照从上到下的步骤完成一次 VASP 计算，可点击按钮快速跳转到对应面板。",
            wraplength=900,
            justify=tk.LEFT,
        )
        intro.pack(fill=tk.X, padx=12, pady=8)

        status_box = ttk.LabelFrame(frame, text="当前项目状态")
        status_box.pack(fill=tk.BOTH, expand=False, padx=12, pady=6)

        status_row = ttk.Frame(status_box)
        status_row.pack(fill=tk.X, padx=8, pady=6)
        ttk.Label(status_row, text="运行状态：").pack(side=tk.LEFT)
        ttk.Label(status_row, textvariable=self.run_status_var).pack(side=tk.LEFT, padx=4)
        ttk.Button(status_row, text="刷新状态", command=self.refresh_run_status).pack(side=tk.RIGHT)

        tree_frame = ttk.Frame(status_box)
        tree_frame.pack(fill=tk.BOTH, expand=True, padx=8, pady=(0, 6))
        columns = ("name", "status", "detail")
        self.workflow_tree = ttk.Treeview(tree_frame, columns=columns, show="headings", height=6)
        self.workflow_tree.heading("name", text="项目项")
        self.workflow_tree.heading("status", text="状态")
        self.workflow_tree.heading("detail", text="详情")
        self.workflow_tree.column("name", width=120, anchor=tk.W)
        self.workflow_tree.column("status", width=120, anchor=tk.W)
        self.workflow_tree.column("detail", anchor=tk.W, stretch=True)
        tree_scroll = ttk.Scrollbar(tree_frame, orient=tk.VERTICAL, command=self.workflow_tree.yview)
        self.workflow_tree.configure(yscrollcommand=tree_scroll.set)
        self.workflow_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        tree_scroll.pack(side=tk.RIGHT, fill=tk.Y)

        sugg = ttk.Frame(status_box)
        sugg.pack(fill=tk.BOTH, expand=False, padx=8, pady=(0, 6))
        ttk.Label(sugg, text="运行建议：").pack(anchor=tk.W)
        wf_suggest = ScrolledText(sugg, height=4, wrap="word", state="disabled")
        wf_suggest.pack(fill=tk.X, expand=True)
        self._register_suggestion_widget(wf_suggest)

        steps = [
            (
                "① 准备项目目录",
                "选择/新建项目文件夹，所有输入输出文件都保存在此处。",
                [
                    ("选择项目", self.choose_project),
                    ("新建项目", self.create_project),
                    ("快速体检", self.quick_check),
                ],
                self.page_inputs,
            ),
            (
                "② 编辑输入文件",
                "填写 INCAR、POSCAR、KPOINTS 等输入，确保必要信息完整。",
                [
                    ("跳转到输入面板", lambda: self.goto_tab(self.page_inputs)),
                    ("跳转到 K 点设置", lambda: self.goto_tab(self.page_inputs)),
                ],
                self.page_inputs,
            ),
            (
                "③ 准备 POTCAR",
                "解析 POSCAR 元素并在 POTCAR 面板一键拼接所需赝势。",
                [
                    ("跳转到 POTCAR", lambda: self.goto_tab(self.page_inputs)),
                    ("解析元素", self.show_poscar_elements),
                ],
                self.page_inputs,
            ),
            (
                "④ 配置运行方式",
                "根据实际环境选择本地/WSL/SLURM 运行，并生成脚本。",
                [
                    ("跳转到运行页", lambda: self.goto_tab(self.page_run)),
                    ("生成运行脚本", self.write_job_script),
                ],
                self.page_run,
            ),
            (
                "⑤ 启动并监视",
                "启动计算后，利用监视页关注能量收敛、CPU 使用率及文件增长。",
                [
                    ("启动/提交", self.start_run),
                    ("跳转到监视", lambda: self.goto_tab(self.page_monitor)),
                    ("开始监视", self.start_monitor),
                ],
                self.page_monitor,
            ),
            (
                "⑥ 后处理与结果",
                "提取最终能量或绘制一次性曲线，整理输出文件。",
                [
                    ("跳转到后处理", lambda: self.goto_tab(self.page_post)),
                    ("提取最终能量", self.extract_final_energy),
                ],
                self.page_post,
            ),
        ]

        steps_frame = ttk.Frame(frame)
        steps_frame.pack(fill=tk.BOTH, expand=True, padx=12, pady=6)
        steps_frame.grid_columnconfigure(0, weight=1)
        steps_frame.grid_columnconfigure(1, weight=1)
        for idx, (title, desc, buttons, page) in enumerate(steps):
            row, col = divmod(idx, 2)
            box = ttk.LabelFrame(steps_frame, text=title)
            box.grid(row=row, column=col, sticky="nsew", padx=6, pady=6)
            ttk.Label(box, text=desc, justify=tk.LEFT, wraplength=360).pack(anchor=tk.W, padx=8, pady=4)
            row_frame = ttk.Frame(box)
            row_frame.pack(anchor=tk.W, padx=8, pady=4)
            for txt, cmd in buttons:
                ttk.Button(row_frame, text=txt, command=cmd).pack(side=tk.LEFT, padx=4)
            ttk.Button(row_frame, text="打开此面板", command=lambda p=page: self.goto_tab(p)).pack(side=tk.LEFT, padx=8)

        notes = ttk.LabelFrame(frame, text="流程备注 / 待办")
        notes.pack(fill=tk.BOTH, expand=True, padx=12, pady=8)
        self.workflow_notes = ScrolledText(notes, height=8, wrap="word")
        self.workflow_notes.pack(fill=tk.BOTH, expand=True, padx=6, pady=6)
        self.workflow_notes.insert(
            tk.END,
            "可在此记录当前任务的特殊参数、检查列表或备注。内容不会自动保存。",
        )
        return frame

    def kpoints_to_editor(self):
        s = gen_kpoints_monkhorst(self.k_nx.get(), self.k_ny.get(), self.k_nz.get(), self.k_gamma.get())
        self.kpoints_text.delete("1.0", tk.END)
        self.kpoints_text.insert("1.0", s)

    def kpoints_save(self):
        proj = self.current_project_path()
        proj.mkdir(parents=True, exist_ok=True)
        s = self.kpoints_text.get("1.0", tk.END)
        write_text(proj / "KPOINTS", s)
        messagebox.showinfo(APP_NAME, f"KPOINTS 已保存到 {proj/'KPOINTS'}")
        self.refresh_project_overview()

    def goto_tab(self, page):
        try:
            self.nb.select(page)
        except Exception:
            pass


    def append_run_log(self, msg: str):
        text = (msg or "")
        lines = text.splitlines() or [""]
        for line in lines:
            self.run_log.insert(tk.END, line.rstrip("\n") + "\n")
        self.run_log.see(tk.END)

    # ====== 非阻塞跟随 vasp.out 到 GUI ======
    def _start_following_log(self, log_path: Path, interval_ms: int = 500):
        """非阻塞跟随 log_path，将新增内容追加到 self.run_log。"""
        self._log_path = Path(log_path)
        self._tail_pos = 0
        self._tail_interval = int(interval_ms)
        # 若之前有定时任务，先取消
        if hasattr(self, "_tail_job") and self._tail_job:
            try:
                self.after_cancel(self._tail_job)
            except Exception:
                pass
        # 立即触发一次
        self._follow_log_tick()

    def _follow_log_tick(self):
        chunk = ""
        try:
            with open(self._log_path, "r", encoding="utf-8", errors="ignore") as f:
                f.seek(getattr(self, "_tail_pos", 0))
                chunk = f.read(64 * 1024)  # 每 tick 最多 64KB
                self._tail_pos = f.tell()
        except FileNotFoundError:
            pass
        except Exception as e:
            chunk = f"[log-follow] 读取失败：{e}\n"
        if chunk:
            self.append_run_log(chunk)
        self._tail_job = self.after(getattr(self, "_tail_interval", 500), self._follow_log_tick)

    def _stop_following_log(self):
        if hasattr(self, "_tail_job") and self._tail_job:
            try:
                self.after_cancel(self._tail_job)
            except Exception:
                pass
            self._tail_job = None

    def _int_from_var(self, var, default=0) -> int:
        try:
            value = var.get()
        except Exception:
            value = default
        try:
            return int(value)
        except Exception:
            try:
                return int(default)
            except Exception:
                return 0

    # ------------------------- 页面：运行 / 提交 ----------------------------
    def _build_run_page(self, parent):
        frame = ttk.Frame(parent)

        status = ttk.LabelFrame(frame, text="运行状态")
        status.pack(fill=tk.X, padx=8, pady=6)
        row = ttk.Frame(status)
        row.pack(fill=tk.X, padx=6, pady=4)
        ttk.Label(row, text="当前状态：").pack(side=tk.LEFT)
        ttk.Label(row, textvariable=self.run_status_var).pack(side=tk.LEFT, padx=4)
        ttk.Button(row, text="刷新状态", command=self.refresh_run_status).pack(side=tk.RIGHT)
        run_suggest = ScrolledText(status, height=3, wrap="word", state="disabled")
        run_suggest.pack(fill=tk.X, padx=6, pady=(0, 6))
        self._register_suggestion_widget(run_suggest)

        # 运行方式
        row0 = ttk.LabelFrame(frame, text="运行方式")
        row0.pack(fill=tk.X, padx=8, pady=8)
        self.run_mode = tk.StringVar(value="local")
        ttk.Radiobutton(row0, text="本地 mpirun", value="local", variable=self.run_mode).pack(side=tk.LEFT, padx=8)
        ttk.Radiobutton(row0, text="WSL2 (Windows)", value="wsl", variable=self.run_mode).pack(side=tk.LEFT, padx=8)
        ttk.Radiobutton(row0, text="SLURM 集群", value="slurm", variable=self.run_mode).pack(side=tk.LEFT)

        # VASP 执行文件 & 核心数
        row1 = ttk.LabelFrame(frame, text="VASP 执行配置")
        row1.pack(fill=tk.X, padx=8, pady=4)
        ttk.Label(row1, text="VASP 命令").grid(row=0, column=0, sticky=tk.W, padx=6, pady=4)
        self.vasp_cmd = tk.StringVar(value="vasp_std")
        ttk.Entry(row1, textvariable=self.vasp_cmd, width=30).grid(row=0, column=1, sticky=tk.W)
        ttk.Button(row1, text="which?", command=self.which_vasp).grid(row=0, column=2, padx=6)

        ttk.Label(row1, text="MPI 进程数 -np").grid(row=1, column=0, sticky=tk.W, padx=6, pady=4)
        self.mpi_np = tk.IntVar(value=8)
        # 新增：自动并行
        self.auto_parallel = tk.BooleanVar(value=True)
        ttk.Checkbutton(row1, text="自动并行（智能设置 KPAR/NCORE）",
                        variable=self.auto_parallel).grid(row=2, column=0, columnspan=3, sticky=tk.W, padx=6)
        ttk.Spinbox(row1, from_=1, to=2048, textvariable=self.mpi_np, width=8).grid(row=1, column=1, sticky=tk.W)

        # SLURM 区域
        row2 = ttk.LabelFrame(frame, text="SLURM 提交（仅在选择 SLURM 运行时使用）")
        row2.pack(fill=tk.X, padx=8, pady=4)
        self.slurm_part = tk.StringVar(value="normal")
        self.slurm_time = tk.StringVar(value="02:00:00")
        self.slurm_nodes = tk.IntVar(value=1)
        self.slurm_ntasks = tk.IntVar(value=32)
        self.slurm_account = tk.StringVar(value="")
        ttk.Label(row2, text="分区").grid(row=0, column=0, sticky=tk.W, padx=6, pady=4)
        ttk.Entry(row2, textvariable=self.slurm_part, width=12).grid(row=0, column=1)
        ttk.Label(row2, text="时长").grid(row=0, column=2, sticky=tk.W, padx=6)
        ttk.Entry(row2, textvariable=self.slurm_time, width=12).grid(row=0, column=3)
        ttk.Label(row2, text="节点").grid(row=0, column=4, sticky=tk.W, padx=6)
        ttk.Spinbox(row2, from_=1, to=128, textvariable=self.slurm_nodes, width=6).grid(row=0, column=5)
        ttk.Label(row2, text="ntasks").grid(row=0, column=6, sticky=tk.W, padx=6)
        ttk.Spinbox(row2, from_=1, to=8192, textvariable=self.slurm_ntasks, width=8).grid(row=0, column=7)
        ttk.Label(row2, text="账号").grid(row=0, column=8, sticky=tk.W, padx=6)
        ttk.Entry(row2, textvariable=self.slurm_account, width=12).grid(row=0, column=9)

        btns = ttk.Frame(frame)
        btns.pack(fill=tk.X, padx=8, pady=8)
        ttk.Button(btns, text="生成运行脚本", command=self.write_job_script).pack(side=tk.LEFT)
        ttk.Button(btns, text="启动/提交", command=self.start_run).pack(side=tk.LEFT, padx=8)
        ttk.Button(btns, text="停止本地进程", command=self.stop_local).pack(side=tk.LEFT)

        self.run_log = ScrolledText(frame, height=14, wrap="word")
        self.run_log.pack(fill=tk.BOTH, expand=True, padx=8, pady=8)

        return frame

    @staticmethod
    def is_windows() -> bool:
        return os.name == "nt" or sys.platform.startswith("win")

    def win_to_wsl_path(self, p: Path) -> str:
        # 将 Windows 路径 C:\foo\bar 转为 /mnt/c/foo/bar
        s = str(p)
        if len(s) >= 2 and s[1] == ":":
            drive = s[0].lower()
            rest = s[2:].replace("\\", "/")
            return f"/mnt/{drive}{rest if rest.startswith('/') else '/' + rest}"
        return s.replace("\\", "/")

    def which_vasp(self):
        cmd = self.vasp_cmd.get().strip()
        path = which(cmd)
        if path:
            messagebox.showinfo(APP_NAME, f"{cmd} -> {path}")
        else:
            messagebox.showwarning(APP_NAME, f"未在 PATH 中找到 {cmd}")

    def write_job_script(self):
        """生成 run_local.sh / run_slurm.sh（含自动并行设置与稳健环境）。"""
        proj = self.current_project_path()
        proj.mkdir(parents=True, exist_ok=True)

        # —— 可选额外库（只拼接存在的路径，不会写坏环境）——
        extra_libs = []
        for pth in ["/home/yu/apps/aocl/4.1.0/aocc/lib",
                    "/home/yu/apps/aocc-compiler-4.1.0/lib"]:
            try:
                if Path(pth).exists():
                    extra_libs.append(pth)
            except Exception:
                pass
        extra_ld = ":".join(extra_libs)

        ld_line = (f'export LD_LIBRARY_PATH="{extra_ld}:${{LD_LIBRARY_PATH}}"\n'
                   if extra_ld else 'export LD_LIBRARY_PATH="${LD_LIBRARY_PATH:-}"\n')

        env_lines = (
            "# --- Runtime environment (auto generated) ---\n"
            ': "${LD_LIBRARY_PATH:=}"\n'
            f"{ld_line}"
            'export OMP_NUM_THREADS="${OMP_NUM_THREADS:-1}"\n'
            'export OMP_PROC_BIND="${OMP_PROC_BIND:-true}"\n'
            'export OMP_PLACES="${OMP_PLACES:-cores}"\n'
        )

        vcmd = (self.vasp_cmd.get().strip() if hasattr(self, "vasp_cmd") else "") or "vasp_std"
        mpirun_path = which("mpirun") or "mpirun"
        try:
            np = int(self.mpi_np.get()) if hasattr(self, "mpi_np") else 8
        except Exception:
            np = 8

        # —— 自动并行：写回 KPAR/NCORE（若提供了开关或未提供也尝试）——
        try:
            if hasattr(self, "auto_parallel"):
                if self.auto_parallel.get():
                    self._autotune_parallel_and_write(np)
            else:
                # 没有勾选框也尽量自动一次，不报错即可
                if hasattr(self, "_autotune_parallel_and_write"):
                    self._autotune_parallel_and_write(np)
        except Exception as e:
            self.append_run_log(f"[auto-parallel] 失败：{e}")

        # ===== 本地 run_local.sh =====
        local_script = f"""#!/bin/bash
    set -euo pipefail

    {env_lines}
    cd "{proj}"

    echo "[INFO] Workdir: $(pwd)"
    echo "[INFO] Using mpirun: {mpirun_path}"
    echo "[INFO] VASP cmd    : {vcmd}"
    echo "[INFO] NP          : {np}"
    echo "[INFO] LD_LIBRARY_PATH=$LD_LIBRARY_PATH"
    echo "[INFO] OMP_NUM_THREADS=$OMP_NUM_THREADS"

    # 降低调度与 I/O 优先级；并把 MPI 绑定到 core，降低任务迁移开销
    # 动态选择绑定策略：超过物理核数就用硬件线程
PHYS_CORES=$(lscpu -p=CORE 2>/dev/null | egrep -v '^#' | cut -d, -f2 | sort -u | wc -l | tr -d ' ')
if [ -n "$PHYS_CORES" ] && [ "$PHYS_CORES" -gt 0 ] && [ "{np}" -gt "$PHYS_CORES" ]; then
  BIND="--use-hwthread-cpus --bind-to hwthread --map-by ppr:1:hwthread"
else
  BIND="--bind-to core --map-by ppr:1:core"
fi

nice -n 5 ionice -c2 -n4 \
{mpirun_path} $BIND -np {np} {vcmd} > vasp.out 2>&1

    """

        # ===== SLURM run_slurm.sh =====
        slurm_part = self.slurm_part.get().strip() if hasattr(self, "slurm_part") else "normal"
        slurm_time = self.slurm_time.get().strip() if hasattr(self, "slurm_time") else "02:00:00"
        try:
            slurm_nodes = int(self.slurm_nodes.get()) if hasattr(self, "slurm_nodes") else 1
        except Exception:
            slurm_nodes = 1
        try:
            slurm_ntasks = int(self.slurm_ntasks.get()) if hasattr(self, "slurm_ntasks") else max(np, 1)
        except Exception:
            slurm_ntasks = max(np, 1)
        slurm_account = (self.slurm_account.get().strip() if hasattr(self, "slurm_account") else "")
        acc_line = f"#SBATCH --account={slurm_account}\n" if slurm_account else ""

        slurm_script = f"""#!/bin/bash
    #SBATCH --job-name=vasp
    #SBATCH --partition={slurm_part}
    #SBATCH --time={slurm_time}
    #SBATCH --nodes={slurm_nodes}
    #SBATCH --ntasks={slurm_ntasks}
    {acc_line}set -euo pipefail

    {env_lines}
    cd "{proj}"

    echo "SLURM_JOB_ID=$SLURM_JOB_ID"
    echo "[INFO] Workdir: $(pwd)"
    echo "[INFO] VASP cmd: {vcmd}"
    echo "[INFO] ntasks  : $SLURM_NTASKS"
    echo "[INFO] LD_LIBRARY_PATH=$LD_LIBRARY_PATH"
    echo "[INFO] OMP_NUM_THREADS=$OMP_NUM_THREADS"

    # 绑定到物理核，避免过度超线程导致的抖动
    srun --cpu-bind=cores {vcmd} > vasp.out 2>&1
    """

        # —— 写文件并授权 ——
        try:
            write_text(proj / "run_local.sh", local_script)
            os.chmod(proj / "run_local.sh", 0o755)
            self.append_run_log(f"已生成 {proj / 'run_local.sh'}")
        except Exception as e:
            self.append_run_log(f"[EXC] 写 run_local.sh 失败：{e}")

        try:
            write_text(proj / "run_slurm.sh", slurm_script)
            os.chmod(proj / "run_slurm.sh", 0o755)
            self.append_run_log(f"已生成 {proj / 'run_slurm.sh'}")
        except Exception as e:
            self.append_run_log(f"[EXC] 写 run_slurm.sh 失败：{e}")

        # 刷新界面状态
        self.refresh_project_overview()

    def start_run(self):
        proj = self.current_project_path()
        mode = self.run_mode.get()
        vcmd = self.vasp_cmd.get().strip()

        if not proj.exists():
            messagebox.showerror(APP_NAME, f"项目目录不存在：{proj}")
            return

        # 关键输入文件缺失时提示，但允许继续
        missing = [f for f in ["INCAR", "POSCAR", "POTCAR"] if not (proj / f).exists()]
        if missing:
            if not messagebox.askyesno(
                    APP_NAME,
                    "检测到以下关键输入文件缺失：\n"
                    + "\n".join(missing)
                    + "\n仍要继续启动吗？",
            ):
                return

        if mode == "local":
            # 防止重复起
            if self.proc and self.proc.poll() is None:
                messagebox.showwarning(APP_NAME, "已有本地 VASP 进程在运行。先停止或等待结束。")
                return

            # 基础可用性检查
            if not which("mpirun"):
                messagebox.showerror(APP_NAME, "未找到 mpirun。请安装 OpenMPI/IntelMPI 并加入 PATH。")
                return
            if not which(vcmd):
                messagebox.showerror(APP_NAME, f"未找到 VASP 命令：{vcmd}\n可改填绝对路径，例如 /opt/vasp/vasp_std")
                return

            # 总是重写一次脚本，确保环境最新
            self.write_job_script()
            # 替换 start_run() 内 local 分支里 “后台运行脚本” 那一段
            runsh = proj / "run_local.sh"
            try:
                # 使用 Popen 非阻塞启动脚本本身，而不是在主线程里 check_output
                self.proc = subprocess.Popen(
                    ["bash", "-lc", f"cd '{proj}' && exec './{runsh.name}'"],
                    stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL,
                    start_new_session=True  # 关键：新会话，便于后续整组终止
                )
                self.append_run_log(f"[run_local.sh pid] {self.proc.pid}")

                # 启动非阻塞日志跟随
                self._start_following_log(proj / "vasp.out")
                self.append_run_log("日志跟随 vasp.out（非阻塞）已启动。\n")

                # 改为 after 定时健康检查（避免 time.sleep 阻塞 Tk）
                def _health_check():
                    vout = proj / "vasp.out"
                    if not vout.exists() or vout.stat().st_size == 0:
                        # 再等 2 秒复查一次
                        self.after(2000, _health_check)
                        return
                    # 有输出就启动监视器
                    self.start_monitor()

                self.after(1500, _health_check)

            except Exception as e:
                self.append_run_log(f"[EXC] 启动失败：{e}")
                messagebox.showerror(APP_NAME, f"启动失败：{e}")
                return

        elif mode == "wsl":
            messagebox.showerror(APP_NAME, "WSL 分支未内置 AOCL/AOCC 环境设置，请使用本地或 SLURM。")
            return

        else:
            # SLURM：写脚本并 sbatch
            if not which("sbatch"):
                messagebox.showerror(APP_NAME, "未找到 sbatch。请在 SLURM 节点上运行或配置环境。")
                return
            self.write_job_script()
            script = proj / "run_slurm.sh"
            try:
                out = subprocess.check_output(["bash", "-lc", f"cd '{proj}' && sbatch '{script.name}'"], text=True)
                if out:
                    self.append_run_log(out)
                self.start_monitor()
            except subprocess.CalledProcessError as e:
                messagebox.showerror(APP_NAME, f"sbatch 失败：{e}{e.output}")

    def stop_local(self):
        try:
            if self.proc and self.proc.poll() is None:
                # 发送到整组（需要 start_new_session=True）
                os.killpg(os.getpgid(self.proc.pid), 15)  # SIGTERM
                time.sleep(0.5)
                if self.proc.poll() is None:
                    os.killpg(os.getpgid(self.proc.pid), 9)  # SIGKILL
                self.append_run_log("已停止本地 VASP 进程组。\n")
            else:
                # 兜底：旧行为
                subprocess.call(["bash", "-lc", f"pkill -f 'vasp' || true"])
                self.append_run_log("已尝试 pkill -f 'vasp'。\n")
            self.refresh_run_status()
        except Exception as e:
            messagebox.showerror(APP_NAME, f"停止失败：{e}")

    # ------------------------- 页面：监视 ----------------------------------
    def _build_monitor_page(self, parent):
        frame = ttk.Frame(parent)

        status_box = ttk.LabelFrame(frame, text="运行状态概览")
        status_box.pack(fill=tk.X, padx=8, pady=10)
        row = ttk.Frame(status_box)
        row.pack(fill=tk.X, padx=6, pady=8)
        ttk.Label(row, text="当前状态：").pack(side=tk.LEFT)
        ttk.Label(row, textvariable=self.run_status_var).pack(side=tk.LEFT, padx=4)
        ttk.Button(row, text="刷新状态", command=self.refresh_run_status).pack(side=tk.RIGHT)
        monitor_suggest = ScrolledText(status_box, height=3, wrap="word", state="disabled")
        monitor_suggest.pack(fill=tk.X, padx=6, pady=(2, 8))
        self._register_suggestion_widget(monitor_suggest)

        top = ttk.Frame(frame)
        top.pack(fill=tk.X, padx=8, pady=6)
        ttk.Button(top, text="开始监视", command=self.start_monitor).pack(side=tk.LEFT)
        ttk.Button(top, text="停止监视", command=self.stop_monitor).pack(side=tk.LEFT, padx=6)
        ttk.Label(top, text="文件列表(逗号分隔)").pack(side=tk.LEFT, padx=6)
        self.file_watch_var = tk.StringVar(value="vasp.out,OSZICAR,OUTCAR")
        ttk.Entry(top, textvariable=self.file_watch_var, width=36).pack(side=tk.LEFT)

        fig = Figure(figsize=(6, 4), dpi=100)
        self.ax = fig.add_subplot(111)
        self.ax.set_xlabel("Step")
        self.ax.set_ylabel("Total energy (F or E0) [eV]")
        self.ax.grid(True, linestyle=":", linewidth=0.8)
        self.line, = self.ax.plot([], [], marker="o", linestyle="-")

        self.canvas = FigureCanvasTkAgg(fig, master=frame)
        self.canvas.draw()
        self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True, padx=8, pady=8)

        # ETA 显示
        eta_row = ttk.Frame(frame)
        eta_row.pack(fill=tk.X, padx=8, pady=(0, 4))
        ttk.Label(eta_row, text="预计剩余时间：").pack(side=tk.LEFT)
        self.eta_var = tk.StringVar(value="—")
        self.eta_label = ttk.Label(eta_row, textvariable=self.eta_var, foreground="#2b8a3e")
        self.eta_label.pack(side=tk.LEFT, padx=6)
        ttk.Label(eta_row, text="(基于最近 SCF 平均耗时与 OSZICAR 迭代统计)").pack(side=tk.LEFT, padx=6)

        self.mon_info = ScrolledText(frame, height=6, wrap="word")
        self.mon_info.pack(fill=tk.BOTH, expand=False, padx=8, pady=4)

        sys_frame = ttk.LabelFrame(frame, text="系统状态：CPU / 进程 / 文件增长")
        sys_frame.pack(fill=tk.BOTH, expand=False, padx=8, pady=6)
        self.sys_info = ScrolledText(sys_frame, height=10, wrap="word")
        self.sys_info.pack(fill=tk.BOTH, expand=True, padx=6, pady=6)

        self.sys_info.insert(tk.END, "点击“开始监视”以获取实时系统信息。\n")

        return frame

    def start_monitor(self):
        self.stop_monitor()
        proj = self.current_project_path()
        self.monitor = EnergyMonitor(proj, self.on_energy_update)
        self.monitor.start()
        self.mon_info.insert(tk.END, f"开始监视 {proj / 'OSZICAR'}\n")
        self.mon_info.see(tk.END)
        watch_files = [s.strip() for s in self.file_watch_var.get().split(",") if s.strip()]
        self.sys_monitor = SystemStatsMonitor(proj, watch_files, self.on_system_update)
        self.sys_monitor.start()
        self.sys_info.delete("1.0", tk.END)
        self.sys_info.insert(tk.END, "系统监视线程已启动……\n")
        self.apply_run_status("🟡 正在监视…", ["系统监视线程已启动，等待数据更新。"])

        # <<< 新增：初始化刷新一次 ETA >>>
        self._update_eta()

    def stop_monitor(self):
        if self.monitor:
            self.monitor.stop()
            self.monitor = None
        if self.sys_monitor:

            monitor = self.sys_monitor
            self.sys_monitor = None
            monitor.stop()
        self.mon_info.insert(tk.END, "已停止监视。\n")
        self.mon_info.see(tk.END)
        self.sys_info.insert(tk.END, "系统监视已停止。\n")
        self.refresh_run_status()
        self._stop_following_log()

    def on_energy_update(self, steps, energies):
        def _upd():
            # 初始化坐标轴标签只做一次
            if not hasattr(self, "_plot_inited"):
                self.ax.set_xlabel("Step")
                self.ax.set_ylabel("Total energy (F or E0) [eV]")
                self.ax.grid(True, linestyle=":", linewidth=0.8)
                self._plot_inited = True

            # ★ 不再 cla：直接更新 Line2D 数据
            self.line.set_data(steps or [], energies or [])
            self.ax.relim()
            self.ax.autoscale_view()

            self.canvas.draw_idle()
            # 保证布局立即刷新
            self.canvas.get_tk_widget().update_idletasks()

            if energies:
                self.mon_info.insert(tk.END, f"最新步：{steps[-1]}, 能量：{energies[-1]:.6f} eV\n")
                self.mon_info.see(tk.END)

            # 顺手刷新 ETA
            self._update_eta()

        self.after(0, _upd)

    def on_system_update(self, stats):
        def _upd():
            self._handle_stats(stats)
            lines = []
            run_state = stats.get("run_state")
            run_pids = stats.get("run_pids", [])
            if run_state == "running" and run_pids:
                lines.append(f"运行状态：运行中 (PID {', '.join(run_pids)})")
            elif run_state == "idle":
                lines.append("运行状态：未检测到 VASP 进程")
            else:
                lines.append("运行状态：未知")
            lines.append(f"时间：{stats.get('timestamp', '-')}")
            cpu = stats.get("cpu_usage")
            if cpu is not None:
                lines.append(f"CPU 使用率：{cpu:.1f}%")
            load = stats.get("loadavg")
            if load:
                lines.append(f"平均负载：{load[0]:.2f}, {load[1]:.2f}, {load[2]:.2f}")
            lines.append("监视文件：")
            for item in stats.get("files", []):
                name = item.get("name", "-")
                if item.get("exists"):
                    size = format_bytes(item.get("size"))
                    delta = format_bytes(item.get("delta"))
                    lines.append(f"  {name}: {size} (Δ {delta})")
                else:
                    lines.append(f"  {name}: 未找到")
            procs = stats.get("processes", [])
            if procs:
                lines.append("相关进程 (前5按CPU)：")
                for p in procs:
                    mark = "★" if p.get("is_vasp") else " "
                    lines.append(
                        f" {mark} PID {p.get('pid')} {p.get('cmd')} | CPU {p.get('cpu')} | MEM {p.get('mem')}"
                    )
            else:
                lines.append("未获取到进程信息 (可能无 ps 命令或权限不足)。")
            self.sys_info.delete("1.0", tk.END)
            self.sys_info.insert(tk.END, "\n".join(lines) + "\n")

            # <<< 新增：系统状态更新后也刷新 ETA（即便 OSZICAR 暂未增长，仍可用 vasp.out 的 LOOP） >>>
            self._update_eta()

        self.after(0, _upd)

    def _estimate_eta_text(self) -> str:
        """综合 OSZICAR/vasp.out/INCAR 估算 ETA。优先针对几何优化 (NSW>0)。"""
        proj = self.current_project_path()
        osz = proj / "OSZICAR"
        vout = proj / "vasp.out"
        incar = proj / "INCAR"

        # 解析步数配置
        NSW = _parse_incar_int(incar, "NSW", None)
        NELM = _parse_incar_int(incar, "NELM", 60)  # 若未给出，VASP 默认 60

        # 统计 OSZICAR：已完成离子步、平均每步迭代数
        steps_done, avg_iter = _oszicar_stats(osz)

        # 统计 vasp.out：最近单次 SCF 的平均耗时（中位数更稳）
        t_per_scf, seen_loops = _vaspout_loop_times(vout, take_last=40)

        # 默认兜底
        if avg_iter is None:
            avg_iter = 8.0  # 常见数量级 6~15 之间
        if t_per_scf is None:
            return "—"

        # 情况A：几何优化 (NSW>0)
        if NSW and NSW > 0:
            remain_steps = max(NSW - steps_done, 0)
            eta_sec = remain_steps * avg_iter * t_per_scf
            # 若刚开始，给个宽松区间
            if steps_done <= 1:
                eta_sec *= 1.3
            return _fmt_eta_seconds(eta_sec)

        # 情况B：静态或单步 (NSW<=0) → 用 NELM 估一个上界
        # 估计已完成迭代数 = vasp.out LOOP 行数（近似）
        done_iters = seen_loops
        remain_iters = max((NELM or 60) - done_iters, 0)
        eta_sec = remain_iters * t_per_scf
        return _fmt_eta_seconds(eta_sec)

    def _update_eta(self):
        try:
            self.eta_var.set(self._estimate_eta_text())
        except Exception:
            self.eta_var.set("—")

    # ------------------------- 页面：后处理 ---------------------------
    def _build_post_page(self, parent):
        frame = ttk.Frame(parent)
        row = ttk.Frame(frame)
        row.pack(fill=tk.X, padx=8, pady=8)
        ttk.Button(row, text="收敛曲线（OSZICAR）→ 图/CSV", command=self.export_convergence).pack(side=tk.LEFT)
        ttk.Button(row, text="总 DOS（DOSCAR）→ 图/CSV", command=self.export_dos_total).pack(side=tk.LEFT, padx=8)
        ttk.Button(row, text="能带（EIGENVAL）→ 图/CSV", command=self.export_bands).pack(side=tk.LEFT)
        self.post_log = ScrolledText(frame, height=18, wrap="word")
        self.post_log.pack(fill=tk.BOTH, expand=True, padx=8, pady=8)
        return frame

    def plot_once_from_oszicar(self):
        proj = self.current_project_path()
        osz = proj / "OSZICAR"
        if not osz.exists():
            messagebox.showwarning(APP_NAME, f"{osz} 不存在。")
            return
        steps, energies = [], []
        try:
            with osz.open("r", encoding="utf-8", errors="ignore") as f:
                i = 0
                for line in f:
                    m = ENERGY_RX.search(line)
                    if m:
                        val = m.group(1) or m.group(2)
                        try:
                            e = float(val)
                            i += 1
                            steps.append(i)
                            energies.append(e)
                        except Exception:
                            pass
        except Exception as e:
            messagebox.showerror(APP_NAME, f"解析失败：{e}")
            return
        # 复用监视页画布
        self.on_energy_update(steps, energies)
        self.post_log.insert(tk.END, f"一次性绘制完成，点数：{len(steps)}\n")
        self.post_log.see(tk.END)

    def extract_final_energy(self):
        proj = self.current_project_path()
        osz = proj / "OSZICAR"
        if not osz.exists():
            messagebox.showwarning(APP_NAME, f"{osz} 不存在。")
            return
        last_e = None
        try:
            for line in osz.read_text(encoding="utf-8", errors="ignore").splitlines():
                m = ENERGY_RX.search(line)
                if m:
                    val = m.group(1) or m.group(2)
                    try:
                        last_e = float(val)
                    except Exception:
                        pass
        except Exception as e:
            messagebox.showerror(APP_NAME, f"解析失败：{e}")
            return
        if last_e is None:
            messagebox.showwarning(APP_NAME, "未解析到能量。")
        else:
            self.post_log.insert(tk.END, f"最终能量（最后一步）：{last_e:.6f} eV\n")
            self.post_log.see(tk.END)

    # ------------------------- 配置读写（保存用户设置） ---------------------
    def load_config(self):
        if not CONFIG_PATH.exists():
            return
        try:
            data = json.loads(CONFIG_PATH.read_text(encoding="utf-8"))
        except Exception:
            return
        # 窗口几何
        geom = data.get("geometry")
        if geom:
            try:
                self.geometry(geom)
            except Exception:
                pass
        # 基本变量
        project_path = data.get("project", self.project_var.get())
        self.pot_dir_var.set(data.get("pot_dir", self.pot_dir_var.get()))
        self.run_mode.set(data.get("run_mode", self.run_mode.get()))
        self.vasp_cmd.set(data.get("vasp_cmd", self.vasp_cmd.get()))
        self.figure_style_var.set(data.get("figure_style", self.figure_style_var.get()))
        self.emit_report_var.set(bool(data.get("emit_report", self.emit_report_var.get())))
        try:
            self.mpi_np.set(int(data.get("mpi_np", self.mpi_np.get())))
        except Exception:
            pass
        self.file_watch_var.set(data.get("file_watch", self.file_watch_var.get()))
        # SLURM
        self.slurm_part.set(data.get("slurm_part", self.slurm_part.get()))
        self.slurm_time.set(data.get("slurm_time", self.slurm_time.get()))
        try:
            self.slurm_nodes.set(int(data.get("slurm_nodes", self.slurm_nodes.get())))
            self.slurm_ntasks.set(int(data.get("slurm_ntasks", self.slurm_ntasks.get())))
        except Exception:
            pass
        self.slurm_account.set(data.get("slurm_account", self.slurm_account.get()))
        # K 网格
        k = data.get("kgrid", {})
        for var, key in [(self.k_nx, "nx"),(self.k_ny, "ny"),(self.k_nz, "nz")]:
            try:
                var.set(int(k.get(key, var.get())))
            except Exception:
                pass
        try:
            self.k_gamma.set(bool(k.get("gamma", self.k_gamma.get())))
        except Exception:
            pass
        # 选中的页签
        try:
            idx = int(data.get("tab_index", 0))
            self.nb.select(idx)
        except Exception:
            pass
        self.set_project(project_path)

    def save_config(self):
        data = {
            "geometry": self.geometry(),
            "project": self.project_var.get(),
            "pot_dir": self.pot_dir_var.get(),
            "run_mode": self.run_mode.get(),
            "vasp_cmd": self.vasp_cmd.get(),
            "mpi_np": self._int_from_var(self.mpi_np, 8),
            "figure_style": self.figure_style_var.get(),
            "emit_report": bool(self.emit_report_var.get()),
            "slurm_part": self.slurm_part.get(),
            "slurm_time": self.slurm_time.get(),
            "slurm_nodes": self._int_from_var(self.slurm_nodes, 1),
            "slurm_ntasks": self._int_from_var(self.slurm_ntasks, 32),
            "slurm_account": self.slurm_account.get(),
            "kgrid": {
                "nx": self._int_from_var(self.k_nx, 5),
                "ny": self._int_from_var(self.k_ny, 5),
                "nz": self._int_from_var(self.k_nz, 5),
                "gamma": bool(self.k_gamma.get()),
            },
            "tab_index": self.nb.index("current"),
            "file_watch": self.file_watch_var.get(),
        }
        try:
            CONFIG_DIR.mkdir(parents=True, exist_ok=True)
            CONFIG_PATH.write_text(json.dumps(data, ensure_ascii=False, indent=2), encoding="utf-8")
        except Exception:
            pass

    def _register_suggestion_widget(self, widget: tk.Text):
        self.run_suggestion_widgets.append(widget)

    def current_project_path(self) -> Path:
        val = self.project_var.get()
        try:
            proj = Path(val).expanduser()
        except Exception:
            proj = Path(val)
        self.project_dir = proj
        return proj

    def apply_run_status(self, status_text: str, suggestions: list[str] | None = None):
        self.run_status_var.set(status_text)
        text = "暂无建议。"
        if suggestions:
            text = "\n".join(f"• {s}" for s in suggestions)
        for widget in self.run_suggestion_widgets:
            try:
                widget.configure(state="normal")
                widget.delete("1.0", tk.END)
                widget.insert("1.0", text)
                widget.configure(state="disabled")
            except Exception:
                pass

    def refresh_run_status(self):
        """后台采样 + 主线程更新；带防抖，确保同一时刻最多一个采样线程。"""
        proj = self.current_project_path()
        if not proj.exists():
            self.apply_run_status("⚠️ 项目目录不存在", ["请选择有效的项目路径。"])
            return

        # --- 防抖：已有一次刷新在路上，就直接跳过 ---
        if getattr(self, "_refresh_busy", False):
            return
        self._refresh_busy = True

        watch_files = [s.strip() for s in self.file_watch_var.get().split(",") if s.strip()]

        def _worker():
            try:
                stats = SystemStatsMonitor.snapshot(proj, watch_files)
            except Exception:
                stats = {"run_state": "unknown", "suggestions": ["状态刷新失败。"]}
            finally:
                # 回到主线程：更新 UI，并清除 busy 标记
                def _apply():
                    try:
                        self._handle_stats(stats)
                    finally:
                        self._refresh_busy = False

                self.after(0, _apply)

        threading.Thread(target=_worker, daemon=True).start()

    def _handle_stats(self, stats: dict):
        run_state = stats.get("run_state")
        run_pids = stats.get("run_pids", [])
        if run_state == "running" and run_pids:
            status = f"   运行中 (PID {', '.join(run_pids)})"
        elif run_state == "idle":
            status = "⚪ 未检测到 VASP 进程"
        else:
            status = "⚠️ 状态未知"
        suggestions = stats.get("suggestions") or []
        self.apply_run_status(status, suggestions)
        self.update_overview_with_file_stats(stats.get("files", []))

    def update_overview_with_file_stats(self, file_stats: list[dict]):
        tree = getattr(self, "workflow_tree", None)
        if not tree or not file_stats:
            return
        # 使用现有 iid 判断是否存在
        existing = set(tree.get_children()) | {"__project__", "INCAR", "POSCAR", "KPOINTS", "POTCAR", "CONTCAR",
                                               "vasp.out", "OSZICAR", "OUTCAR"}
        for item in file_stats:
            name = item.get("name")
            if not name:
                continue
            short = Path(name).name
            key = self.overview_key_map.get(short.lower())
            if not key or key not in existing:
                continue
            label = self.overview_label_map.get(key, short)
            if item.get("exists"):
                detail = f"大小 {format_bytes(item.get('size'))}"
                delta = item.get("delta")
                if isinstance(delta, (int, float)):
                    detail += f" | Δ {format_bytes(delta)}"
                status = "📈 输出增长" if isinstance(delta, (int, float)) and delta > 0 else "✅ 已存在"
            else:
                status = "⚠️ 未找到"
                detail = "尚未生成或路径不匹配"
            tree.item(key, values=(label, status, detail))

    def refresh_project_overview(self):
        tree = getattr(self, "workflow_tree", None)
        if not tree:
            return
        for row in tree.get_children():
            tree.delete(row)
        proj = self.current_project_path()
        exists = proj.exists()
        proj_status = "✅ 已存在" if exists else "⚠️ 未找到"
        tree.insert(
            "",
            tk.END,
            iid="__project__",
            values=(self.overview_label_map.get("__project__", "项目目录"), proj_status, str(proj)),
        )
        for key, label in self.overview_items:
            if key == "__project__":
                continue
            path = proj / key
            if path.exists():
                try:
                    stat = path.stat()
                    mtime = time.strftime("%Y-%m-%d %H:%M", time.localtime(stat.st_mtime))
                    status = "✅ 已存在"
                    detail = f"更新于 {mtime} | {format_bytes(stat.st_size)}"
                except Exception:
                    status = "✅ 已存在"
                    detail = "已检测到文件"
            else:
                status = "⚠️ 未找到"
                detail = "项目目录中未检测到该文件"
            tree.insert("", tk.END, iid=key, values=(label, status, detail))

    def load_project_inputs(self):
        proj = self.current_project_path()
        mapping = [
            (proj / "INCAR", getattr(self, "incar_text", None)),
            (proj / "POSCAR", getattr(self, "poscar_text", None)),
            (proj / "KPOINTS", getattr(self, "kpoints_text", None)),
        ]
        for path, widget in mapping:
            if not widget or not path.exists():
                continue
            try:
                widget.delete("1.0", tk.END)
                widget.insert("1.0", read_text(path))
            except Exception:
                pass

    def set_project(self, path: Path):
        try:
            path = Path(path).expanduser()
        except Exception:
            path = Path(path)
        self.project_dir = path
        self.project_var.set(str(path))
        self.load_project_inputs()
        self.refresh_project_overview()
        self.refresh_run_status()

    # ------------------------- 项目与体检 ----------------------------------
    def choose_project(self):
        d = filedialog.askdirectory(initialdir=self.project_var.get(), title="选择项目目录")
        if d:
            self.set_project(Path(d))

    def create_project(self):
        d = filedialog.askdirectory(initialdir=str(Path.home()), title="选择或创建项目父目录")
        if not d:
            return
        # 创建以时间命名的项目
        base = Path(d)
        name = time.strftime("vasp_proj_%Y%m%d_%H%M%S")
        p = base / name
        p.mkdir(parents=True, exist_ok=True)
        self.set_project(p)
        messagebox.showinfo(APP_NAME, f"已创建项目目录：{p}")

    def quick_check(self):
        proj = self.current_project_path()
        summary: list[str] = []
        issues: list[str] = []

        required = ["INCAR", "POSCAR", "POTCAR", "KPOINTS"]
        for name in required:
            path = proj / name
            exists = path.exists()
            mark = "✔" if exists else "✗"
            summary.append(f"{name:7s} : {mark} {path if exists else ''}".rstrip())
            if not exists:
                issues.append(f"未检测到 {name}，请确认是否已保存到项目目录。")

        poscar_text = ""
        poscar_path = proj / "POSCAR"
        if poscar_path.exists():
            poscar_text = read_text(poscar_path)
        else:
            poscar_text = self.poscar_text.get("1.0", tk.END).strip()

        elems = unique_elements_from_poscar(poscar_text) if poscar_text else []
        if elems:
            summary.append("POSCAR 元素: " + ", ".join(elems))
        elif poscar_text:
            issues.append("POSCAR 内容存在但未能解析元素，请检查第6/7行。")
        else:
            issues.append("POSCAR 内容为空。")

        potcar_path = proj / "POTCAR"
        if potcar_path.exists() and elems:
            pot_text = read_text(potcar_path)
            titels = [ln for ln in pot_text.splitlines() if ln.strip().startswith("TITEL")]
            if len(titels) < len(elems):
                issues.append("POTCAR 中的赝势数量少于 POSCAR 元素数量。")

        incar_path = proj / "INCAR"
        incar_text = read_text(incar_path) if incar_path.exists() else self.incar_text.get("1.0", tk.END)
        for key in ("ENCUT", "EDIFF"):
            if not re.search(rf"(?mi)^\s*{re.escape(key)}\s*=", incar_text):
                issues.append(f"INCAR 未设置 {key}，请确认输入参数。")

        for cmd in ["mpirun", self.vasp_cmd.get().strip(), "sbatch", "wsl" if os.name == "nt" else None]:
            if not cmd:
                continue
            resolved = which(cmd)
            summary.append(f"which {cmd:8s} -> {resolved or '未找到'}")
            if resolved is None and cmd not in ("sbatch", "wsl"):
                issues.append(f"未在 PATH 中找到 {cmd}，可能无法直接运行 VASP。")

        potroot = Path(self.pot_dir_var.get())
        summary.append(f"POT 库: {potroot} {'(存在)' if potroot.exists() else '(不存在)'}")
        if not potroot.exists():
            issues.append("赝势库根目录不存在，请重新设置 POTCAR 路径。")

        log_msg = "\n".join(summary)
        self.append_run_log(log_msg + "\n")
        self.refresh_project_overview()
        self.refresh_run_status()

        if issues:
            detail = "\n- " + "\n- ".join(issues)
            messagebox.showwarning(APP_NAME, f"项目体检结果：\n{log_msg}\n\n需关注：{detail}")
        else:
            messagebox.showinfo(APP_NAME, f"项目体检完成：\n{log_msg}\n\n未发现明显问题，可继续下一步。")

    # === 并行推断辅助 ===
    def _read_file_text(self, p: Path) -> str:
        try:
            return p.read_text(encoding="utf-8", errors="ignore")
        except Exception:
            return ""

    def _incar_get(self, key: str) -> int | None:
        txt = self._read_file_text(self.current_project_path() / "INCAR")
        m = re.search(rf"(?mi)^\s*{re.escape(key)}\s*=\s*([-+]?\d+)", txt)
        return int(m.group(1)) if m else None

    def _incar_upsert(self, key: str, val: int):
        """在 INCAR 中插入/更新形如 'KEY = val' 的行：
        - 匹配不区分大小写，仅替换第一处，以保留后续注释或模板段落
        - 保留原有行前缩进
        - 追加时确保文件末尾带换行
        """
        proj = self.current_project_path()
        incar = proj / "INCAR"
        txt = self._read_file_text(incar)

        # 目标行（不带末尾换行，写入时再统一补 '\n'）
        new_line = f"{key:6s} = {val}"

        # 匹配：行首可有空白，然后是 key，再等号到行尾；忽略大小写、多行模式
        # 使用命名分组 'lead' 保留原有缩进
        pattern = re.compile(rf"(?mi)^(?P<lead>\s*){re.escape(key)}\s*=.*$")

        m = pattern.search(txt)
        if m:
            # 仅替换第一处匹配，保持该行原有缩进
            def _repl(mm: re.Match) -> str:
                lead = mm.group('lead') or ''
                return f"{lead}{new_line}"

            txt = pattern.sub(_repl, txt, count=1)
            # 确保文件以换行结尾
            if not txt.endswith("\n"):
                txt += "\n"
        else:
            # 末尾补换行后再追加新行
            if txt and not txt.endswith("\n"):
                txt += "\n"
            txt += new_line + "\n"

        write_text(incar, txt)

    def _infer_nbands(self) -> int | None:
        outcar = self.current_project_path() / "OUTCAR"
        m = re.search(r"(?mi)\bNBANDS\s*=\s*(\d+)", self._read_file_text(outcar))
        return int(m.group(1)) if m else None

    def _infer_kpoints_total(self) -> int | None:
        """粗略从 KPOINTS 取 Monkhorst-Pack 网格乘积；line-mode 留空。"""
        kp = self.current_project_path() / "KPOINTS"
        s = self._read_file_text(kp).splitlines()
        if len(s) >= 4 and re.search(r"(?i)gamma|monkhorst", s[2]):
            try:
                nx, ny, nz = map(int, s[3].split()[:3])
                return max(1, nx * ny * nz)
            except Exception:
                return None
        return None

    def _best_divisor(self, n: int, choices=(8, 6, 4, 3, 2, 1)) -> int:
        for c in choices:
            if n % c == 0: return c
        return 1

    def _autotune_parallel_and_write(self, np_total: int):
        """核心：根据 -np / NBANDS / KPOINTS 推断 KPAR 与 NCORE，并写回 INCAR。"""
        # 1) 读现有设置（用户若已手动设定，尊重并只做校验）
        ncore_user = self._incar_get("NCORE")
        kpar_user = self._incar_get("KPAR")

        # 2) 粗略信息
        nbands = self._infer_nbands() or 12  # 缺省 12（小体系常见）
        ktot = self._infer_kpoints_total() or np_total  # 没法判断就放宽

        # 3) 选一个合理的 NCORE（要能整除 -np）
        ncore = ncore_user if ncore_user and np_total % ncore_user == 0 else self._best_divisor(np_total)

        # 4) 估 groups（band 并行组数），不能超过 NBANDS
        groups_max = max(1, nbands)
        # KPAR 先给个上限（不能超过总 k 点的粗略值）
        kpar_max = max(1, min(ktot, np_total // ncore))

        # 若用户指定了 KPAR 就尽量用，否则我们分配尽量多的 k 点并行
        if kpar_user:
            kpar = max(1, min(kpar_user, kpar_max))
        else:
            # 让剩余核数 /ncore 尽量落到“<= NBANDS”的组数
            # np_total = KPAR * NCORE * groups  →  groups = np_total/(KPAR*NCORE)
            kpar = kpar_max
            while kpar > 1 and np_total // (kpar * ncore) > groups_max:
                kpar -= 1
            # 还要让整除成立
            while kpar > 1 and (np_total % (kpar * ncore) != 0):
                kpar -= 1
            kpar = max(1, kpar)

        groups = max(1, np_total // (kpar * ncore))

        # 5) 写回（只有当自动模式勾选或用户未设置时才写）
        if self.auto_parallel.get() or (ncore_user is None):
            self._incar_upsert("NCORE", ncore)
        if self.auto_parallel.get() or (kpar_user is None):
            self._incar_upsert("KPAR", kpar)

        self.append_run_log(
            f"[auto-parallel] np={np_total}, 推断: NCORE={ncore}, KPAR={kpar}, groups≈{groups}, NBANDS≈{nbands}, K总≈{ktot}")

    def _plots_dir(self) -> Path:
        d = self.current_project_path() / "plots"
        d.mkdir(parents=True, exist_ok=True)
        return d

    def export_convergence(self):
        proj = self.current_project_path()
        osz = proj / "OSZICAR"
        if not osz.exists():
            messagebox.showwarning(APP_NAME, f"{osz} 不存在。");
            return
        steps, energies = [], []
        with osz.open("r", encoding="utf-8", errors="ignore") as f:
            i = 0
            for line in f:
                m = ENERGY_RX.search(line)
                if m:
                    val = m.group(1) or m.group(2)
                    try:
                        e = float(val.replace("D", "E").replace("d", "E"))
                        i += 1;
                        steps.append(i);
                        energies.append(e)
                    except:
                        pass
        if not energies:
            messagebox.showwarning(APP_NAME, "OSZICAR 未解析到能量。");
            return

        # 图
        fig = Figure(figsize=(6, 4), dpi=140);
        ax = fig.add_subplot(111)
        ax.plot(steps, energies, marker="o", linestyle="-")
        ax.set_xlabel("Ionic step");
        ax.set_ylabel("Total energy [eV]")
        ax.grid(True, linestyle=":", linewidth=0.8)
        canvas = FigureCanvasTkAgg(fig, master=self.page_post); canvas.draw()
        canvas.draw()

        out = self._plots_dir()
        png = out / "convergence.png";
        svg = out / "convergence.svg";
        csv = out / "convergence.csv"
        fig.savefig(png, bbox_inches="tight");
        fig.savefig(svg, bbox_inches="tight")
        with (csv).open("w", encoding="utf-8") as g:
            g.write("step,energy_eV\n");
            g.writelines(f"{s},{e}\n" for s, e in zip(steps, energies))
        self.post_log.insert(tk.END, f"已导出收敛图：{png}\nSVG：{svg}\nCSV：{csv}\n")

    def _fermi_from_outcar(self) -> float | None:
        m = re.search(r"(?mi)E-fermi\s*:\s*([-\d.Ee+]+)", self._read_file_text(self.current_project_path() / "OUTCAR"))
        return float(m.group(1)) if m else None

    def export_dos_total(self):
        proj = self.current_project_path()
        doscar = proj / "DOSCAR"
        if not doscar.exists():
            messagebox.showwarning(APP_NAME, "未找到 DOSCAR。请先做 DOS 计算。");
            return
        ef = self._fermi_from_outcar() or 0.0

        with doscar.open("r", encoding="utf-8", errors="ignore") as f:
            lines = f.read().splitlines()
        if len(lines) < 6:
            messagebox.showwarning(APP_NAME, "DOSCAR 文件太短。");
            return
        # 第6行起为 DOS 数据，直到 NEDOS 行数结束；简单做法：跳过前5行，直到遇到空行/非数字
        data = []
        for ln in lines[5:]:
            parts = ln.split()
            if len(parts) < 3: break
            try:
                nums = list(map(float, parts))
                data.append(nums)
            except:
                break
        if not data:
            messagebox.showwarning(APP_NAME, "未解析到 DOS 数据。");
            return

        arr = list(zip(*data))  # 转置
        E = [x - ef for x in arr[0]]
        if len(arr) >= 5:  # 自旋极化：E, DOS_up, DOS_dn, Int_up, Int_dn
            DOS = [u + d for u, d in zip(arr[1], arr[2])]
        else:  # 非极化：E, DOS, Int
            DOS = list(arr[1])

        # 图
        fig = Figure(figsize=(6, 4), dpi=140);
        ax = fig.add_subplot(111)
        ax.plot(E, DOS, linewidth=1.2)
        ax.axvline(0.0, linestyle="--", linewidth=0.8)  # EF
        ax.set_xlabel("Energy - $E_F$ (eV)");
        ax.set_ylabel("DOS (states/eV)")
        ax.grid(True, linestyle=":", linewidth=0.8)
        out = self._plots_dir()
        png = out / "dos_total.png";
        svg = out / "dos_total.svg";
        csv = out / "dos_total.csv"
        fig.savefig(png, bbox_inches="tight");
        fig.savefig(svg, bbox_inches="tight")
        with (csv).open("w", encoding="utf-8") as g:
            g.write("E-EF,DOS\n");
            g.writelines(f"{x},{y}\n" for x, y in zip(E, DOS))
        self.post_log.insert(tk.END, f"已导出 DOS：{png}\nSVG：{svg}\nCSV：{csv}\n")

    def export_bands(self):
        proj = self.current_project_path()
        eig = proj / "EIGENVAL"
        if not eig.exists():
            messagebox.showwarning(APP_NAME, "未找到 EIGENVAL。请使用 KPOINTS 路径做 band 计算。");
            return
        ef = self._fermi_from_outcar() or 0.0
        txt = self._read_file_text(eig).splitlines()

        # 头部：第6行通常包含 NKPTS, NBANDS, NIONS
        try:
            parts = txt[5].split()
            nk, nb = int(parts[0]), int(parts[1])
        except Exception:
            messagebox.showwarning(APP_NAME, "EIGENVAL 头部解析失败。");
            return

        i = 6
        kpts = []
        bands = [[] for _ in range(nb)]

        for _ in range(nk):
            # 跳过空行（有些版本每个 k-block 前有空行）
            while i < len(txt) and not txt[i].strip():
                i += 1
            if i >= len(txt):
                break

            # kx ky kz w
            try:
                kx, ky, kz, w = map(float, txt[i].split()[:4])
            except Exception:
                messagebox.showwarning(APP_NAME, "EIGENVAL k 点块格式异常。")
                return
            i += 1
            kpts.append((kx, ky, kz))

            # nb 行： bandIndex, energy, occ
            for b in range(nb):
                parts = txt[i].split()
                e = float(parts[1]) - ef
                bands[b].append(e)
                i += 1

        import math
        xs = [0.0]
        for a, b in zip(kpts[:-1], kpts[1:]):
            xs.append(xs[-1] + math.dist(a, b))

        fig = Figure(figsize=(6, 4), dpi=140)
        ax = fig.add_subplot(111)
        for b in range(nb):
            ax.plot(xs, bands[b], linewidth=0.8)
        ax.axhline(0, linestyle="--", linewidth=0.8)  # EF
        ax.set_xlabel("k-path (arb.)")
        ax.set_ylabel("Energy - $E_F$ (eV)")
        ax.grid(True, linestyle=":", linewidth=0.8)
        out = self._plots_dir()
        png, svg, csv = out / "bands.png", out / "bands.svg", out / "bands.csv"
        fig.savefig(png, bbox_inches="tight")
        fig.savefig(svg, bbox_inches="tight")
        with csv.open("w", encoding="utf-8") as g:
            g.write("k," + ",".join(f"band{b + 1}" for b in range(nb)) + "\n")
            for j in range(nk):
                row = [f"{xs[j]}"] + [f"{bands[b][j]}" for b in range(nb)]
                g.write(",".join(row) + "\n")
        self.post_log.insert(tk.END, f"已导出能带：{png}\nSVG：{svg}\nCSV：{csv}\n")

    def import_project_files(self):
        """把项目目录下的 INCAR/POSCAR/KPOINTS 一键读入三个编辑器，并刷新概览与状态。"""
        self.load_project_inputs()
        self.refresh_project_overview()
        self.refresh_run_status()
        messagebox.showinfo(APP_NAME, "已读取项目文件并刷新状态。")

    # ------------------------- 退出清理 ------------------------------------
    def on_close(self):
        try:
            # 保存配置
            self.save_config()
            # 停止监视与 tail 进程
            self.stop_monitor()
            if self.proc and self.proc.poll() is None:
                self.proc.terminate()
        except Exception:
            pass
        self.destroy()
        self._stop_following_log()


class FirstTimeWizard(tk.Toplevel):
    def __init__(self, master: VaspGUI):
        super().__init__(master)
        self.result: WizardProfile | None = None
        self.title("首次使用向导")
        self.transient(master)
        self.grab_set()
        self.resizable(False, False)
        # 适当扩大初始尺寸，避免表单内容被截断（尤其是第三步的精度设置）
        self.geometry("720x540")
        self.protocol("WM_DELETE_WINDOW", self.on_cancel)

        self.system_type = tk.StringVar(value="semiconductor")
        self.workflow = tk.StringVar(value="relax_scf_dos")
        self.encut_mode = tk.StringVar(value="auto")
        self.encut_value = tk.StringVar(value="520")
        self.k_mode = tk.StringVar(value="kspacing")
        self.kspacing = tk.StringVar(value="0.22")
        self.kgrid = [tk.IntVar(value=6), tk.IntVar(value=6), tk.IntVar(value=6)]
        self.use_slurm = tk.BooleanVar(value=False)
        self.np_var = tk.StringVar(value=str(max(1, master._int_from_var(master.mpi_np, 8))))
        self.slurm_part = tk.StringVar(value=master.slurm_part.get())
        self.slurm_time = tk.StringVar(value=master.slurm_time.get())
        self.slurm_nodes = tk.StringVar(value=str(master.slurm_nodes.get()))
        self.slurm_ntasks = tk.StringVar(value=str(master.slurm_ntasks.get()))
        self.slurm_account = tk.StringVar(value=master.slurm_account.get())
        self.style_var = tk.StringVar(value=master.figure_style_var.get())
        self.emit_report = tk.BooleanVar(value=bool(master.emit_report_var.get()))

        container = ttk.Frame(self, padding=12)
        container.pack(fill=tk.BOTH, expand=True)
        self.step_var = tk.StringVar(value="步骤 1/5")
        ttk.Label(container, textvariable=self.step_var, font=("", 12, "bold")).pack(anchor=tk.W, pady=(0, 8))

        self.stack = ttk.Frame(container)
        self.stack.pack(fill=tk.BOTH, expand=True)
        self.pages: list[ttk.Frame] = []
        self.slurm_widgets: list[ttk.Widget] = []
        self.pages.append(self._build_system_page())
        self.pages.append(self._build_workflow_page())
        self.pages.append(self._build_precision_page())
        self.pages.append(self._build_resource_page())
        self.pages.append(self._build_output_page())

        nav = ttk.Frame(container)
        nav.pack(fill=tk.X, pady=(12, 0))
        self.btn_prev = ttk.Button(nav, text="上一步", command=self.on_prev)
        self.btn_prev.pack(side=tk.LEFT)
        self.btn_cancel = ttk.Button(nav, text="取消", command=self.on_cancel)
        self.btn_cancel.pack(side=tk.RIGHT)
        self.btn_finish = ttk.Button(nav, text="完成", command=self.on_finish)
        self.btn_finish.pack(side=tk.RIGHT, padx=6)
        self.btn_next = ttk.Button(nav, text="下一步", command=self.on_next)
        self.btn_next.pack(side=tk.RIGHT)

        self.current_index = 0
        self._update_page()
        self._center_on_parent(master)

    def _center_on_parent(self, master):
        try:
            self.update_idletasks()
            w = self.winfo_width()
            h = self.winfo_height()
            x = master.winfo_rootx() + (master.winfo_width() - w) // 2
            y = master.winfo_rooty() + (master.winfo_height() - h) // 2
            self.geometry(f"{w}x{h}+{x}+{y}")
        except Exception:
            pass

    def _build_system_page(self) -> ttk.Frame:
        frame = ttk.Frame(self.stack)
        ttk.Label(frame, text="选择体系类型：").pack(anchor=tk.W)
        options = [
            ("metal", "金属（ISMEAR=1, SIGMA≈0.2）"),
            ("semiconductor", "半导体（ISMEAR=0, SIGMA≈0.05）"),
            ("insulator", "绝缘体（ISMEAR=0, SIGMA≈0.05）"),
        ]
        for value, text in options:
            ttk.Radiobutton(frame, text=text, value=value, variable=self.system_type).pack(anchor=tk.W, pady=2)
        ttk.Label(frame, text="该设置用于推荐展宽参数。", foreground="#555555").pack(anchor=tk.W, pady=(6, 0))
        return frame

    def _build_workflow_page(self) -> ttk.Frame:
        frame = ttk.Frame(self.stack)
        ttk.Label(frame, text="选择计算流程：").pack(anchor=tk.W)
        for value, text in [
            ("relax_scf_dos", "Relax → SCF → DOS"),
            ("relax_scf_bands", "Relax → SCF → Bands"),
            ("scf_dos", "SCF → DOS"),
        ]:
            ttk.Radiobutton(frame, text=text, value=value, variable=self.workflow).pack(anchor=tk.W, pady=2)
        ttk.Label(frame, text="流程将决定生成的脚本与建议。", foreground="#555555").pack(anchor=tk.W, pady=(6, 0))
        ttk.Label(
            frame,
            text=(
                "Relax → SCF → DOS（默认）\n"
                "用于“有应力/对齐方式不确定”的结构：先几何优化，再精细自洽，最后基于该电荷做 DOS。\n"
                "可靠稳健，适合多数 2D 扭转/滑移扫描。\n\n"
                "Relax → SCF → Bands\n"
                "目标是能带路径：先 Relax，再 SCF 得到准确电荷，最后用 ICHARG=11 的 band run 走高对称线。\n"
                "适合在 DOS/带隙初筛后，对少量代表构型出图。\n\n"
                "SCF → DOS（无 Relax）\n"
                "当几何已可信或做快速预筛时可直接 SCF，随后投 DOS。速度快，但若未 Relax 可能影响能量和带隙。"
            ),
            wraplength=660,
            justify=tk.LEFT,
            foreground="#444444",
        ).pack(anchor=tk.W, pady=(8, 0))
        return frame

    def _build_precision_page(self) -> ttk.Frame:
        frame = ttk.Frame(self.stack)
        ttk.Label(frame, text="设置精度与 K 网格：").pack(anchor=tk.W)
        encut_box = ttk.LabelFrame(frame, text="ENCUT")
        encut_box.pack(fill=tk.X, pady=4)
        ttk.Radiobutton(encut_box, text="自动（1.3×ENMAX_max）", value="auto", variable=self.encut_mode, command=self._update_state).pack(anchor=tk.W)
        ttk.Radiobutton(encut_box, text="手动指定", value="manual", variable=self.encut_mode, command=self._update_state).pack(anchor=tk.W)
        row = ttk.Frame(encut_box)
        row.pack(anchor=tk.W, pady=4)
        ttk.Label(row, text="ENCUT (eV):").pack(side=tk.LEFT)
        self.encut_entry = ttk.Entry(row, textvariable=self.encut_value, width=8)
        self.encut_entry.pack(side=tk.LEFT, padx=4)
        ttk.Label(
            encut_box,
            text=(
                "自动（推荐）：ENCUT ≈ 1.3 × 元素最大 ENMAX，适合混合元素或批量扫描。\n"
                "手动：仅在做收敛测试或沿用既有基准时使用；常见半导体 450–550 eV，含 O/N/F 时 520–600 eV。"
            ),
            wraplength=640,
            justify=tk.LEFT,
            foreground="#444444",
        ).pack(anchor=tk.W, pady=(4, 0))

        k_box = ttk.LabelFrame(frame, text="K 网格")
        k_box.pack(fill=tk.X, pady=4)
        ttk.Radiobutton(k_box, text="使用 KSPACING", value="kspacing", variable=self.k_mode, command=self._update_state).pack(anchor=tk.W)
        ks_row = ttk.Frame(k_box)
        ks_row.pack(anchor=tk.W, pady=4)
        ttk.Label(ks_row, text="KSPACING:").pack(side=tk.LEFT)
        self.kspacing_entry = ttk.Entry(ks_row, textvariable=self.kspacing, width=8)
        self.kspacing_entry.pack(side=tk.LEFT, padx=4)
        ttk.Radiobutton(k_box, text="使用 Monkhorst-Pack 网格", value="kpoints", variable=self.k_mode, command=self._update_state).pack(anchor=tk.W, pady=(6, 0))
        grid_row = ttk.Frame(k_box)
        grid_row.pack(anchor=tk.W, pady=4)
        for label, var in zip(["Nx", "Ny", "Nz"], self.kgrid):
            ttk.Label(grid_row, text=label).pack(side=tk.LEFT, padx=(0, 2))
            ttk.Spinbox(grid_row, from_=1, to=24, textvariable=var, width=4).pack(side=tk.LEFT, padx=(0, 6))
        ttk.Label(
            k_box,
            text=(
                "KSPACING（推荐）：以倒空间点间距控制密度，随超胞自动缩放。\n"
                "金属/小原胞 0.18–0.22，半导体 0.22–0.30，大莫尔超胞可改为 Γ-only 并放宽到 ~0.35。\n"
                "Monkhorst-Pack：当你明确需要 Nx×Ny×Nz 网格时使用；2D 薄膜通常 Nz=1，金属可考虑取消 Γ 中心。"
            ),
            wraplength=640,
            justify=tk.LEFT,
            foreground="#444444",
        ).pack(anchor=tk.W, pady=(4, 0))
        if not HAS_SEEKPATH:
            ttk.Label(k_box, text="未检测到 seekpath，建议优先使用 KSPACING。", foreground="#aa5500").pack(anchor=tk.W, pady=(4, 0))
        return frame

    def _build_resource_page(self) -> ttk.Frame:
        frame = ttk.Frame(self.stack)
        ttk.Label(frame, text="配置资源：").pack(anchor=tk.W)
        row = ttk.Frame(frame)
        row.pack(anchor=tk.W, pady=4)
        ttk.Label(row, text="本地核数 (-np):").pack(side=tk.LEFT)
        self.np_entry = ttk.Entry(row, textvariable=self.np_var, width=6)
        self.np_entry.pack(side=tk.LEFT, padx=4)
        ttk.Checkbutton(frame, text="使用 SLURM 集群", variable=self.use_slurm, command=self._update_state).pack(anchor=tk.W, pady=(6, 4))
        slurm_box = ttk.LabelFrame(frame, text="SLURM")
        slurm_box.pack(fill=tk.X, pady=4)
        for label, var in [
            ("分区", self.slurm_part),
            ("时长", self.slurm_time),
            ("节点", self.slurm_nodes),
            ("ntasks", self.slurm_ntasks),
            ("账号", self.slurm_account),
        ]:
            r = ttk.Frame(slurm_box)
            r.pack(anchor=tk.W, pady=2)
            ttk.Label(r, text=label + "：").pack(side=tk.LEFT)
            entry = ttk.Entry(r, textvariable=var, width=12)
            entry.pack(side=tk.LEFT, padx=4)
            self.slurm_widgets.append(entry)
        if not shutil.which("squeue"):
            ttk.Label(slurm_box, text="未检测到 SLURM 命令，提交功能可能不可用。", foreground="#aa5500").pack(anchor=tk.W, pady=(4, 0))
        return frame

    def _build_output_page(self) -> ttk.Frame:
        frame = ttk.Frame(self.stack)
        ttk.Label(frame, text="输出选项：").pack(anchor=tk.W)
        ttk.Label(frame, text="期刊风格：").pack(anchor=tk.W)
        ttk.Combobox(frame, values=list(FIG_STYLES.keys()), textvariable=self.style_var, state="readonly").pack(anchor=tk.W, pady=2)
        ttk.Checkbutton(frame, text="生成复现报告", variable=self.emit_report).pack(anchor=tk.W, pady=(6, 2))
        if not HAS_PYMATGEN:
            ttk.Label(frame, text="未检测到 pymatgen，高级结构功能将关闭。", foreground="#aa5500").pack(anchor=tk.W, pady=(6, 0))
        return frame

    def _update_state(self):
        self.encut_entry.configure(state=tk.NORMAL if self.encut_mode.get() == "manual" else tk.DISABLED)
        self.kspacing_entry.configure(state=tk.NORMAL if self.k_mode.get() == "kspacing" else tk.DISABLED)
        for widget in self.slurm_widgets:
            try:
                widget.configure(state=tk.NORMAL if self.use_slurm.get() else tk.DISABLED)
            except Exception:
                pass

    def _update_page(self):
        for page in self.pages:
            page.pack_forget()
        page = self.pages[self.current_index]
        page.pack(fill=tk.BOTH, expand=True)
        self.step_var.set(f"步骤 {self.current_index + 1}/5")
        self.btn_prev.configure(state=tk.NORMAL if self.current_index > 0 else tk.DISABLED)
        if self.current_index >= len(self.pages) - 1:
            self.btn_next.configure(state=tk.DISABLED)
            self.btn_finish.configure(state=tk.NORMAL)
        else:
            self.btn_next.configure(state=tk.NORMAL)
            self.btn_finish.configure(state=tk.DISABLED)
        self._update_state()

    def _validate_page(self) -> bool:
        if self.current_index == 2 and self.k_mode.get() == "kspacing":
            try:
                float(self.kspacing.get())
            except Exception:
                messagebox.showerror(APP_NAME, "KSPACING 需为数字")
                return False
        if self.current_index == 3:
            try:
                int(self.np_var.get())
            except Exception:
                messagebox.showerror(APP_NAME, "-np 需为正整数")
                return False
        return True

    def on_next(self):
        if not self._validate_page():
            return
        if self.current_index < len(self.pages) - 1:
            self.current_index += 1
            self._update_page()

    def on_prev(self):
        if self.current_index > 0:
            self.current_index -= 1
            self._update_page()

    def on_cancel(self):
        self.result = None
        self.destroy()

    def on_finish(self):
        if not self._validate_page():
            return
        try:
            np_total = int(self.np_var.get())
            if np_total <= 0:
                raise ValueError
        except Exception:
            messagebox.showerror(APP_NAME, "-np 需为正整数")
            return
        encut_val = None
        if self.encut_mode.get() == "manual":
            try:
                encut_val = int(self.encut_value.get())
            except Exception:
                messagebox.showerror(APP_NAME, "请输入合法的 ENCUT 数值")
                return
        kspacing_val = None
        kgrid_val = None
        if self.k_mode.get() == "kspacing":
            try:
                kspacing_val = float(self.kspacing.get())
            except Exception:
                messagebox.showerror(APP_NAME, "KSPACING 需为数字")
                return
        else:
            kgrid_val = tuple(int(var.get()) for var in self.kgrid)
        slurm_cfg: Dict[str, Any] = {
            "partition": self.slurm_part.get(),
            "time": self.slurm_time.get(),
            "nodes": self._safe_int(self.slurm_nodes.get(), 1),
            "ntasks": self._safe_int(self.slurm_ntasks.get(), np_total),
            "account": self.slurm_account.get(),
        }
        profile = WizardProfile(
            system_type=self.system_type.get(),
            workflow=self.workflow.get(),
            encut_strategy=self.encut_mode.get(),
            encut_value=encut_val,
            k_mode=self.k_mode.get(),
            kspacing=kspacing_val,
            kgrid=kgrid_val,
            use_slurm=bool(self.use_slurm.get()),
            np=np_total,
            slurm=slurm_cfg,
            figure_style=self.style_var.get() or "AFM",
            emit_report=bool(self.emit_report.get()),
        )
        self.result = profile
        self.destroy()

    def _safe_int(self, value: str, default: int) -> int:
        try:
            num = int(value)
            return num if num > 0 else default
        except Exception:
            return default




if __name__ == "__main__":
    app = VaspGUI()
    app.mainloop()
