#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
VASP Linux 一体化GUI（Tkinter 版 | 单文件可运行）
=================================================
目标：把 Linux 下常用 VASP 操作整合到简洁 GUI：项目管理、INCAR/POSCAR/KPOINTS 编辑、
POTCAR 拼接（本地已有赝势）、K 点生成、作业脚本生成与提交（本地 / SLURM）、
以及 OSZICAR 能量-步数监视与简单可视化。

依赖（尽量轻）：
- Python 3.8+
- tkinter（随 Python 自带）
- matplotlib（绘图）

可选依赖（提升体验，但不是必须）：
- ttkbootstrap（更美观的主题）
- pymatgen / ase（将来可扩展结构与后处理）

使用：
- python vasp_gui.py

说明：
- 本工具不包含、也不会分发任何 VASP 程序或赝势文件。请确保你拥有 VASP 许可，
  并在"POTCAR 面板"正确设置本地赝势库路径。
- 监视功能主要解析 OSZICAR（F= 或 E0= 行），用于快速查看收敛趋势。
- SLURM 模板可在 GUI 中一键生成，你可以直接提交或先手动修改。

作者：ChatGPT（GPT-5 Thinking）
许可：MIT
"""
from __future__ import annotations
import os
import sys
import re
import time
import json
import textwrap
import shutil
import math
import threading
import subprocess
import hashlib
import datetime as _dt
import pickle
import tempfile
from functools import partial
from collections import deque
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Tuple, Literal, Callable
from pathlib import Path

try:
    import tkinter as tk
    from tkinter import ttk, filedialog, messagebox
    from tkinter.scrolledtext import ScrolledText
except Exception as e:
    print("[FATAL] Tkinter 未安装或不可用：", e)
    sys.exit(1)

# matplotlib 放在 TkAgg 嵌入
import matplotlib
matplotlib.use("TkAgg")
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib.figure import Figure

try:
    import ttkbootstrap as tb
    HAS_TTKBOOTSTRAP = True
except Exception:
    tb = None
    HAS_TTKBOOTSTRAP = False

try:
    import pymatgen  # type: ignore  # noqa: F401
    HAS_PYMATGEN = True
except Exception:
    HAS_PYMATGEN = False

# === CODEX BEGIN: imports for twist/shift page ===
try:
    import numpy as np  # 数值与线性代数
    HAS_NUMPY = True
except Exception:
    HAS_NUMPY = False

try:
    from pymatgen.analysis.interfaces.zsl import ZSLGenerator  # type: ignore
    HAS_ZSL = True
except Exception:
    HAS_ZSL = False
# === CODEX END: imports for twist/shift page ===

try:
    import seekpath  # type: ignore  # noqa: F401
    HAS_SEEKPATH = True
except Exception:
    HAS_SEEKPATH = False

EV_TO_J = 1.602176634e-19
HBAR = 1.054571817e-34  # J*s
M_E = 9.10938356e-31     # kg
ANG_TO_M = 1e-10


def _ensure_report_dirs(workdir: Path, opts: Dict[str, Any]) -> tuple[Path, Path, Path]:
    """确保报告输出目录存在，返回 (report_dir, figs_dir, tables_dir)。"""
    report_dir = opts.get("report_dir")
    if not report_dir:
        ts = _dt.datetime.now().strftime("%Y%m%d-%H%M%S")
        report_dir = workdir / "reports" / f"post_{ts}"
    report_dir = Path(report_dir)
    figs_dir = report_dir / "figs"
    figs_dir.mkdir(parents=True, exist_ok=True)
    tables_dir = report_dir / "tables"
    tables_dir.mkdir(parents=True, exist_ok=True)
    return report_dir, figs_dir, tables_dir


def _read_kpoints_linemode(kpoints_path: Path) -> tuple[list[list[float]], list[str]]:
    """解析 line-mode KPOINTS（含 ! 标签），返回 (kpoints_frac, labels)。
    labels 与点一一对应，若无标签用空串。
    """
    ks: list[list[float]] = []
    labs: list[str] = []
    try:
        lines = read_text(kpoints_path).splitlines()
    except Exception:
        return ks, labs
    if len(lines) < 5:
        return ks, labs
    for ln in lines[4:]:
        s = ln.strip()
        if not s:
            continue
        parts = s.split("!")
        xyz = parts[0].split()
        if len(xyz) >= 3:
            try:
                kx, ky, kz = float(xyz[0]), float(xyz[1]), float(xyz[2])
                ks.append([kx, ky, kz])
                labs.append(parts[1].strip() if len(parts) > 1 else "")
            except Exception:
                pass
    return ks, labs


APP_NAME = "VASP GUI"

# 配置文件路径（保存用户设置）
CONFIG_DIR = Path.home() / ".config" / "vasp_gui"
CONFIG_PATH = CONFIG_DIR / "config.json"


@dataclass
class PostResult:
    metrics: Dict[str, float]
    figs: Dict[str, Path]
    tables: Dict[str, Path]
    notes: List[str]
    extra: Dict[str, Any] = field(default_factory=dict)


@dataclass
class PostProc:
    name: str
    needs: List[str]
    runner: Callable[[Path, Dict[str, Any]], PostResult]


POSTPROCS: Dict[str, PostProc] = {}


def register_postproc(proc: PostProc) -> None:
    POSTPROCS[proc.name] = proc


@dataclass
class WizardProfile:
    system_type: Literal["metal", "semiconductor", "insulator"]
    workflow: Literal["relax_scf_dos", "relax_scf_bands", "scf_dos"]
    encut_strategy: Literal["auto", "manual"]
    encut_value: Optional[int]
    k_mode: Literal["kspacing", "kpoints"]
    kspacing: Optional[float]
    kgrid: Optional[Tuple[int, int, int]]
    use_slurm: bool
    np: int
    slurm: Dict[str, Any]
    figure_style: Literal["AFM"]
    emit_report: bool


FIG_STYLES: Dict[str, Dict[str, Any]] = {
    "AFM": {
        "font": "Times New Roman",
        "size": {"title": 12, "label": 11, "tick": 10},
        "linew": 1.2,
        "tick_dir": "in",
        "tick_len": 3,
        "box": True,
    },
}

POST_FIG_DPI = 240


@dataclass
class PreflightItem:
    level: Literal["ok", "warn", "error", "info"]
    title: str
    detail: str
    fix: Optional[Callable[[], None]] = None
    fix_label: Optional[str] = None
    auto: bool = True


KEY_CORRECTIONS = {
    "ISPINN": "ISPIN",
    "ENCUTT": "ENCUT",
    "SIGMMA": "SIGMA",
    "MAGMOMM": "MAGMOM",
    "IDIPLOL": "IDIPOL",
}


TW_TEMPLATE_LIBRARY: dict[str, dict[str, Any]] = {
    "graphene_bn": {
        "label": "石墨烯 / h-BN（六角）",
        "summary": "典型蜂窝晶格，真空 18–20 Å，默认 Γ 中心网格。",
        "incar": {
            "ISMEAR": "0",
            "SIGMA": "0.05",
            "ISYM": "0",
            "LDIPOL": ".TRUE.",
            "IDIPOL": "3",
            "LCHARG": ".TRUE.",
            "LWAVE": ".FALSE.",
        },
        "kspacing": 0.22,
        "vacuum": 20.0,
        "interlayer": 3.35,
        "allow_strain": 0.8,
        "gamma_center": True,
        "notes": "蜂窝晶格默认 0–60°，展宽采用高斯 0.05 eV。",
    },
    "mos2_tmd": {
        "label": "MoS₂ / WS₂（TMD）",
        "summary": "过渡金属二硫化物常用设定，真空 18–20 Å。",
        "incar": {
            "ISMEAR": "0",
            "SIGMA": "0.05",
            "ISYM": "0",
            "EDIFF": "1e-6",
            "EDIFFG": "-0.02",
            "LDIPOL": ".TRUE.",
            "IDIPOL": "3",
            "LCHARG": ".TRUE.",
            "LWAVE": ".FALSE.",
            "IVDW": "12",
        },
        "kspacing": 0.24,
        "vacuum": 20.0,
        "interlayer": 3.2,
        "allow_strain": 0.8,
        "gamma_center": True,
        "notes": "半导体体系默认高斯展宽 0.05 eV，推荐配合 rVV10 / D3。",
    },
    "hetero_moire": {
        "label": "异质双层 / 莫尔预筛",
        "summary": "大莫尔超胞初筛，默认 Γ-only 预估，放宽 KSPACING。",
        "incar": {
            "ISMEAR": "0",
            "SIGMA": "0.05",
            "ISYM": "0",
            "LDIPOL": ".TRUE.",
            "IDIPOL": "3",
            "LREAL": "Auto",
            "NELM": "120",
            "ALGO": "Normal",
            "LCHARG": ".TRUE.",
            "LWAVE": ".FALSE.",
        },
        "kspacing": 0.35,
        "vacuum": 20.0,
        "interlayer": 3.3,
        "allow_strain": 1.0,
        "gamma_center": True,
        "force_gamma_only": True,
        "notes": "原子数巨大的莫尔超胞优先仅 Γ 点，再细化网格。",
    },
}

TW_FALLBACK_DEFAULTS = {
    "vacuum": 20.0,
    "interlayer": 3.35,
    "allow_strain": 0.8,
    "kspacing": 0.22,
    "ISMEAR": "0",
    "SIGMA": "0.05",
    "LDIPOL": ".TRUE.",
    "IDIPOL": "3",
    "ENCUT": None,
    "gamma_center": True,
    "force_gamma_only": False,
}



def _normalize_style(style: str | None) -> str:
    if style in FIG_STYLES:
        return style  # type: ignore[return-value]
    return "AFM"


def _clone_2d_table(table: list[list[float]] | None) -> list[list[float]]:
    if not table:
        return []
    return [list(row) for row in table]


def _extract_kcoords(raw_kpts: list[Any] | None) -> list[list[float]]:
    coords: list[list[float]] = []
    if not raw_kpts:
        return coords
    for item in raw_kpts:
        vec: Any = None
        if isinstance(item, (list, tuple)):
            if item and isinstance(item[0], (list, tuple)):
                vec = item[0]
            else:
                vec = item
        if vec is None:
            continue
        try:
            triple = [float(vec[i]) for i in range(3)]
        except Exception:
            continue
        coords.append(triple)
    return coords


def _coords_close(a: list[float], b: list[float], tol: float = 1e-6) -> bool:
    if len(a) != len(b):
        return False
    return all(abs(x - y) <= tol for x, y in zip(a, b))


def _align_band_lengths(
    bands: list[list[float]],
    occs: list[list[float]] | None,
    coords: list[list[float]] | None,
) -> tuple[list[list[float]], list[list[float]] | None, list[list[float]] | None]:
    if coords and len(coords) != len(bands):
        limit = min(len(coords), len(bands))
        bands = bands[:limit]
        if occs:
            occs = occs[:limit]
        coords = coords[:limit]
    if occs and len(occs) != len(bands):
        occs = occs[: len(bands)]
    return bands, occs, coords


def _trim_periodic_path(
    coords: list[list[float]] | None,
    bands: list[list[float]],
    occs: list[list[float]] | None,
) -> tuple[list[list[float]] | None, list[list[float]], list[list[float]] | None, bool]:
    trimmed = False
    if coords and bands and len(coords) == len(bands) and len(coords) > 1:
        if _coords_close(coords[0], coords[-1]):
            coords = coords[:-1]
            bands = bands[:-1]
            if occs:
                occs = occs[:-1]
            trimmed = True
    return coords, bands, occs, trimmed


def _transpose_band_table(table: list[list[float]]) -> list[list[float]]:
    if not table:
        return []
    widths = [len(row) for row in table if row]
    if not widths:
        return []
    nb = min(widths)
    if nb <= 0:
        return []
    return [[row[i] for row in table if i < len(row)] for i in range(nb)]


def _compute_kpath_positions(
    coords: list[list[float]] | None,
    recip: list[list[float]] | None = None,
) -> list[float]:
    if not coords:
        return []
    positions: list[float] = []
    accum = 0.0
    prev_vec: list[float] | None = None
    use_recip = (
        recip is not None
        and len(recip) >= 3
        and all(isinstance(row, (list, tuple)) and len(row) >= 3 for row in recip[:3])
    )
    for frac in coords:
        if len(frac) < 3:
            continue
        if use_recip:
            vec = [
                frac[0] * float(recip[0][i])
                + frac[1] * float(recip[1][i])
                + frac[2] * float(recip[2][i])
                for i in range(3)
            ]
        else:
            vec = [float(frac[i]) for i in range(3)]
        if prev_vec is not None:
            delta = math.sqrt(sum((vec[i] - prev_vec[i]) ** 2 for i in range(3)))
            if delta > 1e-9:
                accum += delta
        positions.append(accum)
        prev_vec = vec
    return positions


def _split_segments_from_positions(positions: list[float]) -> list[tuple[int, int]]:
    if len(positions) < 2:
        return []
    segments: list[tuple[int, int]] = []
    start = 0
    for idx in range(1, len(positions)):
        if abs(positions[idx] - positions[idx - 1]) < 1e-9:
            if idx - start > 1:
                segments.append((start, idx))
            start = idx
    if len(positions) - start > 1:
        segments.append((start, len(positions)))
    if not segments:
        segments.append((0, len(positions)))
    return segments

DEFAULT_POSCAR_TEMPLATE = """Si
1.0
5.430000 0.000000 0.000000
0.000000 5.430000 0.000000
0.000000 0.000000 5.430000
Si
1
Direct
0.000000 0.000000 0.000000
"""

EXAMPLE_SI_POSCAR = """Si example (diamond)
1.0
0.000000 2.715000 2.715000
2.715000 0.000000 2.715000
2.715000 2.715000 0.000000
Si
2
Direct
0.000000 0.000000 0.000000
0.250000 0.250000 0.250000
"""

EXAMPLE_SI_INCAR = """# 示例项目默认 INCAR
SYSTEM = example_Si
ENCUT = 520
PREC  = Accurate
EDIFF = 1e-6
IBRION = 2
ISIF   = 3
NSW    = 60
ISMEAR = 0
SIGMA  = 0.05
LREAL  = Auto
LWAVE  = .FALSE.
LCHARG = .TRUE.
"""

EXAMPLE_SI_KPOINTS = """Automatic mesh
0
Gamma
6 6 6
0 0 0
"""


# === DEMO DATA (improved realistic set) ======================================
# 口径：PBE-like Si (diamond)；间接带隙 ~0.62 eV (VBM@Γ, CBM@X)

def _linspace(a: float, b: float, n: int) -> list[float]:
    if n <= 1:
        return [a]
    step = (b - a) / (n - 1)
    return [a + i * step for i in range(n)]

def _lerp_vec(a: list[float], b: list[float], t: float) -> list[float]:
    return [a[i] + (b[i] - a[i]) * t for i in range(3)]

def _cumtrapz(y: list[float], x: list[float]) -> list[float]:
    # 简单梯形积分，不依赖 numpy
    out = [0.0]
    for i in range(1, len(x)):
        dx = x[i] - x[i-1]
        out.append(out[-1] + 0.5 * (y[i] + y[i-1]) * dx)
    return out

def _smoothstep(x: float, k: float = 6.0) -> float:
    # logistic-based smooth step: 0~1 过渡，用于柔化带边
    # s(x)=1/(1+exp(-k*x))
    import math
    return 1.0 / (1.0 + math.exp(-k * x))

def _build_demo_twist_results() -> list[dict[str, float]]:
    """生成二维材料演示用的扭转/滑移扫参数据。"""
    import math

    thetas = [0.0, 2.0, 4.0, 6.0, 8.0]
    ux_list = [0.00, 0.25, 0.50, 0.75]
    uy_list = [0.00, 0.33, 0.66]

    Eg0 = 1.55  # 近似 "MoS2-like" 双层带隙（演示用途）
    results: list[dict[str, float]] = []
    for th in thetas:
        for ux in ux_list:
            for uy in uy_list:
                gap = (
                    Eg0
                    - 0.10 * (th / 8.0)  # 小角扭转轻微减隙
                    + 0.12 * math.cos(math.pi * ux)
                    + 0.10 * math.cos(math.pi * uy)
                )
                gap = max(0.85, gap)

                Etot = -500.0 + 0.08 * th + 0.20 * ux + 0.18 * uy

                results.append(
                    {
                        "theta": round(float(th), 6),
                        "ux": round(float(ux), 6),
                        "uy": round(float(uy), 6),
                        "gap": round(float(gap), 6),
                        "E": round(float(Etot), 6),
                        "path": f"theta_{th:04.1f}_ux_{ux:04.2f}_uy_{uy:04.2f}",
                        "note": "2D-demo-mos2",
                    }
                )

    return results


def _build_demo_si():
    import math

    # ---------- DOS / PDOS ----------
    E_MIN, E_MAX, DE = -12.0, 8.0, 0.02
    energies = []
    e = E_MIN
    while e <= E_MAX + 1e-12:
        energies.append(round(e, 6))
        e += DE
    EF = 0.0
    Eg = 0.62  # PBE-like Si 间接带隙近似值（演示）

    # 价带以 p 为主，深能级掺点 s；导带弱 d
    dos_s, dos_p, dos_d = [], [], []
    for E in energies:
        # 抑制带隙内 DOS（光滑衰减）
        gate_v = 1.0 - _smoothstep(E - (-1e-3), k=55.0)   # E<0 强，E>0 抑制
        gate_c = _smoothstep(E - Eg, k=55.0)              # E<Eg 抑制，E>Eg 放大

        # 简单的多峰近似（不追求材料级拟合，只追求形态合理）
        valence_p = 1.8 * math.exp(-((E + 3.5) / 1.8) ** 2)                   + 1.2 * math.exp(-((E + 7.5) / 1.3) ** 2)
        valence_s = 0.9 * math.exp(-((E + 6.5) / 1.0) ** 2)

        # 导带从 Eg 起，逐渐抬升
        conduction_p = 1.0 * math.exp(-((E - (Eg + 1.2)) / 1.4) ** 2)
        conduction_d = 0.35 * math.exp(-((E - (Eg + 2.6)) / 1.2) ** 2)

        s = gate_v * (0.35 * valence_s) + gate_c * (0.25 * conduction_p)
        p = gate_v * (1.00 * valence_p) + gate_c * (0.85 * conduction_p)
        d = gate_c * conduction_d

        # 防止极小负值/NaN
        dos_s.append(max(0.0, s))
        dos_p.append(max(0.0, p))
        dos_d.append(max(0.0, d))

    pdos_curves = {"Si-s": dos_s, "Si-p": dos_p, "Si-d": dos_d}
    total_dos = [dos_s[i] + dos_p[i] + dos_d[i] for i in range(len(energies))]
    integrated = _cumtrapz(total_dos, energies)

    # --------- bands (Γ–X–W–K–Γ–L) ----------
    # fcc 常用高对称路径（分数坐标，近似即可）
    # Γ(0,0,0) → X(0,1/2,1/2) → W(1/4,1/2,3/4) → K(3/8,3/4,3/8) → Γ → L(1/2,1/2,1/2)
    nodes = [
        ("Γ", [0.0,   0.0,  0.0]),
        ("X", [0.0,   0.5,  0.5]),
        ("W", [0.25,  0.5,  0.75]),
        ("K", [0.375, 0.75, 0.375]),
        ("Γ", [0.0,   0.0,  0.0]),
        ("L", [0.5,   0.5,  0.5]),
    ]
    pts_per_seg = 9  # 每段插 9 点（含端点），全路径约 41 点，渲染顺滑
    kpoints = []
    labels = []
    # 生成分段直线插值路径；端点不重复
    for idx in range(len(nodes) - 1):
        name_a, ka = nodes[idx]
        name_b, kb = nodes[idx + 1]
        for i in range(pts_per_seg):
            t = i / (pts_per_seg - 1)
            if idx > 0 and i == 0:
                # 跳过重复端点
                continue
            kpoints.append(_lerp_vec(ka, kb, t))
            lbl = name_a if i == 0 else (name_b if i == (pts_per_seg - 1) else "")
            labels.append(lbl)

    nk = len(kpoints)
    distances = [0.0]
    for i in range(1, nk):
        # 用等步长的“虚拟距离”即可，不依赖晶格
        distances.append(distances[-1] + 1.0)

    # 构造 6 条带：3 条价带（VB1~VB3），3 条导带（CB1~CB3）
    # 形状：VB1 最高在 Γ（0 eV），到 X 降至 ~-0.45 eV；CB1 最低在 X（Eg）
    def _seg_u(i0: int, i1: int, i: int) -> float:
        # 返回 i 在段 [i0,i1] 上的线性 0..1
        if i1 == i0:
            return 0.0
        return (i - i0) / float(i1 - i0)

    # 找到各段索引范围
    idxs = []
    start_idx = 0
    for name, _ in nodes[1:]:
        # 找 label == name 的位置作为段末
        end_idx = max(j for j, lbl in enumerate(labels) if lbl == name)
        idxs.append((start_idx, end_idx))
        start_idx = end_idx

    # 能量生成：按段定义线性/轻微余弦变化，保证 CB1(X)≈Eg、VB1(Γ)=0
    def _bands_along_path():
        # 初始化二维表：nk 行 × 6 带
        B = [[0.0] * 6 for _ in range(nk)]

        # 目标锚点（单位 eV）
        E_Gamma_VBM = 0.0
        E_X_VBM     = -0.45
        E_W_VBM     = -0.35
        E_K_VBM     = -0.40
        E_L_VBM     = -0.15

        E_Gamma_CBM = 3.2
        E_X_CBM     = Eg
        E_W_CBM     = 1.4
        E_K_CBM     = 1.6
        E_L_CBM     = 2.0

        anchors_v = [E_Gamma_VBM, E_X_VBM, E_W_VBM, E_K_VBM, E_Gamma_VBM, E_L_VBM]
        anchors_c = [E_Gamma_CBM, E_X_CBM, E_W_CBM, E_K_CBM, E_Gamma_CBM, E_L_CBM]

        # 逐段插值
        for s, (i0, i1) in enumerate(idxs):
            Ev0, Ev1 = anchors_v[s], anchors_v[s+1]
            Ec0, Ec1 = anchors_c[s], anchors_c[s+1]
            for i in range(i0, i1 + 1):
                u = _seg_u(i0, i1, i)
                # 轻微余弦，避免过于生硬
                w = 0.5 - 0.5 * math.cos(math.pi * u)
                Ev = Ev0 + (Ev1 - Ev0) * w
                Ec = Ec0 + (Ec1 - Ec0) * w

                # 六条带：VB1 最高，其余下移；CB1 最低，其余上移
                B[i][0] = Ev                       # VB1
                B[i][1] = Ev - 0.80                # VB2
                B[i][2] = Ev - 1.60                # VB3
                B[i][3] = Ec                       # CB1
                B[i][4] = Ec + 0.80                # CB2
                B[i][5] = Ec + 1.60                # CB3
        return B

    band_values = _bands_along_path()
    band_occs = []
    for i in range(nk):
        row = []
        for e_val in band_values[i]:
            row.append(1.0 if e_val < EF else 0.0)
        band_occs.append(row)

    # ---------- 平面平均势（z） ----------
    # 设一维 slab，z∈[0, 24] Å，两层原子平面在 z≈6 Å 与 18 Å，势能凹谷 + 轻微表面偶极
    z = _linspace(0.0, 24.0, 180)
    pot = []
    for zi in z:
        # 两个“层内势阱” + 真空中的缓慢起伏 + 表面偶极台阶
        v = -0.18 * math.exp(-((zi - 6.0) / 0.8) ** 2)             -0.18 * math.exp(-((zi - 18.0) / 0.8) ** 2)             + 0.02 * math.sin(2.0 * math.pi * zi / 24.0)             + (0.06 if zi > 12.0 else 0.0)
        pot.append(v)
    # 归一到 V(0)=0 的相对势
    pot0 = pot[0]
    pot_rel = [v - pot0 for v in pot]

    # ---------- 2D 扭转/滑移扫参（演示） ----------
    twist_results = _build_demo_twist_results()

    # ---------- 汇总成原有全局变量 ----------
    demo = {}

    demo["DEMO_DOS_ENERGIES"]   = energies
    demo["DEMO_DOS_TOTAL"]      = total_dos
    demo["DEMO_DOS_INTEGRATED"] = integrated
    demo["DEMO_PDOS_CURVES"]    = pdos_curves
    demo["DEMO_PDOS_TOTAL"]     = [dos_s[i] + dos_p[i] + dos_d[i] for i in range(len(energies))]

    demo["DEMO_BAND_KPOINTS"]   = kpoints
    demo["DEMO_BAND_LABELS"]    = labels
    demo["DEMO_BAND_VALUES"]    = band_values          # 形状：nk × 6
    demo["DEMO_BAND_OCCS"]      = band_occs            # 形状：nk × 6
    demo["DEMO_BAND_DISTANCES"] = distances

    demo["DEMO_PLANAR_Z"]       = z
    demo["DEMO_PLANAR_VALUES"]  = pot_rel

    demo["DEMO_TWIST_RESULTS"]  = twist_results

    # demo 项目文件（KPOINTS 含路径标签；其余与原逻辑兼容）
    kpoints_linemode = """Si band path (fcc)
18
Line-mode
Reciprocal
0.0000 0.0000 0.0000 ! Γ
0.0000 0.0625 0.0625 !
0.0000 0.1250 0.1250 !
0.0000 0.1875 0.1875 !
0.0000 0.2500 0.2500 !
0.0000 0.3125 0.3125 !
0.0000 0.3750 0.3750 !
0.0000 0.4375 0.4375 !
0.0000 0.5000 0.5000 ! X
0.1250 0.5000 0.6250 ! W
0.1875 0.6250 0.5000 !
0.2812 0.6875 0.4375 !
0.3750 0.7500 0.3750 ! K
0.2812 0.5000 0.2812 !
0.1875 0.2500 0.1875 !
0.0938 0.1250 0.0938 !
0.0000 0.0000 0.0000 ! Γ
0.5000 0.5000 0.5000 ! L
"""

    demo["DEMO_PROJECT_FILES"] = {
        "INCAR": EXAMPLE_SI_INCAR + "\n# 演示模式示例输入（改良版数据）\n",
        "POSCAR": EXAMPLE_SI_POSCAR,
        "KPOINTS": kpoints_linemode,
        "README.txt": (
            "演示模式项目（改良数据）\n"
            "========================\n"
            "包含更贴近 Si(PBE-like) 的 DOS/PDOS、间接带隙能带（Γ→X 为主）、\n"
            "以及平面平均势与二维扭转/滑移扫参的示例结果。用于验证 GUI 流程与出图。\n"
            "无需真实 VASP 输出。"
        ),
        "vasprun.xml": "<!-- demo placeholder: 数据由内置样本提供 -->\n",
        "EIGENVAL": "# demo placeholder\n",
        "DOSCAR": "# demo placeholder\n",
        "OUTCAR": "# demo placeholder\nE-fermi : 5.4000\n",
        "LOCPOT": "# demo placeholder\n",
    }

    # 方便下方直接赋值
    return demo

# 生成并绑定到原有全局名
_demo = _build_demo_si()
DEMO_DOS_ENERGIES   = _demo["DEMO_DOS_ENERGIES"]
DEMO_DOS_TOTAL      = _demo["DEMO_DOS_TOTAL"]
DEMO_DOS_INTEGRATED = _demo["DEMO_DOS_INTEGRATED"]
DEMO_PDOS_CURVES    = _demo["DEMO_PDOS_CURVES"]
DEMO_PDOS_TOTAL     = _demo["DEMO_PDOS_TOTAL"]

DEMO_BAND_KPOINTS   = _demo["DEMO_BAND_KPOINTS"]
DEMO_BAND_LABELS    = _demo["DEMO_BAND_LABELS"]
DEMO_BAND_VALUES    = _demo["DEMO_BAND_VALUES"]
DEMO_BAND_OCCS      = _demo["DEMO_BAND_OCCS"]
DEMO_BAND_DISTANCES = _demo["DEMO_BAND_DISTANCES"]

DEMO_PLANAR_Z       = _demo["DEMO_PLANAR_Z"]
DEMO_PLANAR_VALUES  = _demo["DEMO_PLANAR_VALUES"]

DEMO_TWIST_RESULTS  = _demo["DEMO_TWIST_RESULTS"]
DEMO_POSTPROCS = {
    "dos":   {"energies": DEMO_DOS_ENERGIES, "dos": DEMO_DOS_TOTAL,
              "integrated": DEMO_DOS_INTEGRATED, "fermi": 0.0},
    "pdos":  {"energies": DEMO_DOS_ENERGIES, "total": DEMO_PDOS_TOTAL,
              "curves": DEMO_PDOS_CURVES, "fermi": 0.0, "gap": 0.62},
    "bands": {"bands": DEMO_BAND_VALUES, "occupancies": DEMO_BAND_OCCS,
              "kpoints": DEMO_BAND_KPOINTS, "fermi": 0.0,
              "distances": DEMO_BAND_DISTANCES},
    "bands_lbl": {"bands": DEMO_BAND_VALUES, "occupancies": DEMO_BAND_OCCS,
                  "kpoints": DEMO_BAND_KPOINTS, "labels": DEMO_BAND_LABELS,
                  "fermi": 0.0, "distances": DEMO_BAND_DISTANCES},
    "emass": {"bands": DEMO_BAND_VALUES, "occupancies": DEMO_BAND_OCCS,
              "distances": DEMO_BAND_DISTANCES, "fermi": 0.0,
              "me_star": 0.26, "mh_star": 0.49},  # 典型 Si 有效质量近似
    "pot_z": {"z": DEMO_PLANAR_Z, "values": DEMO_PLANAR_VALUES},
}
DEMO_PROJECT_FILES = _demo["DEMO_PROJECT_FILES"]
# === END DEMO DATA (improved realistic set) ==================================
# ----------------------------- 工具函数区 ----------------------------------

def which(cmd: str) -> str | None:
    """返回可执行文件绝对路径，找不到则 None。"""
    return shutil.which(cmd)

def read_text(p: Path) -> str:
    try:
        return p.read_text(encoding="utf-8")
    except Exception:
        try:
            return p.read_text(encoding="latin-1")
        except Exception:
            return ""

def atomic_write_text(path: Path, data: str, encoding: str = "utf-8") -> None:
    path = Path(path)
    path.parent.mkdir(parents=True, exist_ok=True)
    tmp_fd, tmp_path = tempfile.mkstemp(dir=str(path.parent), prefix=f".{path.name}.", suffix=".tmp")
    try:
        with os.fdopen(tmp_fd, "w", encoding=encoding) as fh:
            fh.write(data)
            fh.flush()
            os.fsync(fh.fileno())
        os.replace(tmp_path, path)
    finally:
        try:
            if os.path.exists(tmp_path):
                os.unlink(tmp_path)
        except Exception:
            pass


def write_text(p: Path, s: str) -> None:
    atomic_write_text(p, s, encoding="utf-8")

def format_bytes(num: int | float | None) -> str:
    """将字节数转为易读字符串。"""
    if num is None:
        return "-"
    try:
        n = float(num)
    except Exception:
        return str(num)
    if n < 0:
        n = 0.0
    units = ["B", "KB", "MB", "GB", "TB", "PB"]
    for unit in units:
        if n < 1024.0 or unit == units[-1]:
            if unit == "B":
                return f"{int(n)} {unit}"
            return f"{n:.1f} {unit}"
        n /= 1024.0
    return f"{n:.1f} PB"

POSCAR_ELEM_LINE_RX = re.compile(r"^\s*([A-Za-z][a-z]?(?:\s+[A-Za-z][a-z]?)*?)\s*$")
COUNTS_RX = re.compile(r"^\s*(\d+(?:\s+\d+)*)\s*$")
# 兼容:  -12.34   12.   .1234   -1.23E+02   3.4D-01
ENERGY_RX = re.compile(
    r"F=\s*([+-]?(?:\d+(?:\.\d*)?|\.\d+)(?:[EeDd][+-]?\d+)?)"
    r"|E0=\s*([+-]?(?:\d+(?:\.\d*)?|\.\d+)(?:[EeDd][+-]?\d+)?)"
)
# 备用：从 OUTCAR 也能抓（有时 OSZICAR 很慢才写）
TOTEN_RX = re.compile(
    r"free\s+energy\s+TOTEN\s*=\s*([+-]?(?:\d+(?:\.\d*)?|\.\d+)(?:[EeDd][+-]?\d+)?)",
    re.IGNORECASE
)



def parse_poscar(poscar_text: str):
    """粗略解析 POSCAR 的元素与计数。尽量兼容两种第6/7行写法。
    返回 (elements: list[str], counts: list[int])，可能为空。"""
    lines = [ln.rstrip("\n") for ln in poscar_text.splitlines() if ln.strip() != ""]
    if len(lines) < 8:
        return [], []
    # 寻找元素与计数两行：兼容存在 Selective dynamics 行
    # 常见：
    # 1: comment
    # 2: scale
    # 3-5: lattice
    # 6: elements OR counts
    # 7: counts (if 6 is elements)
    # 8: Selective dynamics? OR Direct/Cartesian
    elem_line = None
    cnt_line = None

    # 尝试 line6 作为元素，line7 作为计数
    l6 = lines[5]
    l7 = lines[6]
    if POSCAR_ELEM_LINE_RX.match(l6) and COUNTS_RX.match(l7):
        elem_line = l6
        cnt_line = l7
    else:
        # 也可能 line6 就是计数（没有元素符号行）
        if COUNTS_RX.match(l6):
            cnt_line = l6
            elem_line = None

    elements = []
    if elem_line:
        elements = elem_line.split()
    # 计数
    counts = []
    if cnt_line:
        counts = [int(x) for x in cnt_line.split()]

    return elements, counts


def unique_elements_from_poscar(poscar_text: str):
    elems, _ = parse_poscar(poscar_text)
    return elems


def find_potcar_candidates(elem: str, pot_dir: Path) -> list[Path]:
    """在 pot_dir 下递归查找包含给定元素名称的 POTCAR 文件，返回候选列表。
    常见目录层级（示例）：
      PAW_PBE/Si/POTCAR  或  potcars/PBE/Si/POTCAR  或  potpaw_PBE.54/Si/POTCAR
    策略：深度<=3 的广度优先查找，目录名包含元素精确匹配。"""
    elem = elem.strip()
    max_depth = 3
    queue = [(pot_dir, 0)]
    candidates = []
    while queue:
        d, depth = queue.pop(0)
        if depth > max_depth:
            continue
        try:
            for entry in d.iterdir():
                if entry.is_dir():
                    name = entry.name
                    if name == elem:
                        pot = entry / "POTCAR"
                        if pot.exists():
                            candidates.append(pot)
                    queue.append((entry, depth + 1))
        except PermissionError:
            pass
        except FileNotFoundError:
            pass
    seen = []
    unique: list[Path] = []
    for cand in candidates:
        key = str(cand)
        if key not in seen:
            seen.append(key)
            unique.append(cand)
    return unique


def build_potcar(pot_files: list[Path], out_path: Path) -> tuple[bool, str]:
    """将 pot_files 中的 POTCAR 依序拼接到 out_path。返回 (ok, msg)。"""
    if not pot_files:
        return False, "未提供任何 POTCAR 文件。"
    try:
        with open(out_path, "wb") as fout:
            for p in pot_files:
                pp = Path(p)
                if not pp.exists():
                    return False, f"未找到 POTCAR：{pp}"
                fout.write(pp.read_bytes())
        return True, f"POTCAR 已生成：{out_path}"
    except Exception as ex:
        return False, f"生成 POTCAR 失败：{ex}"


def gen_kpoints_monkhorst(nx: int, ny: int, nz: int, gamma_center: bool) -> str:
    lines = [
        "Auto KPOINTS",
        "0",
        "Gamma" if gamma_center else "Monkhorst-Pack",
        f"{nx} {ny} {nz}",
        "0 0 0",
    ]
    return "\n".join(lines) + "\n"


def apply_style(ax, style: str) -> None:
    """Apply a lightweight journal style preset to a Matplotlib axis."""
    cfg = FIG_STYLES.get(style, FIG_STYLES["AFM"])
    font = cfg.get("font", "Arial")
    size_cfg = cfg.get("size", {})
    for label in ax.get_xticklabels():
        label.set_fontfamily(font)
        label.set_fontsize(size_cfg.get("tick", 10))
    for label in ax.get_yticklabels():
        label.set_fontfamily(font)
        label.set_fontsize(size_cfg.get("tick", 10))
    ax.tick_params(direction=cfg.get("tick_dir", "in"), length=cfg.get("tick_len", 3))
    ax.set_title(ax.get_title(), fontfamily=font, fontsize=size_cfg.get("title", 12))
    ax.set_xlabel(ax.get_xlabel(), fontfamily=font, fontsize=size_cfg.get("label", 11))
    ax.set_ylabel(ax.get_ylabel(), fontfamily=font, fontsize=size_cfg.get("label", 11))
    for spine in ax.spines.values():
        spine.set_linewidth(cfg.get("linew", 1.2))
        spine.set_visible(True)
    if not cfg.get("box", True):
        for spine in ("top", "right"):
            ax.spines[spine].set_visible(False)


def _fingerprint_files(files: list[Path]) -> str:
    h = hashlib.sha1()
    for path in files:
        try:
            st = path.stat()
        except Exception:
            continue
        h.update(str(path).encode("utf-8", "ignore"))
        h.update(str(st.st_size).encode())
        h.update(str(int(st.st_mtime_ns)).encode())
    return h.hexdigest()


def _load_cached(workdir: Path, cache_key: str, files: list[Path], builder: Callable[[], Any]) -> Any:
    cache_dir = workdir / ".cache"
    fingerprint = _fingerprint_files(files)
    meta_path = cache_dir / f"{cache_key}.json"
    data_path = cache_dir / f"{cache_key}.pkl"
    if cache_dir.exists() and meta_path.exists() and data_path.exists():
        try:
            meta = json.loads(meta_path.read_text(encoding="utf-8"))
        except Exception:
            meta = {}
        if meta.get("fingerprint") == fingerprint:
            try:
                with data_path.open("rb") as fp:
                    return pickle.load(fp)
            except Exception:
                pass
    data = builder()
    if data is None:
        return None
    try:
        cache_dir.mkdir(parents=True, exist_ok=True)
        atomic_write_text(meta_path, json.dumps({"fingerprint": fingerprint}, ensure_ascii=False), encoding="utf-8")
        with data_path.open("wb") as fp:
            pickle.dump(data, fp)
    except Exception:
        pass
    return data


def _parse_fermi_from_outcar(workdir: Path) -> Optional[float]:
    outcar = workdir / "OUTCAR"
    if not outcar.exists():
        return None
    tail: deque[str] = deque(maxlen=2000)
    try:
        with outcar.open("r", encoding="utf-8", errors="ignore") as fh:
            for line in fh:
                tail.append(line)
    except Exception:
        return None
    rx = re.compile(r"E-?fermi\s*[:=]\s*([-+0-9.eE]+)")
    for line in reversed(tail):
        m = rx.search(line)
        if m:
            try:
                return float(m.group(1))
            except Exception:
                continue
    return None


def _parse_dos_vasprun(workdir: Path) -> Optional[dict[str, Any]]:
    vasprun = workdir / "vasprun.xml"
    if not vasprun.exists():
        return None
    try:
        from xml.etree import ElementTree as ET
    except Exception:
        return None

    energies: list[float] = []
    dos: list[float] = []
    integ: list[float] = []
    efermi: Optional[float] = None

    try:
        context = ET.iterparse(str(vasprun), events=("end",))
        for event, elem in context:
            if elem.tag == "i" and elem.attrib.get("name") == "efermi" and elem.text:
                try:
                    efermi = float(elem.text)
                except Exception:
                    pass
            if elem.tag == "set" and elem.attrib.get("comment", "").lower().startswith("spin 1"):
                energies.clear()
                dos.clear()
                integ.clear()
                for row in elem.findall("r"):
                    text = row.text or ""
                    parts = text.split()
                    if len(parts) >= 3:
                        try:
                            energies.append(float(parts[0]))
                            dos.append(float(parts[1]))
                            integ.append(float(parts[2]))
                        except Exception:
                            continue
                elem.clear()
                break
            elem.clear()
    except Exception:
        return None

    if not energies:
        return None
    return {"energies": energies, "dos": dos, "integrated": integ, "fermi": efermi}


def _parse_dos_doscar(workdir: Path) -> Optional[dict[str, Any]]:
    doscar = workdir / "DOSCAR"
    if not doscar.exists():
        return None
    try:
        with doscar.open("r", encoding="utf-8", errors="ignore") as fh:
            header = [next(fh) for _ in range(5)]
            line = next(fh)
            while line.strip() == "":
                line = next(fh)
            parts = line.split()
            if len(parts) < 3:
                return None
            ngrid = int(parts[2])
            efermi = float(parts[3]) if len(parts) > 3 else None
            energies: list[float] = []
            dos: list[float] = []
            integ: list[float] = []
            for _ in range(ngrid):
                vals = next(fh).split()
                if len(vals) < 3:
                    continue
                try:
                    e = float(vals[0])
                    up = float(vals[1])
                    dn = float(vals[2])
                    energies.append(e)
                    if len(vals) >= 5:
                        # spin polarized: up, down, integrated up, integrated down
                        dos.append(up + dn)
                        integ.append(float(vals[3]) + float(vals[4]))
                    else:
                        dos.append(up)
                        integ.append(dn)
                except Exception:
                    continue
    except Exception:
        return None
    return {"energies": energies, "dos": dos, "integrated": integ, "fermi": efermi}


def _estimate_gap_from_dos(energies: list[float], dos: list[float], threshold: float) -> tuple[float, str]:
    if not energies or not dos or len(energies) != len(dos):
        return 0.0, "unknown"
    pairs = sorted(zip(energies, dos), key=lambda x: x[0])
    lower = [p for p in pairs if p[0] <= 0]
    upper = [p for p in pairs if p[0] >= 0]
    if not lower or not upper:
        return 0.0, "unknown"
    # find valence edge: energy closest to zero from below where DOS < threshold
    val_states = [e for e, d in lower if abs(d) <= threshold]
    cond_states = [e for e, d in upper if abs(d) <= threshold]
    if not val_states or not cond_states:
        return 0.0, "metal"
    ev = max(val_states)
    ec = min(cond_states)
    gap = max(ec - ev, 0.0)
    if gap <= 1e-4:
        return 0.0, "metal"
    return gap, "insulator"


def proc_dos(workdir: Path, opts: Dict[str, Any]) -> PostResult:
    style = _normalize_style(opts.get("style"))
    threshold = float(opts.get("metal_threshold", 0.02))
    demo_payload = opts.get("demo_payload")
    if demo_payload:
        data = demo_payload
    else:
        cache_key = "dos_total"
        files = [workdir / "vasprun.xml", workdir / "DOSCAR", workdir / "OUTCAR"]

        def _builder():
            data = _parse_dos_vasprun(workdir)
            if data is None:
                data = _parse_dos_doscar(workdir)
            if data is None:
                raise FileNotFoundError("缺少 DOS 数据文件 (vasprun.xml/DOSCAR)")
            return data

        data = _load_cached(workdir, cache_key, files, _builder)
        if data is None:
            raise RuntimeError("无法解析 DOS 数据。")

    energies = data.get("energies", [])
    dos = data.get("dos", [])
    efermi = data.get("fermi")
    if efermi is None:
        outcar_fermi = _parse_fermi_from_outcar(workdir)
        if outcar_fermi is not None:
            efermi = outcar_fermi
        elif energies:
            efermi = (max(energies) + min(energies)) / 2
        else:
            efermi = 0.0
    rel_energies = [e - efermi for e in energies]
    dos_at_ef = 0.0
    if rel_energies and dos:
        # interpolate around zero
        closest_idx = min(range(len(rel_energies)), key=lambda i: abs(rel_energies[i]))
        dos_at_ef = float(dos[closest_idx])
    gap, band_type = _estimate_gap_from_dos(rel_energies, dos, threshold)
    is_metal = 1.0 if dos_at_ef > threshold else 0.0

    report_dir, figs_dir, tables_dir = _ensure_report_dirs(workdir, opts)

    fig = Figure(figsize=(5.0, 3.2))
    ax = fig.add_subplot(111)
    ax.plot(rel_energies, dos, color="#1f77b4", lw=1.4)
    ax.axvline(0.0, color="#d62728", ls="--", lw=1.0)
    ax.set_xlabel("E - E$_F$ (eV)")
    ax.set_ylabel("DOS (states/eV)")
    apply_style(ax, style)
    fig.tight_layout()
    fig_path = figs_dir / "dos.png"
    fig.savefig(fig_path, dpi=POST_FIG_DPI)

    csv_path = tables_dir / "dos.csv"
    with csv_path.open("w", encoding="utf-8") as fh:
        fh.write("E-Ef (eV),DOS\n")
        for e, d in zip(rel_energies, dos):
            fh.write(f"{e:.6f},{d:.6f}\n")

    notes = []
    if band_type == "metal":
        notes.append("DOS 显示体系为金属态（带隙≈0）。")
    elif gap > 0:
        notes.append(f"估算带隙 ~ {gap:.3f} eV。")

    metrics = {
        "E_F": float(efermi),
        "DOS(E_F)": float(dos_at_ef),
        "is_metal": float(is_metal),
        "gap": float(gap),
    }

    return PostResult(
        metrics=metrics,
        figs={"dos": fig_path},
        tables={"dos": csv_path},
        notes=notes,
        extra={"plot": {"x": rel_energies, "y": dos, "style": style}},
    )


def _parse_eigenval(workdir: Path) -> Optional[dict[str, Any]]:
    eigenval = workdir / "EIGENVAL"
    if not eigenval.exists():
        return None
    try:
        with eigenval.open("r", encoding="utf-8", errors="ignore") as fh:
            header = [next(fh) for _ in range(5)]
            counts = next(fh)
            while counts.strip() == "":
                counts = next(fh)
            nel, nk, nb = map(int, counts.split()[:3])
            kpts: list[tuple[list[float], float]] = []
            bands: list[list[float]] = []
            occs: list[list[float]] = []
            for ik in range(nk):
                line = next(fh)
                while line.strip() == "":
                    line = next(fh)
                parts = list(map(float, line.split()))
                kcoord = parts[:3]
                weight = parts[3] if len(parts) > 3 else 1.0 / nk
                energies: list[float] = []
                occ: list[float] = []
                for ib in range(nb):
                    vals = next(fh).split()
                    if len(vals) < 3:
                        continue
                    energies.append(float(vals[1]))
                    occ.append(float(vals[2]))
                kpts.append((kcoord, weight))
                bands.append(energies)
                occs.append(occ)
    except Exception:
        return None
    return {"kpoints": kpts, "bands": bands, "occupancies": occs}


def _estimate_gap_from_bands(bands: list[list[float]], occs: list[list[float]], fermi: float) -> tuple[float, str, float, float]:
    if not bands:
        return 0.0, "unknown", fermi, fermi
    vbm = -1e9
    cbm = 1e9
    direct_gap = 1e9
    vb_k = cb_k = None
    for kidx, (energies, occ) in enumerate(zip(bands, occs)):
        v_local = max((e for e, o in zip(energies, occ) if o > 0.5), default=-1e9)
        c_local = min((e for e, o in zip(energies, occ) if o < 0.5), default=1e9)
        if v_local > vbm:
            vbm = v_local
            vb_k = kidx
        if c_local < cbm:
            cbm = c_local
            cb_k = kidx
        gap_k = max(c_local - v_local, 0.0)
        if gap_k < direct_gap:
            direct_gap = gap_k
    gap = max(cbm - vbm, 0.0)
    if gap <= 1e-4:
        return 0.0, "metal", vbm, cbm
    nature = "direct" if vb_k == cb_k and direct_gap <= gap + 1e-3 else "indirect"
    return gap, nature, vbm, cbm


def proc_bands(workdir: Path, opts: Dict[str, Any]) -> PostResult:
    style = _normalize_style(opts.get("style"))
    threshold = float(opts.get("metal_threshold", 0.02))
    demo_payload = opts.get("demo_payload") if isinstance(opts.get("demo_payload"), dict) else None
    data: dict[str, Any] | None = None
    fermi_hint: float | None = None
    distance_hint: list[float] = []
    if isinstance(demo_payload, dict):
        data = demo_payload
        try:
            fermi_hint = float(demo_payload.get("fermi"))
        except Exception:
            fermi_hint = None
        dist_val = demo_payload.get("distances")
        if isinstance(dist_val, (list, tuple)):
            try:
                distance_hint = [float(x) for x in dist_val]
            except Exception:
                distance_hint = []
    if data is None:
        cache_key = "bands"
        files = [workdir / "vasprun.xml", workdir / "EIGENVAL", workdir / "OUTCAR"]

        def _builder():
            data = _parse_dos_vasprun(workdir)
            if data and data.get("energies"):
                # vasprun already parsed for dos; but band requires dedicated parse
                pass
            bands_data = _parse_eigenval(workdir)
            if bands_data is None:
                raise FileNotFoundError("缺少能带数据 (vasprun.xml/EIGENVAL)")
            return bands_data

        data = _load_cached(workdir, cache_key, files, _builder)
        if data is None:
            raise RuntimeError("无法解析能带数据。")

    raw_bands = _clone_2d_table(data.get("bands"))
    if not raw_bands:
        raise RuntimeError("未能在 vasprun.xml/EIGENVAL 中解析到能带数据，请确认已完成能带计算。")
    occs = _clone_2d_table(data.get("occupancies"))
    coords = _extract_kcoords(data.get("kpoints"))

    if not coords and isinstance(demo_payload, dict):
        coords = _extract_kcoords(demo_payload.get("kpoints"))
    if not coords:
        kp_file, _ = _read_kpoints_linemode(workdir / "KPOINTS")
        coords = _extract_kcoords(kp_file)
    bands, occs, coords = _align_band_lengths(raw_bands, occs, coords)
    coords, bands, occs, trimmed = _trim_periodic_path(coords, bands, occs)


    fermi = fermi_hint
    if fermi is None:
        fermi = _parse_fermi_from_outcar(workdir)
    if fermi is None and bands:
        flat = [e for energies in bands for e in energies]
        fermi = sum(flat) / len(flat)

    gap, nature, vbm, cbm = _estimate_gap_from_bands(bands, occs or [], fermi)

    rel_bands = [[e - fermi for e in row] for row in bands]

    positions = distance_hint or _compute_kpath_positions(coords)
    if not positions:
        positions = list(range(len(rel_bands)))
    if len(positions) != len(rel_bands):
        common = min(len(positions), len(rel_bands))
        positions = positions[:common]
        rel_bands = rel_bands[:common]
        bands = bands[:common]
        if occs:
            occs = occs[:common]
    segments = _split_segments_from_positions(positions)
    band_series = _transpose_band_table(rel_bands)
    if not band_series:
        raise RuntimeError("能带数据为空，请确认已完成能带计算。")

    report_dir, figs_dir, tables_dir = _ensure_report_dirs(workdir, opts)

    fig = Figure(figsize=(5.0, 3.5))
    ax = fig.add_subplot(111)
    plotted = False
    for series in band_series:
        for start, end in segments:
            xs = positions[start:end]
            ys = series[start:end]
            if len(xs) >= 2:
                ax.plot(xs, ys, color="#1f77b4", lw=1.0)
                plotted = True
    if not plotted and positions and band_series:
        ax.plot(positions, band_series[0], color="#1f77b4", lw=1.0)
    if positions and min(positions) != max(positions):
        ax.set_xlim(min(positions), max(positions))
    ax.axhline(0.0, color="#d62728", ls="--", lw=1.0)
    ax.set_ylabel("E - E$_F$ (eV)")
    ax.set_xlabel("k-path distance (arb.)")
    apply_style(ax, style)
    fig.tight_layout()
    fig_path = figs_dir / "bands.png"
    fig.savefig(fig_path, dpi=POST_FIG_DPI)

    csv_path = tables_dir / "bands.csv"
    with csv_path.open("w", encoding="utf-8") as fh:
        fh.write("k_index,band_index,E-Ef (eV),occupation\n")
        for kidx, row in enumerate(rel_bands):
            occ_row = occs[kidx] if occs and kidx < len(occs) else []
            for bidx, val in enumerate(row, start=1):
                occ = occ_row[bidx - 1] if bidx - 1 < len(occ_row) else 0.0
                fh.write(f"{kidx},{bidx},{val:.6f},{occ:.3f}\n")

    use_index_axis = not coords or all(abs(positions[i] - float(i)) < 1e-9 for i in range(len(positions)))

    notes = []
    if gap <= 1e-4:
        notes.append("能带结构显示体系为金属态。")
    else:
        notes.append(f"估算带隙约 {gap:.3f} eV（{nature}）。")
    if trimmed:
        notes.append("检测到重复路径端点，已仅保留一个周期的数据。")
    if use_index_axis and positions:
        notes.append("缺少 KPOINTS 路径信息，x 轴按路径索引绘制。")

    metrics = {
        "gap": float(gap),
        "vbm": float(vbm - fermi if vbm != -1e9 else 0.0),
        "cbm": float(cbm - fermi if cbm != 1e9 else 0.0),
        "is_metal": 1.0 if gap <= threshold else 0.0,
        "fermi": float(fermi),
    }

    return PostResult(
        metrics=metrics,
        figs={"bands": fig_path},
        tables={"bands": csv_path},
        notes=notes,
        extra={"plot": {"bands": rel_bands, "style": style}},
    )


register_postproc(PostProc(name="dos", needs=["vasprun.xml|DOSCAR"], runner=proc_dos))
register_postproc(PostProc(name="bands", needs=["vasprun.xml|EIGENVAL"], runner=proc_bands))


def proc_pdos(workdir: Path, opts: Dict[str, Any]) -> PostResult:
    """投影态密度图与数据导出。"""
    style = _normalize_style(opts.get("style"))
    group = (opts.get("group") or "element").lower()
    want_elems = opts.get("elements") or None
    want_orbs = [o.lower() for o in (opts.get("orbitals") or [])]
    ewin = opts.get("energy_window") or (-6.0, 6.0)

    report_dir, figs_dir, tables_dir = _ensure_report_dirs(workdir, opts)

    demo_payload = opts.get("demo_payload") if isinstance(opts.get("demo_payload"), dict) else None

    if demo_payload:
        energies = [float(e) for e in demo_payload.get("energies", [])]
        total = [float(v) for v in demo_payload.get("total", [])]
        raw_curves = demo_payload.get("curves") or {}
        curves = {str(k): [float(x) for x in v] for k, v in raw_curves.items()}
        try:
            efermi = float(demo_payload.get("fermi", 0.0))
        except Exception:
            efermi = 0.0
        gap_val = float(demo_payload.get("gap", 0.0))
        notes = ["演示模式示例 PDOS：数据来源于内置样本。"]
    else:
        if not HAS_PYMATGEN:
            raise RuntimeError("需要 pymatgen 才能生成 PDOS，请安装 pymatgen。")

        from pymatgen.io.vasp.outputs import Vasprun  # type: ignore

        vxml = workdir / "vasprun.xml"
        if not vxml.exists():
            raise FileNotFoundError("未找到 vasprun.xml，无法生成投影态密度。")

        vasprun = Vasprun(str(vxml), parse_dos=True, parse_projected_dos=True)
        cdos = vasprun.complete_dos
        efermi = float(cdos.efermi)
        energies = [float(e) - efermi for e in cdos.energies]

        curves: dict[str, list[float]] = {}
        total = [float(x) for x in cdos.densities["total"]]

        if group == "element":
            wanted = {str(el) for el in want_elems} if want_elems else None
            for el, edos in cdos.get_element_dos().items():
                name = str(el)
                if wanted and name not in wanted:
                    continue
                curves[name] = [float(x) for x in edos.densities["total"]]
        elif group == "orbital":
            for spd, odos in cdos.get_spd_dos().items():
                key = str(spd).lower()
                if want_orbs and key not in want_orbs:
                    continue
                curves[key] = [float(x) for x in odos.densities["total"]]
        elif group == "site":
            structure = cdos.structure
            for idx, site in enumerate(structure.sites[:8]):
                sd = cdos.get_site_dos(site)
                curves[f"site{idx+1}-{site.specie}"] = [float(x) for x in sd.densities["total"]]
        else:
            raise ValueError("PDOS 分组仅支持 element/orbital/site。")

        try:
            gap_info = vasprun.get_band_structure().get_band_gap()
            gap_val = float(gap_info.get("energy", 0.0)) if gap_info else 0.0
        except Exception:
            gap_val = 0.0

        if not curves:
            raise RuntimeError("未在 vasprun.xml 中找到投影 DOS，请确认 INCAR 设置 LORBIT=11/12 并保留投影数据。")

        notes = [
            "PDOS 由 vasprun.xml 投影得到；如需更细分的投影，请在 INCAR 设置 LORBIT=11/12 并确保写出投影数据。",
        ]

    if not curves:
        raise RuntimeError("未在 vasprun.xml 中找到投影 DOS，请确认 INCAR 设置 LORBIT=11/12 并保留投影数据。")

    fig = Figure(figsize=(5.4, 3.3))
    ax = fig.add_subplot(111)
    ax.plot(energies, total, lw=1.6, label="total")
    for name, values in curves.items():
        ax.plot(energies, values, lw=1.0, label=name)
    ax.axvline(0.0, ls="--", lw=1.0)
    ax.set_xlim(ewin[0], ewin[1])
    ax.set_xlabel("E - E$_F$ (eV)")
    ax.set_ylabel("DOS (states/eV)")
    ax.legend(ncol=2, fontsize=8, frameon=False)
    apply_style(ax, style)
    fig.tight_layout()
    fig_path = figs_dir / f"pdos_{group}.png"
    fig.savefig(fig_path, dpi=POST_FIG_DPI)

    csv_path = tables_dir / f"pdos_{group}.csv"
    with csv_path.open("w", encoding="utf-8") as fh:
        headers = ["E-Ef (eV)", "total"] + list(curves.keys())
        fh.write(",".join(headers) + "\n")
        for idx, energy in enumerate(energies):
            row = [f"{energy:.6f}", f"{total[idx]:.6f}"]
            for name in curves.keys():
                values = curves[name]
                val = values[idx] if idx < len(values) else 0.0
                row.append(f"{val:.6f}")
            fh.write(",".join(row) + "\n")

    metrics = {"E_F": float(efermi), "gap": float(gap_val)}
    return PostResult(metrics=metrics, figs={"pdos": fig_path}, tables={"pdos": csv_path}, notes=notes)


register_postproc(PostProc(name="pdos", needs=["vasprun.xml"], runner=proc_pdos))


def _fallback_reciprocal_from_poscar(poscar: Path) -> Optional[list[list[float]]]:
    try:
        lines = read_text(poscar).splitlines()
    except Exception:
        return None
    if len(lines) < 5:
        return None
    try:
        scale = float(lines[1].strip())
        a1 = [float(x) for x in lines[2].split()[:3]]
        a2 = [float(x) for x in lines[3].split()[:3]]
        a3 = [float(x) for x in lines[4].split()[:3]]
    except Exception:
        return None
    lat = [[scale * a1[i], scale * a2[i], scale * a3[i]] for i in range(3)]
    try:
        import numpy as _np

        mat = _np.array(lat, dtype=float)
        recip = 2 * _np.pi * _np.linalg.inv(mat).T
        return recip.tolist()
    except Exception:
        return None


def proc_bands_labeled(workdir: Path, opts: Dict[str, Any]) -> PostResult:
    style = _normalize_style(opts.get("style"))
    report_dir, figs_dir, tables_dir = _ensure_report_dirs(workdir, opts)

    demo_payload = opts.get("demo_payload") if isinstance(opts.get("demo_payload"), dict) else None
    if demo_payload:
        kpts = _extract_kcoords(demo_payload.get("kpoints"))
        raw_labels = demo_payload.get("labels")
        labels = [str(lbl) for lbl in raw_labels] if isinstance(raw_labels, (list, tuple)) else []
    else:
        kpts, labels = _read_kpoints_linemode(workdir / "KPOINTS")

    if demo_payload is None and HAS_PYMATGEN and (workdir / "vasprun.xml").exists():
        from pymatgen.io.vasp.outputs import BSVasprun  # type: ignore

        bsrun = BSVasprun(str(workdir / "vasprun.xml"), parse_projected_eigen=False)
        bands = bsrun.get_band_structure(line_mode=True)
        efermi = float(bands.efermi)
        distances = [float(d) for d in bands.distance]
        rel_bands = [[float(e - efermi) for e in row] for row in bands.bands[bands.spin_keys[0]]]
        ticks = bands.get_ticks()
        tick_pos = [float(p) for p in ticks["distance"]]
        tick_lab = [str(lbl) for lbl in ticks["label"]]
        gap_info = bands.get_band_gap()
        vbm = bands.get_vbm()
        cbm = bands.get_cbm()
        gap_val = float(gap_info.get("energy", 0.0)) if gap_info else 0.0
        nature = "direct" if gap_info and gap_info.get("direct") else "indirect"
        vbm_rel = float(vbm["energy"] - efermi) if vbm else 0.0
        cbm_rel = float(cbm["energy"] - efermi) if cbm else 0.0

        fig = Figure(figsize=(5.6, 3.6))
        ax = fig.add_subplot(111)
        segments = _split_segments_from_positions(distances)
        for series in rel_bands:
            for start, end in segments:
                xs = distances[start:end]
                ys = series[start:end]
                if len(xs) >= 2:
                    ax.plot(xs, ys, lw=1.0)
        for pos in tick_pos:
            ax.axvline(pos, lw=0.6, ls=":", alpha=0.6)
        ax.axhline(0.0, lw=1.0, ls="--")
        ax.set_xticks(tick_pos)
        ax.set_xticklabels(tick_lab)
        ax.set_ylabel("E - E$_F$ (eV)")
        apply_style(ax, style)
        fig.tight_layout()
        fig_path = figs_dir / "bands_labeled.png"
        fig.savefig(fig_path, dpi=POST_FIG_DPI)

        csv_path = tables_dir / "bands_labeled.csv"
        with csv_path.open("w", encoding="utf-8") as fh:
            fh.write("distance,band_index,E-Ef (eV)\n")
            for bidx, row in enumerate(rel_bands, start=1):
                for dist, energy in zip(distances, row):
                    fh.write(f"{dist:.6f},{bidx},{energy:.6f}\n")

        metrics = {
            "gap": float(gap_val),
            "nature": nature,
            "vbm": vbm_rel,
            "cbm": cbm_rel,
        }
        notes = ["x 轴依据高对称路径距离，刻度为自动识别的高对称点。"]
        return PostResult(metrics=metrics, figs={"bands_labeled": fig_path}, tables={"bands_labeled": csv_path}, notes=notes)


    distance_hint: list[float] = []
    if isinstance(demo_payload, dict):
        dist_val = demo_payload.get("distances")
        if isinstance(dist_val, (list, tuple)):
            try:
                distance_hint = [float(x) for x in dist_val]
            except Exception:
                distance_hint = []

    if demo_payload:
        data = demo_payload
    else:
        data = _parse_eigenval(workdir)
        if data is None:
            raise FileNotFoundError("缺少能带数据 (vasprun.xml 或 EIGENVAL)，请先完成能带计算。")

    raw_bands = _clone_2d_table(data.get("bands"))
    if not raw_bands:
        raise RuntimeError("EIGENVAL 中未解析到能带数据，请确认计算输出完整。")
    occs = _clone_2d_table(data.get("occupancies"))
    coords = kpts or _extract_kcoords(data.get("kpoints"))
    bands, occs, coords = _align_band_lengths(raw_bands, occs, coords)
    coords, bands, occs, trimmed = _trim_periodic_path(coords, bands, occs)
    if labels:
        labels = labels[: len(coords) if coords else len(bands)]

    fermi = None
    if isinstance(demo_payload, dict):
        try:
            fermi = float(demo_payload.get("fermi"))
        except Exception:
            fermi = None
    if fermi is None:
        fermi = _parse_fermi_from_outcar(workdir)
    if fermi is None:
        flat = [e for row in bands for e in row]
        fermi = sum(flat) / len(flat) if flat else 0.0

    recip = None
    if HAS_PYMATGEN and (workdir / "POSCAR").exists():
        try:
            from pymatgen.core import Structure  # type: ignore

            structure = Structure.from_file(str(workdir / "POSCAR"))
            recip = structure.lattice.reciprocal_lattice_crystallographic.matrix
        except Exception:
            recip = None
    if recip is None:
        recip = _fallback_reciprocal_from_poscar(workdir / "POSCAR")


    distances = distance_hint or _compute_kpath_positions(coords, recip)
    if not distances:
        distances = list(range(len(bands)))
    if len(distances) != len(bands):
        limit = min(len(distances), len(bands))
        distances = distances[:limit]
        bands = bands[:limit]
        if occs:
            occs = occs[:limit]
        if labels:
            labels = labels[:limit]

    rel_bands = [[e - fermi for e in row] for row in bands]
    gap_val, nature, vabs, cabs = _estimate_gap_from_bands(bands, occs or [], fermi)
    vbm_rel = float(vabs - fermi)
    cbm_rel = float(cabs - fermi)

    band_series = _transpose_band_table(rel_bands)
    if not band_series:
        raise RuntimeError("能带数据不足，无法生成路径图。")

    segments = _split_segments_from_positions(distances)

    fig = Figure(figsize=(5.6, 3.6))
    ax = fig.add_subplot(111)
    plotted = False
    for series in band_series:
        for start, end in segments:
            xs = distances[start:end]
            ys = series[start:end]
            if len(xs) >= 2:
                ax.plot(xs, ys, lw=1.0)
                plotted = True
    if not plotted and distances and band_series:
        ax.plot(distances, band_series[0], color="#1f77b4", lw=1.0)
    if distances and min(distances) != max(distances):
        ax.set_xlim(min(distances), max(distances))
    if labels:
        tick_pos: list[float] = []
        tick_lab: list[str] = []
        for dist, lab in zip(distances, labels):
            if lab:
                tick_pos.append(dist)
                tick_lab.append(lab)
                ax.axvline(dist, lw=0.6, ls=":", alpha=0.6)
        if tick_pos:
            ax.set_xticks(tick_pos)
            ax.set_xticklabels(tick_lab)
    ax.axhline(0.0, lw=1.0, ls="--")
    ax.set_ylabel("E - E$_F$ (eV)")
    apply_style(ax, style)
    fig.tight_layout()
    fig_path = figs_dir / "bands_labeled.png"
    fig.savefig(fig_path, dpi=POST_FIG_DPI)

    csv_path = tables_dir / "bands_labeled.csv"
    with csv_path.open("w", encoding="utf-8") as fh:
        fh.write("distance,band_index,E-Ef (eV)\n")
        for bidx, series in enumerate(band_series, start=1):
            for dist, energy in zip(distances, series):
                fh.write(f"{dist:.6f},{bidx},{energy:.6f}\n")

    metrics = {
        "gap": float(max(cbm_rel - vbm_rel, 0.0)),
        "nature": nature,
        "vbm": vbm_rel,
        "cbm": cbm_rel,
    }
    notes = [
        "EIGENVAL 回退模式：若需精确路径建议使用非自洽能带计算并生成 vasprun.xml。",
    ]
    if trimmed:
        notes.append("检测到重复路径端点，已仅保留一个周期的数据。")
    if not distances or distances == list(range(len(distances))):
        notes.append("缺少晶格信息，x 轴按路径索引绘制。")
    return PostResult(metrics=metrics, figs={"bands_labeled": fig_path}, tables={"bands_labeled": csv_path}, notes=notes)


register_postproc(PostProc(name="bands_lbl", needs=["vasprun.xml|EIGENVAL"], runner=proc_bands_labeled))


def proc_effective_mass(workdir: Path, opts: Dict[str, Any]) -> PostResult:
    style = _normalize_style(opts.get("style"))
    window = max(int(opts.get("window_k", 4)), 2)
    report_dir, figs_dir, tables_dir = _ensure_report_dirs(workdir, opts)
    demo_payload = opts.get("demo_payload") if isinstance(opts.get("demo_payload"), dict) else None

    if demo_payload:
        bands_raw = demo_payload.get("bands") or []
        occs_raw = demo_payload.get("occupancies") or []
        try:
            fermi = float(demo_payload.get("fermi", 0.0))
        except Exception:
            fermi = 0.0

        rel = []
        for row in bands_raw:
            try:
                rel.append([float(e) - fermi for e in row])
            except Exception:
                continue

        occs = []
        for row in occs_raw:
            try:
                occs.append([float(o) for o in row])
            except Exception:
                occs.append([])

        distances: list[float] = []
        raw_dist = demo_payload.get("distances") or []
        if isinstance(raw_dist, (list, tuple)):
            try:
                distances = [float(x) for x in raw_dist]
            except Exception:
                distances = []

        if not rel or not rel[0]:
            raise RuntimeError("演示数据缺少能带或路径信息，无法估算有效质量。")

        nk = len(rel)
        nb = len(rel[0])

        if distances and len(distances) != nk:
            if nb == len(distances):
                rel = _transpose_band_table(rel)
                occs = _transpose_band_table(occs) if occs else occs
                nk = len(rel)
                nb = len(rel[0]) if rel and rel[0] else 0
            distances = [float(x) for x in distances[:nk]]
        if not distances or len(distances) != nk:
            distances = [float(i) for i in range(nk)]

        v_idx = (0, 0)
        c_idx = (0, 0)
        vbm_E = -1e9
        cbm_E = 1e9
        for k in range(nk):
            occ_row = occs[k] if k < len(occs) else []
            for b in range(nb):
                energy = rel[k][b]
                occupied = occ_row[b] if b < len(occ_row) else (1.0 if energy < 0 else 0.0)
                if occupied > 0.5 and energy > vbm_E:
                    vbm_E = energy
                    v_idx = (b, k)
                if occupied < 0.5 and energy < cbm_E:
                    cbm_E = energy
                    c_idx = (b, k)

        rel_by_band = _transpose_band_table(rel)
        if not rel_by_band:
            raise RuntimeError("演示数据缺少能带或路径信息，无法估算有效质量。")

        def _safe_float(val: Any, default: float = 0.0) -> float:
            try:
                return float(val)
            except Exception:
                return default

        me_star = _safe_float(demo_payload.get("me_star"), 0.0)
        mh_star = _safe_float(demo_payload.get("mh_star"), 0.0)

        fig = Figure(figsize=(5.2, 3.4))
        ax = fig.add_subplot(111)
        for series in rel_by_band:
            if not series:
                continue
            length = min(len(series), len(distances))
            if length <= 1:
                continue
            ax.plot(distances[:length], series[:length], lw=0.7, alpha=0.6)
        if distances and v_idx[0] < len(rel_by_band) and v_idx[1] < len(distances) and v_idx[1] < len(rel_by_band[v_idx[0]]):
            ax.scatter([distances[v_idx[1]]], [rel_by_band[v_idx[0]][v_idx[1]]], s=28, label=f"VBM m*_h≈{mh_star:.2f} m_e")
        if distances and c_idx[0] < len(rel_by_band) and c_idx[1] < len(distances) and c_idx[1] < len(rel_by_band[c_idx[0]]):
            ax.scatter([distances[c_idx[1]]], [rel_by_band[c_idx[0]][c_idx[1]]], s=28, label=f"CBM m*_e≈{me_star:.2f} m_e")
        ax.axhline(0.0, lw=1.0, ls="--")
        ax.set_ylabel("E - E$_F$ (eV)")
        apply_style(ax, style)
        ax.legend(fontsize=9, frameon=False)
        fig.tight_layout()
        fig_path = figs_dir / "effective_mass.png"
        fig.savefig(fig_path, dpi=POST_FIG_DPI)

        csv_path = tables_dir / "effective_mass.csv"
        with csv_path.open("w", encoding="utf-8") as fh:
            fh.write("edge,band_index,k_index,m*/m_e\n")
            fh.write(f"VBM,{v_idx[0]},{v_idx[1]},{mh_star:.6f}\n")
            fh.write(f"CBM,{c_idx[0]},{c_idx[1]},{me_star:.6f}\n")

        notes = ["演示模式示例有效质量，数值基于内置数据。"]
        metrics = {"mh*": float(mh_star), "me*": float(me_star)}
        return PostResult(metrics=metrics, figs={"effective_mass": fig_path}, tables={"effective_mass": csv_path}, notes=notes)

    if not HAS_NUMPY:
        raise RuntimeError("需要 numpy 才能估算有效质量，请安装 numpy。")

    import numpy as _np

    if HAS_PYMATGEN and (workdir / "vasprun.xml").exists():
        from pymatgen.io.vasp.outputs import BSVasprun  # type: ignore

        bsrun = BSVasprun(str(workdir / "vasprun.xml"), parse_projected_eigen=False)
        bs = bsrun.get_band_structure(line_mode=True)
        efermi = float(bs.efermi)
        distances = [float(d) for d in bs.distance]
        bands = [[float(e) for e in row] for row in bs.bands[bs.spin_keys[0]]]
        occs = [[1.0 if e < efermi else 0.0 for e in row] for row in bs.bands[bs.spin_keys[0]]]
    else:
        data = _parse_eigenval(workdir)
        if data is None or not data.get("bands"):
            raise FileNotFoundError("缺少能带数据 (vasprun.xml 或 EIGENVAL)，请先完成能带计算。")
        bands = data.get("bands", [])
        occs = data.get("occupancies", [])
        efermi = _parse_fermi_from_outcar(workdir) or 0.0
        kpts, _ = _read_kpoints_linemode(workdir / "KPOINTS")
        recip = None
        if HAS_PYMATGEN and (workdir / "POSCAR").exists():
            try:
                from pymatgen.core import Structure  # type: ignore

                structure = Structure.from_file(str(workdir / "POSCAR"))
                recip = structure.lattice.reciprocal_lattice_crystallographic.matrix
            except Exception:
                recip = None
        if recip is None:
            recip = _fallback_reciprocal_from_poscar(workdir / "POSCAR")
        if recip is not None and kpts:
            distances = []
            accum = 0.0
            prev = None
            for frac in kpts:
                vec = _np.dot(frac, _np.array(recip))
                if prev is None:
                    prev = vec
                dist = float(_np.linalg.norm(vec - prev))
                accum += dist
                distances.append(accum)
                prev = vec
        else:
            distances = list(range(len(bands[0]))) if bands else []

    bands_clean = []
    for row in bands:
        try:
            bands_clean.append([float(e) for e in row])
        except Exception:
            continue
    occs_clean = []
    for row in occs:
        try:
            occs_clean.append([float(o) for o in row])
        except Exception:
            occs_clean.append([])

    if not bands_clean or not bands_clean[0]:
        raise RuntimeError("有效质量拟合失败：能带数据为空，请确认能带计算输出完整。")

    if distances and len(distances) == len(bands_clean[0]) and len(distances) != len(bands_clean):
        bands_k = _transpose_band_table(bands_clean)
        occs_k = _transpose_band_table(occs_clean) if occs_clean else occs_clean
    else:
        bands_k = bands_clean
        occs_k = occs_clean

    nk = len(bands_k)
    if nk == 0:
        raise RuntimeError("有效质量拟合失败：能带数据为空，请确认能带计算输出完整。")

    if distances:
        distances = [float(x) for x in distances[:nk]]
    if not distances or len(distances) != nk:
        distances = [float(i) for i in range(nk)]

    rel = [[val - efermi for val in row] for row in bands_k]
    nb = len(rel[0]) if rel else 0

    v_idx = (0, 0)
    c_idx = (0, 0)
    vbm_E = -1e9
    cbm_E = 1e9
    for k in range(nk):
        occ_row = occs_k[k] if k < len(occs_k) else []
        for b in range(nb):
            energy = rel[k][b]
            occupied = occ_row[b] if b < len(occ_row) else (1.0 if energy < 0 else 0.0)
            if occupied > 0.5 and energy > vbm_E:
                vbm_E = energy
                v_idx = (b, k)
            if occupied < 0.5 and energy < cbm_E:
                cbm_E = energy
                c_idx = (b, k)

    rel_by_band = _transpose_band_table(rel)
    if not rel_by_band:
        raise RuntimeError("有效质量拟合失败：能带数据为空，请确认能带计算输出完整。")

    def _fit_mass(idx: tuple[int, int]) -> tuple[float, list[float], list[float]]:
        band, k0 = idx
        if band < 0 or band >= len(rel_by_band):
            return float("nan"), [], []
        series = rel_by_band[band]
        if not series:
            return float("nan"), [], []
        k0 = max(0, min(k0, len(series) - 1, len(distances) - 1))
        lo = max(0, k0 - window)
        hi = min(len(distances), len(series), k0 + window + 1)
        xs = _np.array(distances[lo:hi], dtype=float)
        ys = _np.array(series[lo:hi], dtype=float)
        if len(xs) < 3:
            return float("nan"), xs.tolist(), ys.tolist()
        coeffs = _np.polyfit(xs, ys, 2)
        a = coeffs[0]
        d2E = 2.0 * a * EV_TO_J * (ANG_TO_M**2)
        if abs(d2E) < 1e-40:
            return float("nan"), xs.tolist(), ys.tolist()
        m_star = HBAR**2 / d2E
        return float(m_star / M_E), xs.tolist(), ys.tolist()

    me_star, _, _ = _fit_mass(c_idx)
    mh_star, _, _ = _fit_mass(v_idx)

    fig = Figure(figsize=(5.2, 3.4))
    ax = fig.add_subplot(111)
    for series in rel_by_band:
        if not series:
            continue
        length = min(len(series), len(distances))
        if length <= 1:
            continue
        ax.plot(distances[:length], series[:length], lw=0.7, alpha=0.6)
    if distances and v_idx[0] < len(rel_by_band) and v_idx[1] < len(distances) and v_idx[1] < len(rel_by_band[v_idx[0]]):
        ax.scatter([distances[v_idx[1]]], [rel_by_band[v_idx[0]][v_idx[1]]], s=28, label=f"VBM m*_h≈{mh_star:.2f} m_e")
    if distances and c_idx[0] < len(rel_by_band) and c_idx[1] < len(distances) and c_idx[1] < len(rel_by_band[c_idx[0]]):
        ax.scatter([distances[c_idx[1]]], [rel_by_band[c_idx[0]][c_idx[1]]], s=28, label=f"CBM m*_e≈{me_star:.2f} m_e")
    ax.axhline(0.0, lw=1.0, ls="--")
    ax.set_ylabel("E - E$_F$ (eV)")
    apply_style(ax, style)
    ax.legend(fontsize=9, frameon=False)
    fig.tight_layout()
    fig_path = figs_dir / "effective_mass.png"
    fig.savefig(fig_path, dpi=POST_FIG_DPI)

    csv_path = tables_dir / "effective_mass.csv"
    with csv_path.open("w", encoding="utf-8") as fh:
        fh.write("edge,band_index,k_index,m*/m_e\n")
        fh.write(f"VBM,{v_idx[0]},{v_idx[1]},{mh_star:.6f}\n")
        fh.write(f"CBM,{c_idx[0]},{c_idx[1]},{me_star:.6f}\n")

    metrics = {"mh*": float(mh_star), "me*": float(me_star)}
    notes = [
        "m* 为路径方向的一维近似，建议在关键方向上复核。",
        f"拟合窗口 ±{window} 个 k 点，可在界面调整。",
    ]
    return PostResult(metrics=metrics, figs={"effective_mass": fig_path}, tables={"effective_mass": csv_path}, notes=notes)


register_postproc(PostProc(name="emass", needs=["vasprun.xml|EIGENVAL"], runner=proc_effective_mass))


def _parse_locpot_planar_z(locpot: Path) -> Optional[tuple[list[float], list[float]]]:
    if not HAS_NUMPY:
        return None
    import numpy as _np

    text = read_text(locpot)
    if not text:
        return None
    lines = text.splitlines()
    if len(lines) < 20:
        return None
    try:
        scale = float(lines[1].strip())
        a1 = [float(x) for x in lines[2].split()[:3]]
        a2 = [float(x) for x in lines[3].split()[:3]]
        a3 = [float(x) for x in lines[4].split()[:3]]
    except Exception:
        return None
    idx = 5
    counts = None
    if idx < len(lines) and re.match(r"^[A-Za-z]", lines[idx].strip() or ""):
        idx += 1
    if idx >= len(lines):
        return None
    try:
        counts = [int(x) for x in lines[idx].split()]
    except Exception:
        return None
    idx += 1
    if idx < len(lines) and lines[idx].strip().lower().startswith("selective"):
        idx += 1
    if idx < len(lines):
        mode = lines[idx].strip().lower()
        if mode.startswith("direct") or mode.startswith("cart"):
            idx += 1
    natoms = sum(counts) if counts else 0
    idx += natoms
    if idx >= len(lines):
        return None
    try:
        nx, ny, nz = map(int, lines[idx].split()[:3])
    except Exception:
        return None
    idx += 1
    values: list[float] = []
    while idx < len(lines):
        s = lines[idx].strip()
        if s:
            try:
                values.extend([float(x) for x in s.split()])
            except Exception:
                pass
        idx += 1
    arr = _np.array(values, dtype=float)
    if arr.size != nx * ny * nz:
        return None
    arr = arr.reshape((nz, ny, nx))
    planar = arr.mean(axis=(1, 2))
    lattice = _np.array([a1, a2, a3], dtype=float) * scale
    c_len = float(_np.linalg.norm(lattice[2]))
    z = [c_len * i / nz for i in range(nz)]
    return z, planar.tolist()


def proc_planar_potential(workdir: Path, opts: Dict[str, Any]) -> PostResult:

    style = _normalize_style(opts.get("style"))
    report_dir, figs_dir, tables_dir = _ensure_report_dirs(workdir, opts)
    demo_payload = opts.get("demo_payload") if isinstance(opts.get("demo_payload"), dict) else None

    if demo_payload:
        z = [float(v) for v in demo_payload.get("z", [])]
        values = [float(v) for v in demo_payload.get("values", [])]
        if not z or not values:
            raise RuntimeError("演示数据缺少平面势信息，无法绘制。")
    else:
        if not HAS_NUMPY:
            raise RuntimeError("需要 numpy 才能解析平面平均势，请安装 numpy。")


        locpot = workdir / "LOCPOT"
        if not locpot.exists():
            raise FileNotFoundError("未找到 LOCPOT，请在计算中输出局域势。")

        data = _parse_locpot_planar_z(locpot)
        if not data:
            raise RuntimeError("解析 LOCPOT 失败或数据不完整，请确认计算输出了 LOCPOT/CHGCAR 并保持文件完整。")
        z, values = data
        if not values:
            raise RuntimeError("LOCPOT 中未获得平面平均势数据，请检查 LOCPOT 是否写全。")

    baseline = values[0]
    rel = [v - baseline for v in values]

    fig = Figure(figsize=(5.2, 3.2))
    ax = fig.add_subplot(111)
    ax.plot(z, rel, lw=1.4)
    ax.set_xlabel("z (Å)")
    ax.set_ylabel("V(z) - V(0) (eV)")
    apply_style(ax, style)
    fig.tight_layout()
    fig_path = figs_dir / "planar_potential.png"
    fig.savefig(fig_path, dpi=POST_FIG_DPI)

    csv_path = tables_dir / "planar_potential.csv"
    with csv_path.open("w", encoding="utf-8") as fh:
        fh.write("z_A,V_rel_eV\n")
        for zi, val in zip(z, rel):
            fh.write(f"{zi:.6f},{val:.6f}\n")

    metrics = {"V_peak": float(max(rel, default=0.0)), "V_min": float(min(rel, default=0.0))}
    if demo_payload:
        notes = ["演示模式示例平面平均势，展示界面势垒轮廓。"]
    else:
        notes = [
            "平面平均势反映沿 z 的势垒分布，可结合滑动平均进一步分析界面偶极。",
        ]
    return PostResult(metrics=metrics, figs={"planar_potential": fig_path}, tables={"planar_potential": csv_path}, notes=notes)


register_postproc(PostProc(name="pot_z", needs=["LOCPOT"], runner=proc_planar_potential))

# ----------------------------- GUI 组件 ------------------------------------

class SystemStatsMonitor(threading.Thread):
    """后台线程：监视 CPU/进程以及关键文件增长情况。"""

    def __init__(self, workdir: Path, watch_files: list[str] | None, on_update=None):
        super().__init__(daemon=True)
        self.workdir = Path(workdir).expanduser()
        try:
            self.workdir_resolved = self.workdir.resolve()
        except Exception:
            self.workdir_resolved = self.workdir
        self.watch_files = watch_files or []
        self.on_update = on_update  # callback(dict)
        self._stop_event = threading.Event()
        self._prev_cpu = None  # tuple(total, idle)
        self._prev_sizes: dict[Path, int] = {}

    def stop(self):
        self._stop_event.set()

        if self.is_alive():
            try:
                self.join(timeout=2.0)
            except RuntimeError:
                pass

    def run(self):
        while not self._stop_event.is_set():
            stats = self._collect_stats()
            if self.on_update:
                try:
                    self.on_update(stats)
                except Exception:
                    pass
            for _ in range(6):
                if self._stop_event.is_set():
                    break
                time.sleep(0.5)

    def _collect_stats(self) -> dict:
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
        cpu_usage = self._cpu_usage_percent()
        loadavg = self._loadavg()
        files = self._file_stats()
        procs = self._process_stats()
        run_state, run_pids, suggestions, run_elapsed = self._run_status(procs, files)
        return {
            "timestamp": timestamp,
            "cpu_usage": cpu_usage,
            "loadavg": loadavg,
            "files": files,
            "processes": procs,
            "run_state": run_state,
            "run_pids": run_pids,
            "suggestions": suggestions,
            "run_elapsed": run_elapsed,
        }

    def _cpu_usage_percent(self) -> float | None:
        proc_stat = Path("/proc/stat")
        if not proc_stat.exists():
            return None
        try:
            line = proc_stat.read_text().splitlines()[0]
        except Exception:
            return None
        parts = line.split()
        if len(parts) < 5 or parts[0] != "cpu":
            return None
        try:
            values = [float(x) for x in parts[1:]]
        except Exception:
            return None
        idle = values[3]
        total = sum(values)
        if self._prev_cpu is None:
            self._prev_cpu = (total, idle)
            return None
        prev_total, prev_idle = self._prev_cpu
        total_delta = total - prev_total
        idle_delta = idle - prev_idle
        self._prev_cpu = (total, idle)
        if total_delta <= 0:
            return None
        usage = max(0.0, min(100.0, (1.0 - idle_delta / total_delta) * 100.0))
        return usage

    def _loadavg(self) -> tuple[float, float, float] | None:
        if hasattr(os, "getloadavg"):
            try:
                return os.getloadavg()
            except OSError:
                return None
        return None

    def _file_stats(self) -> list[dict]:
        stats = []
        for name in self.watch_files:
            if not name:
                continue
            p = Path(name)
            if not p.is_absolute():
                p = self.workdir / name
            p = p.resolve()
            info = {
                "name": str(p),
                "exists": False,
                "size": 0,
                "delta": 0,
            }
            try:
                if p.exists():
                    size = p.stat().st_size
                    prev = self._prev_sizes.get(p, size)
                    info.update({
                        "exists": True,
                        "size": size,
                        "delta": size - prev,
                    })
                    self._prev_sizes[p] = size
            except Exception:
                pass
            stats.append(info)
        return stats

    def _process_stats(self) -> list[dict]:
        # 限制输出 + 超时，避免在某些系统里 ps 卡住
        try:
            out = subprocess.check_output(
                ["bash", "-lc", "ps -eo pid,etimes,%cpu,%mem,cmd --sort=-%cpu | head -n 6"],
                text=True, stderr=subprocess.DEVNULL, timeout=2.0
            )
        except Exception:
            try:
                out = subprocess.check_output(
                    ["ps", "-eo", "pid,etimes,%cpu,%mem,cmd"],
                    text=True, stderr=subprocess.DEVNULL, timeout=2.0
                )
                out = "\n".join(out.splitlines()[:6])
            except Exception:
                return []

        lines = out.strip().splitlines()
        procs = []
        for line in lines[1:6]:
            parts = line.split(None, 4)
            if len(parts) < 4:
                continue
            pid = parts[0]
            elapsed_str = parts[1] if len(parts) >= 2 else ""
            cpu = parts[2] if len(parts) >= 3 else ""
            mem = parts[3] if len(parts) >= 4 else ""
            cmd_full = parts[4] if len(parts) >= 5 else ""
            try:
                elapsed = int(elapsed_str)
            except Exception:
                elapsed = None
            cwd = self._proc_cwd(pid)

            in_project = False
            try:
                if cwd:
                    resolved = Path(cwd).resolve()
                    in_project = (resolved == self.workdir_resolved)
                    if not in_project:
                        try:
                            resolved.relative_to(self.workdir_resolved)
                            in_project = True
                        except Exception:
                            in_project = False
            except Exception:
                in_project = False

            cmd_lower = cmd_full.lower()
            is_vasp = ("vasp" in cmd_lower) or ("mpi" in cmd_lower and "vasp" in cmd_lower)
            procs.append({
                "pid": pid, "cmd": cmd_full.strip(),
                "cpu": cpu, "mem": mem,
                "is_vasp": is_vasp, "cwd": cwd, "in_project": in_project,
                "elapsed": elapsed,
            })
        return procs

    def _proc_cwd(self, pid: str) -> str | None:
        proc_path = Path("/proc") / str(pid) / "cwd"
        try:
            return os.readlink(proc_path)
        except Exception:
            return None

    def _run_status(self, procs: list[dict], files: list[dict]) -> tuple[str, list[str], list[str], int | None]:
        run_pids: list[str] = []
        suggestions: list[str] = []
        run_elapsed: int | None = None
        for proc in procs:
            if proc.get("is_vasp") and proc.get("in_project"):
                run_pids.append(proc.get("pid", ""))
                elapsed_val = proc.get("elapsed")
                if isinstance(elapsed_val, (int, float)):
                    elapsed_int = int(elapsed_val)
                    if elapsed_int >= 0:
                        if run_elapsed is None or elapsed_int > run_elapsed:
                            run_elapsed = elapsed_int
        run_state = "running" if run_pids else "idle"
        if run_pids:
            suggestions.append(
                f"检测到 {len(run_pids)} 个 VASP 相关进程在 {self.workdir} 运行。"
            )
        else:
            suggestions.append("未检测到项目内的 VASP 进程，可检查作业或尝试重新启动。")

        for item in files:
            short = Path(item.get("name", "")).name
            if not item.get("exists"):
                suggestions.append(f"未发现 {short}，请确认计算是否已开始输出。")
            else:
                delta = item.get("delta")
                if isinstance(delta, (int, float)) and delta <= 0 and run_pids:
                    suggestions.append(f"{short} 暂未增长，可稍后再次检查。")
        if len(suggestions) > 5:
            suggestions = suggestions[:5]
        return run_state, run_pids, suggestions, run_elapsed

    @classmethod
    def snapshot(cls, workdir: Path, watch_files: list[str] | None) -> dict:
        monitor = cls(workdir, watch_files, on_update=None)
        return monitor._collect_stats()


class PostprocWorker(threading.Thread):
    """后台线程：统一调度后处理任务。"""

    def __init__(self, app: "VaspGUI", key: str, opts: Dict[str, Any]):
        super().__init__(daemon=True)
        self.app = app
        self.key = key
        self.opts = opts

    def run(self):
        app = self.app
        proc = POSTPROCS.get(self.key)
        workdir: Path = self.opts.get("workdir", app.current_project_path())
        if not proc:
            app.after(0, lambda: app._on_postproc_error(self.key, "未注册的后处理任务"))
            return
        try:
            result = proc.runner(workdir, self.opts)
        except FileNotFoundError as exc:
            err_msg = str(exc)
            app.after(0, app._on_postproc_error, self.key, err_msg)
            return
        except Exception as exc:
            err_msg = f"后处理异常：{exc}"
            app.after(0, app._on_postproc_error, self.key, err_msg)
            return
        app.after(0, lambda: app._on_postproc_success(self.key, result, workdir, self.opts))


class EnergyMonitor(threading.Thread):
    """后台线程：周期性解析 OSZICAR，提取 F/E0 能量，供主线程绘图。"""
    def __init__(self, workdir: Path, on_update):
        super().__init__(daemon=True)
        self.workdir = workdir
        self.on_update = on_update  # callback(steps:list[int], energies:list[float])
        self._stop_event = threading.Event()
        self.steps = []
        self.energies = []
        self._last_size = 0
        self._last_pos = 0

    def stop(self):
        self._stop_event.set()
        if self.is_alive():
            try:
                self.join(timeout=2.0)
            except RuntimeError:
                pass

    def run(self):
        osz = self.workdir / "OSZICAR"
        outcar = self.workdir / "OUTCAR"
        while not self._stop_event.is_set():
            try:
                target = None
                if osz.exists() and osz.stat().st_size > 0:
                    target = osz
                elif outcar.exists() and outcar.stat().st_size > 0:
                    target = outcar
                if target:
                    size = target.stat().st_size
                    reset = False
                    if size < self._last_size:
                        reset = True
                        self._last_pos = 0
                        self._last_size = 0
                        self.steps = [];
                        self.energies = []
                    if reset or size > self._last_size:
                        self._parse(target, reset)
                        self._last_size = size
                        if self.on_update:
                            self.on_update(self.steps, self.energies)
            except Exception:
                pass
            time.sleep(1.0)

    def _parse(self, path: Path, reset: bool):
        try:
            with path.open("r", encoding="utf-8", errors="ignore") as f:
                if not reset and self._last_pos:
                    f.seek(self._last_pos)
                else:
                    self.steps = []
                    self.energies = []
                new_pts = 0
                for line in f:
                    val = None
                    m = ENERGY_RX.search(line)
                    if m:
                        val = m.group(1) or m.group(2)
                    else:
                        # 若传入的是 OUTCAR，尝试 TOTEN 兜底
                        m2 = TOTEN_RX.search(line)
                        if m2:
                            val = m2.group(1)
                    if val is not None:
                        try:
                            # Fortran 指数 D 替换为 E
                            e = float(val.replace("D", "E").replace("d", "E"))
                            self.steps.append(len(self.steps) + 1)
                            self.energies.append(e)
                            new_pts += 1
                        except Exception:
                            pass
                self._last_pos = f.tell()
        except Exception:
            return


class VaspGUI(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title(f"{APP_NAME}")
        self.geometry("1200x800")
        if HAS_TTKBOOTSTRAP and tb is not None:
            style = None
            try:
                style = tb.Style()
            except Exception:
                style = None
            if style is not None:
                for theme in ("cosmo", "flatly", "darkly", "minty"):
                    try:
                        style.theme_use(theme)
                        break
                    except Exception:
                        continue

        self.project_dir = Path.cwd()
        self.proc = None  # subprocess.Popen or None
        self.monitor = None  # EnergyMonitor
        self.sys_monitor = None  # SystemStatsMonitor
        self.run_status_var = tk.StringVar(value="⚪ 未检测")
        self.figure_style_var = tk.StringVar(value="AFM")
        self.emit_report_var = tk.BooleanVar(value=True)
        self.demo_mode = False
        self.demo_project_dir: Path | None = None
        self._pre_demo_project: Path | None = None
        self.run_suggestion_widgets: list[tk.Text] = []
        self.post_results: dict[str, PostResult] = {}
        self.post_latest_reports: dict[str, Path] = {}
        self.ui_mode = tk.StringVar(value="newbie")
        self.overview_items = [
            ("__project__", "项目目录"),
            ("INCAR", "INCAR"),
            ("POSCAR", "POSCAR"),
            ("KPOINTS", "KPOINTS"),
            ("POTCAR", "POTCAR"),
            ("CONTCAR", "CONTCAR"),
            ("vasp.out", "vasp.out"),
            ("OSZICAR", "OSZICAR"),
            ("OUTCAR", "OUTCAR"),
        ]
        self.overview_label_map = {k: label for k, label in self.overview_items}
        self.overview_key_map = {k.lower(): k for k, _ in self.overview_items}

        self._build_ui()
        self.set_project(self.project_dir)

        # 加载历史配置（若存在）
        try:
            self.load_config()
        except Exception:
            pass

    # ------------------------- UI 构建 ----------------------------------
    def _build_ui(self):
        # 顶部工具栏
        toolbar = ttk.Frame(self)
        toolbar.pack(side=tk.TOP, fill=tk.X)

        ttk.Label(toolbar, text="项目目录:").pack(side=tk.LEFT, padx=6)
        self.project_var = tk.StringVar(value=str(self.project_dir))
        self.project_entry = ttk.Entry(toolbar, textvariable=self.project_var, width=80)
        self.project_entry.pack(side=tk.LEFT, padx=4)
        ttk.Button(toolbar, text="选择…", command=self.choose_project).pack(side=tk.LEFT)
        ttk.Button(toolbar, text="新建项目", command=self.create_project).pack(side=tk.LEFT, padx=4)
        ttk.Button(toolbar, text="首次向导", command=self.launch_first_time_wizard).pack(side=tk.LEFT, padx=4)
        ttk.Button(toolbar, text="创建示例项目", command=self.on_create_example_project).pack(side=tk.LEFT, padx=4)
        self.demo_mode_var = tk.BooleanVar(value=False)
        ttk.Checkbutton(toolbar, text="演示模式", variable=self.demo_mode_var, command=self.toggle_demo_mode).pack(side=tk.LEFT, padx=6)
        ttk.Label(toolbar, text="模式:").pack(side=tk.LEFT, padx=(12, 0))
        ttk.Radiobutton(toolbar, text="简单模式", value="newbie", variable=self.ui_mode).pack(side=tk.LEFT, padx=(4, 0))
        ttk.Radiobutton(toolbar, text="专业模式", value="expert", variable=self.ui_mode).pack(side=tk.LEFT, padx=(4, 8))

        # Notebook
        self.nb = ttk.Notebook(self)
        self.nb.pack(fill=tk.BOTH, expand=True)

        self.page_inputs = self._build_inputs_page(self.nb)

        # 先把 workflow 会引用到的页面都建好
        self.page_run = self._build_run_page(self.nb)
        self.page_monitor = self._build_monitor_page(self.nb)
        self.page_post = self._build_post_page(self.nb)

        # 二维相关页面会在流程助手中引用，需提前创建以保证属性存在
        self.page_twist = self._build_twistshift_page(self.nb)
        self.page_twist_results = self._build_twistshift_results_page(self.nb)

        # 最后再建 workflow（里面会引用上面这些页面）
        self.page_workflow = self._build_workflow_page(self.nb)

        self.nb.add(self.page_inputs, text="输入 / POTCAR / K 点")
        self.nb.add(self.page_workflow, text="流程助手")
        self.nb.add(self.page_run, text="运行 / 提交")
        self.nb.add(self.page_monitor, text="监视")
        self.nb.add(self.page_post, text="后处理")

        # === CODEX BEGIN: add twist/shift tab ===
        self.nb.add(self.page_twist, text="二维材料·滑移/扭转")
        # 结果演示页：用于快速加载 CSV/JSON 并绘制热图
        self.nb.add(self.page_twist_results, text="二维材料·结果演示")
        # === CODEX END: add twist/shift tab ===

        self.protocol("WM_DELETE_WINDOW", self.on_close)

        self.ui_mode.trace_add("write", lambda *_: self._update_mode_ui())
        self.after(50, self._update_mode_ui)

    def toggle_demo_mode(self):
        if self.demo_mode_var.get():
            self._activate_demo_mode()
        else:
            self._deactivate_demo_mode()

    def _activate_demo_mode(self):
        if self.demo_mode:
            return
        self._pre_demo_project = self.current_project_path()
        try:
            demo_dir = self._prepare_demo_project()
        except Exception as exc:
            self.demo_mode_var.set(False)
            messagebox.showerror(APP_NAME, f"演示模式初始化失败：{exc}")
            return
        self.demo_mode = True
        self.demo_project_dir = demo_dir
        self.demo_mode_var.set(True)
        self.set_project(demo_dir)
        try:
            twist_dir = demo_dir / "twist_sweep"
            self._tw_write_demo_results(twist_dir)
        except Exception:
            pass
        try:
            demo_poscar = demo_dir / "POSCAR"
            if demo_poscar.exists():
                self.tw_top_path.set(str(demo_poscar))
                self.tw_bot_path.set(str(demo_poscar))
        except Exception:
            pass
        try:
            self.tw_dir.set(str(twist_dir))
            self._tw_load_dir(twist_dir)
        except Exception:
            pass
        self.apply_run_status("🧪 演示模式", ["已加载内置示例数据，可直接体验全部后处理功能。"])

    def _deactivate_demo_mode(self):
        if not self.demo_mode:
            return
        prev = self._pre_demo_project or Path.cwd()
        self.demo_mode = False
        self.demo_mode_var.set(False)
        self._pre_demo_project = None
        try:
            self.set_project(prev)
        finally:
            self._cleanup_demo_project()
        self.refresh_run_status()

    def _prepare_demo_project(self) -> Path:
        self._cleanup_demo_project()
        demo_root = Path(tempfile.mkdtemp(prefix="vasp_gui_demo_"))
        self._ensure_project_scaffold(demo_root)
        for name, content in DEMO_PROJECT_FILES.items():
            try:
                write_text(demo_root / name, content)
            except Exception:
                pass
        (demo_root / "reports").mkdir(parents=True, exist_ok=True)
        return demo_root

    def _cleanup_demo_project(self):
        demo_dir = self.demo_project_dir
        if demo_dir and demo_dir.exists():
            try:
                shutil.rmtree(demo_dir)
            except Exception:
                pass
        self.demo_project_dir = None

    # ------------------------- 页面：输入文件 -----------------------------
    def _build_inputs_page(self, parent):
        frame = ttk.Frame(parent)

        # 外层滚动容器，确保内容较多时仍可完整浏览
        canvas = tk.Canvas(frame, highlightthickness=0)
        vscroll = ttk.Scrollbar(frame, orient=tk.VERTICAL, command=canvas.yview)
        canvas.configure(yscrollcommand=vscroll.set)
        canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        vscroll.pack(side=tk.RIGHT, fill=tk.Y)

        inner = ttk.Frame(canvas)
        inner_id = canvas.create_window((0, 0), window=inner, anchor="nw")

        def _update_scrollregion(event=None):
            canvas.configure(scrollregion=canvas.bbox("all"))

        def _sync_inner_width(event):
            canvas.itemconfigure(inner_id, width=event.width)

        inner.bind("<Configure>", _update_scrollregion)
        canvas.bind("<Configure>", _sync_inner_width)

        def _on_mousewheel(event):
            if isinstance(event.widget, tk.Text):
                return
            delta = 0
            if event.delta:
                delta = -int(event.delta / 120)
            elif getattr(event, "num", None) in (4, 5):
                delta = -1 if event.num == 4 else 1
            if delta:
                canvas.yview_scroll(delta, "units")

        def _bind_mousewheel(widget):
            def _on_enter(_event):
                canvas.bind_all("<MouseWheel>", _on_mousewheel)
                canvas.bind_all("<Button-4>", _on_mousewheel)
                canvas.bind_all("<Button-5>", _on_mousewheel)

            def _on_leave(_event):
                canvas.unbind_all("<MouseWheel>")
                canvas.unbind_all("<Button-4>")
                canvas.unbind_all("<Button-5>")

            widget.bind("<Enter>", _on_enter)
            widget.bind("<Leave>", _on_leave)

        _bind_mousewheel(inner)

        style = ttk.Style()
        style.configure("TwBanner.TFrame", background="#e7f1ff")
        style.configure("TwBanner.TLabel", background="#e7f1ff", foreground="#0a5cad")

        self.tw_banner_frame = ttk.Frame(inner, padding=8, style="TwBanner.TFrame")
        self.tw_banner_var = tk.StringVar(value="")
        banner_label = ttk.Label(
            self.tw_banner_frame,
            textvariable=self.tw_banner_var,
            wraplength=900,
            justify=tk.LEFT,
            style="TwBanner.TLabel",
        )
        banner_label.pack(side=tk.LEFT, fill=tk.X, expand=True)
        ttk.Button(
            self.tw_banner_frame,
            text="开始二维材料扫描",
            command=self._tw_launch_wizard,
        ).pack(side=tk.RIGHT, padx=(8, 0))
        self._tw_banner_visible = False

        paned = ttk.PanedWindow(inner, orient=tk.HORIZONTAL)
        paned.pack(fill=tk.BOTH, expand=True, padx=8, pady=8)

        # 左边：INCAR 模板
        left = ttk.Frame(paned, padding=8)
        paned.add(left, weight=1)

        self.incar_section_label = ttk.Label(left, text="INCAR 模板与编辑")
        self.incar_section_label.pack(anchor=tk.W)
        self.incar_template = tk.StringVar(value="relax")
        self.incar_template_bar = ttk.Frame(left)
        self.incar_template_bar.pack(fill=tk.X, pady=4)
        for key, txt in [
            ("relax", "几何优化"),
            ("static", "静态自洽"),
            ("dos", "态密度"),
            ("bands", "能带预设"),
        ]:
            ttk.Radiobutton(
                self.incar_template_bar,
                text=txt,
                value=key,
                variable=self.incar_template,
                command=self.load_incar_template,
            ).pack(side=tk.LEFT)
        ttk.Button(self.incar_template_bar, text="加载模板到编辑器", command=self.load_incar_template).pack(side=tk.RIGHT)

        # INCAR 简单面板
        self.incar_simple_box = ttk.LabelFrame(left, text="INCAR 关键旋钮（简单模式）")
        self.incar_simple_box.pack(fill=tk.X, pady=4)
        self.incar_simple_vars: dict[str, tk.StringVar] = {}
        simple_items = [
            ("ENCUT", "ENCUT (eV)"),
            ("KSPACING", "KSPACING (Å⁻¹)"),
            ("ISMEAR", "ISMEAR"),
            ("SIGMA", "SIGMA"),
            ("EDIFF", "EDIFF"),
            ("EDIFFG", "EDIFFG"),
            ("ISPIN", "ISPIN"),
            ("MAGMOM", "MAGMOM"),
            ("LREAL", "LREAL"),
        ]
        for idx, (key, label) in enumerate(simple_items):
            row = idx // 2
            col = idx % 2
            frame_cell = ttk.Frame(self.incar_simple_box)
            frame_cell.grid(row=row, column=col, sticky="ew", padx=4, pady=2)
            ttk.Label(frame_cell, text=label + ":").pack(side=tk.LEFT)
            var = tk.StringVar()
            self.incar_simple_vars[key] = var
            entry = ttk.Entry(frame_cell, textvariable=var, width=14)
            entry.pack(side=tk.LEFT, padx=4)
        for i in range(2):
            self.incar_simple_box.grid_columnconfigure(i, weight=1)
        btn_row = ttk.Frame(self.incar_simple_box)
        btn_row.grid(row=(len(simple_items)+1)//2, column=0, columnspan=2, sticky="ew", pady=(4, 0))
        ttk.Button(btn_row, text="从编辑器读取", command=self.refresh_incar_simple_panel).pack(side=tk.LEFT)
        ttk.Button(btn_row, text="写入到编辑器", command=self.apply_incar_simple_panel).pack(side=tk.LEFT, padx=6)

        self.incar_advanced_frame = ttk.Frame(left)
        self.incar_advanced_frame.pack(fill=tk.BOTH, expand=True)
        self.incar_text = ScrolledText(self.incar_advanced_frame, height=20, undo=True, wrap="none")
        self.incar_text.pack(fill=tk.BOTH, expand=True)
        btns = ttk.Frame(self.incar_advanced_frame)
        btns.pack(fill=tk.X, pady=4)
        ttk.Button(btns, text="打开现有 INCAR", command=lambda: self.open_into_editor("INCAR", self.incar_text)).pack(side=tk.LEFT)
        ttk.Button(btns, text="保存到项目", command=lambda: self.save_from_editor("INCAR", self.incar_text)).pack(side=tk.LEFT, padx=6)

        # 记录 pack 参数以便模式切换时恢复
        try:
            self._incar_template_pack_opts = self.incar_template_bar.pack_info()
            self._incar_template_pack_opts.pop("in", None)
        except Exception:
            self._incar_template_pack_opts = {"fill": tk.X, "pady": 4}
        try:
            self._incar_advanced_pack_opts = self.incar_advanced_frame.pack_info()
            self._incar_advanced_pack_opts.pop("in", None)
        except Exception:
            self._incar_advanced_pack_opts = {"fill": tk.BOTH, "expand": True}

        # 右边：POSCAR & KPOINTS 编辑
        right = ttk.Frame(paned, padding=8)
        paned.add(right, weight=1)

        ttk.Label(right, text="POSCAR 编辑").pack(anchor=tk.W)
        self.poscar_text = ScrolledText(right, height=10, undo=True, wrap="none")
        self.poscar_text.pack(fill=tk.BOTH, expand=True)
        row = ttk.Frame(right)
        row.pack(fill=tk.X, pady=4)
        ttk.Button(row, text="打开 POSCAR", command=lambda: self.open_into_editor("POSCAR", self.poscar_text)).pack(side=tk.LEFT)
        ttk.Button(row, text="保存 POSCAR", command=lambda: self.save_from_editor("POSCAR", self.poscar_text)).pack(side=tk.LEFT, padx=6)
        ttk.Button(row, text="从 POSCAR 解析元素", command=self.show_poscar_elements).pack(side=tk.LEFT, padx=6)

        ttk.Separator(right, orient=tk.HORIZONTAL).pack(fill=tk.X, pady=6)

        ttk.Label(right, text="K 点设置（可改为 KSPACING 自动生成）").pack(anchor=tk.W)
        self.kpoints_text = ScrolledText(right, height=10, undo=True, wrap="none")
        self.kpoints_text.pack(fill=tk.BOTH, expand=True)
        row2 = ttk.Frame(right)
        row2.pack(fill=tk.X, pady=4)
        ttk.Button(row2, text="打开 KPOINTS", command=lambda: self.open_into_editor("KPOINTS", self.kpoints_text)).pack(side=tk.LEFT)
        ttk.Button(row2, text="保存 KPOINTS", command=lambda: self.save_from_editor("KPOINTS", self.kpoints_text)).pack(side=tk.LEFT, padx=6)

        ttk.Separator(inner, orient=tk.HORIZONTAL).pack(fill=tk.X, padx=8, pady=6)

        potcar_box = ttk.LabelFrame(inner, text="POTCAR 赝势")
        potcar_box.pack(fill=tk.BOTH, expand=False, padx=8, pady=4)
        self._populate_potcar_section(potcar_box)

        ttk.Separator(inner, orient=tk.HORIZONTAL).pack(fill=tk.X, padx=8, pady=6)

        kpoints_box = ttk.LabelFrame(inner, text="K 点生成")
        kpoints_box.pack(fill=tk.BOTH, expand=False, padx=8, pady=4)
        self._populate_kpoints_section(kpoints_box)

        # 默认加载模板并同步简单面板
        self.load_incar_template()
        self.refresh_incar_simple_panel()
        self._update_tw_entry_banner()
        return frame

    def load_incar_template(self):
        tpl = self.incar_template.get()
        presets = {
            "relax": (
                """# ==== 几何优化（PBE）====\nSYSTEM = relax\nENCUT = 520\nPREC  = Accurate\nEDIFF = 1e-6\nEDIFFG = -0.02\nISMEAR = 0\nSIGMA  = 0.05\nIBRION = 2\nISIF   = 3\nNSW    = 100\nISPIN  = 1\nLREAL  = Auto\n# 可选：KSPACING = 0.22\n"""
            ),
            "static": (
                """# ==== 静态自洽（SCF）====\nSYSTEM = scf\nENCUT = 520\nPREC  = Accurate\nEDIFF = 1e-6\nISMEAR = 0\nSIGMA  = 0.05\nIBRION = -1\nNSW    = 0\nLREAL  = Auto\nLWAVE  = .FALSE.\nLCHARG = .TRUE.\n# 可选：KSPACING = 0.22\n"""
            ),
            "dos": (
                """# ==== DOS 计算（在已收敛电荷上）====\nSYSTEM = dos\nENCUT = 520\nPREC  = Accurate\nEDIFF = 1e-6\nISMEAR = 0\nSIGMA  = 0.05\nIBRION = -1\nNSW    = 0\nLORBIT = 11\nNEDOS  = 2000\nLCHARG = .TRUE.\nLWAVE  = .FALSE.\n# 可选：KSPACING = 0.18\n"""
            ),
            "bands": (
                """# ==== 能带预设（非自洽）====\nSYSTEM = bands\nENCUT = 520\nPREC  = Accurate\nEDIFF = 1e-6\nISMEAR = 0\nSIGMA  = 0.05\nIBRION = -1\nNSW    = 0\nICHARG = 11\nLORBIT = 11\nLCHARG = .FALSE.\nLWAVE  = .TRUE.\n# KPOINTS 请使用路径方式或外部生成器\n"""
            ),
        }
        self.incar_text.delete("1.0", tk.END)
        self.incar_text.insert("1.0", presets.get(tpl, presets["relax"]))
        self.refresh_incar_simple_panel()

    def refresh_incar_simple_panel(self):
        if not hasattr(self, "incar_simple_vars"):
            return
        text = self.incar_text.get("1.0", tk.END)
        values: dict[str, str] = {}
        for line in text.splitlines():
            stripped = line.strip()
            if not stripped or stripped.startswith("#") or stripped.startswith("!"):
                continue
            m = re.match(r"([A-Za-z0-9_+-]+)\s*=\s*(.+)", stripped)
            if m:
                key_raw = m.group(1).upper()
                key = KEY_CORRECTIONS.get(key_raw, key_raw)
                val = m.group(2)
                for sep in ("!", "#"):
                    idx = val.find(sep)
                    if idx != -1:
                        val = val[:idx]
                        break
                values[key] = val.strip()
        for key, var in self.incar_simple_vars.items():
            var.set(values.get(key, ""))

    def apply_incar_simple_panel(self):
        if not hasattr(self, "incar_simple_vars"):
            return
        updates = {}
        for key, var in self.incar_simple_vars.items():
            val = var.get().strip()
            updates[key] = val
        text = self.incar_text.get("1.0", tk.END)
        new_text = self._update_incar_text(text, updates)
        self.incar_text.delete("1.0", tk.END)
        self.incar_text.insert("1.0", new_text)
        self.refresh_incar_simple_panel()

    def _update_mode_ui(self):
        mode = getattr(self, "ui_mode", None)
        mode_val = "newbie"
        if mode is not None:
            mode_val = mode.get()
        simple_box = getattr(self, "incar_simple_box", None)
        template_bar = getattr(self, "incar_template_bar", None)
        section_label = getattr(self, "incar_section_label", None)
        advanced_frame = getattr(self, "incar_advanced_frame", None)
        template_pack = getattr(self, "_incar_template_pack_opts", {})
        advanced_pack = getattr(self, "_incar_advanced_pack_opts", {})

        if simple_box:
            title = "INCAR 关键旋钮（简单模式）" if mode_val == "newbie" else "INCAR 简单面板（与编辑器同步）"
            try:
                simple_box.configure(text=title)
            except Exception:
                pass
        if section_label:
            try:
                section_label.configure(
                    text="INCAR 简单面板" if mode_val == "newbie" else "INCAR 模板与编辑"
                )
            except Exception:
                pass

        if mode_val == "newbie":
            if template_bar and template_bar.winfo_manager():
                template_bar.pack_forget()
            if advanced_frame and advanced_frame.winfo_manager():
                advanced_frame.pack_forget()
        else:
            if template_bar and not template_bar.winfo_manager():
                template_bar.pack(**template_pack)
            if advanced_frame and not advanced_frame.winfo_manager():
                advanced_frame.pack(**advanced_pack)

    @staticmethod
    def _update_incar_text(text: str, updates: dict[str, Optional[str]]) -> str:
        normalized_updates: dict[str, str] = {}
        removals_exact: set[str] = set()
        for key, value in updates.items():
            if key is None:
                continue
            key_clean = key.upper().strip()
            key_norm = KEY_CORRECTIONS.get(key_clean, key_clean)
            if value is None or (isinstance(value, str) and value.strip() == ""):
                removals_exact.add(key_clean)
                continue
            normalized_updates[key_norm] = value
            if key_clean != key_norm:
                removals_exact.add(key_clean)

        lines = text.splitlines()
        new_lines: list[str] = []
        handled_keys: set[str] = set()

        for line in lines:
            stripped = line.strip()
            if not stripped or stripped.startswith("#") or stripped.startswith("!"):
                new_lines.append(line)
                continue
            m = re.match(r"^(\s*)([A-Za-z0-9_+-]+)\s*=\s*(.*)$", line)
            if not m:
                new_lines.append(line)
                continue
            lead, key_token, value_part = m.groups()
            key_clean = key_token.upper()
            key_norm = KEY_CORRECTIONS.get(key_clean, key_clean)
            comment = ""
            value_body = value_part
            for sep in ("!", "#"):
                idx = value_body.find(sep)
                if idx != -1:
                    comment = value_body[idx:].strip()
                    value_body = value_body[:idx]
                    break

            if key_clean in removals_exact:
                handled_keys.add(key_norm)
                continue

            if key_norm in normalized_updates:
                if key_norm in handled_keys:
                    continue
                new_val = normalized_updates[key_norm]
                line_out = f"{lead}{key_norm} = {new_val.strip()}"
                if comment:
                    if not line_out.endswith(" "):
                        line_out += " "
                    line_out += comment
                new_lines.append(line_out)
                handled_keys.add(key_norm)
            else:
                if key_norm in handled_keys:
                    continue
                new_lines.append(line)
                handled_keys.add(key_norm)

        for key, val in normalized_updates.items():
            if not val or key in handled_keys:
                continue
            new_lines.append(f"{key} = {val}")
            handled_keys.add(key)

        result = "\n".join(new_lines)
        if result and not result.endswith("\n"):
            result += "\n"
        return result

    def launch_first_time_wizard(self):
        profile = self.run_first_time_wizard()
        if profile:
            self.apply_profile_to_project(profile)

    def run_first_time_wizard(self) -> WizardProfile | None:
        dialog = FirstTimeWizard(self)
        self.wait_window(dialog)
        return getattr(dialog, "result", None)

    def apply_profile_to_project(self, profile: WizardProfile, project_path: Path | None = None) -> None:
        proj = self.current_project_path() if project_path is None else Path(project_path)
        try:
            proj = proj.expanduser()
        except Exception:
            proj = Path(proj)
        proj.mkdir(parents=True, exist_ok=True)
        self._ensure_project_scaffold(proj)

        smear_defaults = {"metal": (1, 0.2), "semiconductor": (0, 0.05), "insulator": (0, 0.05)}
        isme, sigma = smear_defaults.get(profile.system_type, (0, 0.05))
        encut_value = profile.encut_value or 520
        encut_comment = ""
        if profile.encut_strategy == "auto" and profile.encut_value is None:
            encut_comment = "# ENCUT ≈ 1.3×ENMAX_max，已使用默认值 520"

        incar_lines = [
            "# === Generated by wizard ===",
            f"# Workflow: {profile.workflow}",
        ]
        if encut_comment:
            incar_lines.append(encut_comment)
        incar_lines.extend([
            f"SYSTEM = {proj.name}",
            f"ENCUT = {encut_value}",
            "PREC  = Accurate",
            "EDIFF = 1e-6",
        ])
        if profile.workflow.startswith("relax"):
            incar_lines.extend(["IBRION = 2", "ISIF   = 3", "NSW    = 80"])
        else:
            incar_lines.extend(["IBRION = -1", "NSW    = 0"])
        incar_lines.extend([
            f"ISMEAR = {isme}",
            f"SIGMA  = {sigma}",
            "LREAL  = Auto",
            "LWAVE  = .FALSE.",
            "LCHARG = .TRUE.",
        ])

        if profile.k_mode == "kspacing":
            kspacing = profile.kspacing or 0.22
            incar_lines.append(f"KSPACING = {kspacing}")
            kpoints_text = (
                f"# 使用 KSPACING = {kspacing}\n"
                "# 若需 Monkhorst 网格请替换为标准 KPOINTS 文件\n"
            )
        else:
            grid = profile.kgrid or (6, 6, 6)
            kpoints_text = gen_kpoints_monkhorst(grid[0], grid[1], grid[2], True)

        write_text(proj / "INCAR", "\n".join(filter(None, incar_lines)) + "\n")
        if not (proj / "POSCAR").exists():
            write_text(proj / "POSCAR", DEFAULT_POSCAR_TEMPLATE)
        write_text(proj / "KPOINTS", kpoints_text)

        self.figure_style_var.set(profile.figure_style)
        self.emit_report_var.set(bool(profile.emit_report))
        try:
            self.mpi_np.set(int(profile.np))
        except Exception:
            pass

        self.run_mode.set("slurm" if profile.use_slurm else "local")
        slurm_cfg = profile.slurm or {}
        self.slurm_part.set(slurm_cfg.get("partition", self.slurm_part.get()))
        self.slurm_time.set(slurm_cfg.get("time", self.slurm_time.get()))
        try:
            self.slurm_nodes.set(int(slurm_cfg.get("nodes", self.slurm_nodes.get())))
        except Exception:
            pass
        try:
            ntasks = int(slurm_cfg.get("ntasks", profile.np))
            self.slurm_ntasks.set(ntasks)
        except Exception:
            pass
        self.slurm_account.set(slurm_cfg.get("account", self.slurm_account.get()))

        self.last_wizard_profile = profile
        self.set_project(proj)
        try:
            self.write_job_script()
        except Exception:
            pass
        try:
            self.save_config()
        except Exception:
            pass

    def create_example_project(self, name: str = "example_Si") -> Path:
        root = Path.home() / "vasp_gui_projects"
        root.mkdir(parents=True, exist_ok=True)
        candidate = root / name
        idx = 1
        while candidate.exists():
            candidate = root / f"{name}_{idx:02d}"
            idx += 1
        style = _normalize_style(self.figure_style_var.get())
        profile = WizardProfile(
            system_type="semiconductor",
            workflow="relax_scf_dos",
            encut_strategy="auto",
            encut_value=None,
            k_mode="kpoints",
            kspacing=None,
            kgrid=(6, 6, 6),
            use_slurm=False,
            np=max(1, self._int_from_var(self.mpi_np, 8)),
            slurm={},
            figure_style=style,
            emit_report=True,
        )
        self.apply_profile_to_project(profile, project_path=candidate)
        write_text(candidate / "POSCAR", EXAMPLE_SI_POSCAR)
        write_text(candidate / "INCAR", EXAMPLE_SI_INCAR)
        write_text(candidate / "KPOINTS", EXAMPLE_SI_KPOINTS)
        self.load_project_inputs()
        self._create_example_figures(candidate, style)
        return candidate

    def on_create_example_project(self):
        try:
            path = self.create_example_project()
        except Exception as exc:
            messagebox.showerror(APP_NAME, f"示例项目创建失败：{exc}")
            return
        messagebox.showinfo(APP_NAME, f"示例项目已创建：{path}")

    def _create_example_figures(self, proj: Path, style: str) -> None:
        fig_dir = proj / "figures"
        plots_dir = proj / "plots"
        fig_dir.mkdir(parents=True, exist_ok=True)
        plots_dir.mkdir(parents=True, exist_ok=True)

        energies = [i * 0.1 for i in range(-40, 41)]
        dos_vals = [max(0.0, 6.0 * math.exp(-((e) / 0.9) ** 2) - 0.15) for e in energies]
        fig = Figure(figsize=(4.0, 3.0), dpi=150)
        ax = fig.add_subplot(111)
        lw = FIG_STYLES.get(style, FIG_STYLES["AFM"]).get("linew", 1.2)
        ax.plot(energies, dos_vals, color="#1f77b4", linewidth=lw)
        ax.axvline(0.0, color="#444444", linestyle="--", linewidth=0.9)
        ax.set_xlabel("Energy (eV)")
        ax.set_ylabel("Total DOS (states/eV)")
        ax.set_title("Example DOS")
        apply_style(ax, style)
        fig.tight_layout()
        dos_png = fig_dir / "dos_demo.png"
        dos_svg = fig_dir / "dos_demo.svg"
        fig.savefig(dos_png, dpi=300)
        fig.savefig(dos_svg)
        with (fig_dir / "dos_demo.csv").open("w", encoding="utf-8") as f:
            f.write("energy_eV,total_dos\n")
            for e, d in zip(energies, dos_vals):
                f.write(f"{e:.3f},{d:.6f}\n")

        k_points = [i / 10 for i in range(11)]
        valence = [-0.5 + 0.25 * math.cos(math.pi * x) for x in k_points]
        conduction = [0.5 + 0.35 * math.cos(math.pi * x) for x in k_points]
        gap = min(conduction) - max(valence)
        fig2 = Figure(figsize=(4.0, 3.0), dpi=150)
        ax2 = fig2.add_subplot(111)
        ax2.plot(k_points, valence, color="#d62728", linewidth=lw)
        ax2.plot(k_points, conduction, color="#2ca02c", linewidth=lw)
        ax2.fill_between(k_points, valence, conduction, where=[c > v for c, v in zip(conduction, valence)], color="#cccccc", alpha=0.3)
        ax2.set_xlabel("k-path (arb.)")
        ax2.set_ylabel("Energy (eV)")
        ax2.set_title("Example Bands")
        ax2.text(0.02, 0.9, f"Gap ≈ {gap:.2f} eV", transform=ax2.transAxes)
        ax2.axhline(0.0, color="#444444", linestyle="--", linewidth=0.9)
        apply_style(ax2, style)
        fig2.tight_layout()
        band_png = fig_dir / "bands_demo.png"
        band_svg = fig_dir / "bands_demo.svg"
        fig2.savefig(band_png, dpi=300)
        fig2.savefig(band_svg)
        with (fig_dir / "bands_demo.csv").open("w", encoding="utf-8") as f:
            f.write("k_index,valence_eV,conduction_eV\n")
            for idx, (k, v, c) in enumerate(zip(k_points, valence, conduction)):
                f.write(f"{idx},{v:.6f},{c:.6f}\n")

        try:
            shutil.copyfile(dos_png, plots_dir / dos_png.name)
        except Exception:
            pass
        try:
            shutil.copyfile(band_png, plots_dir / band_png.name)
        except Exception:
            pass

        manifest = {"figures": [
            {"name": "dos_demo", "files": {"png": dos_png.name, "svg": dos_svg.name, "csv": "dos_demo.csv"}},
            {"name": "bands_demo", "files": {"png": band_png.name, "svg": band_svg.name, "csv": "bands_demo.csv"}},
        ]}
        atomic_write_text(fig_dir / "manifest.json", json.dumps(manifest, ensure_ascii=False, indent=2), encoding="utf-8")

    def _ensure_project_scaffold(self, proj: Path) -> None:
        for name in ("plots", "snapshots", "figures", "reports"):
            try:
                (proj / name).mkdir(parents=True, exist_ok=True)
            except Exception:
                pass

    def open_into_editor(self, name: str, editor: tk.Text):
        proj = self.current_project_path()
        candidate = proj / name
        path = None
        if candidate.exists():
            path = candidate
        else:
            p = filedialog.askopenfilename(
                initialdir=self.project_dir,
                title=f"打开 {name}",
                filetypes=[(name, name), ("全部", "*")],
            )
            if not p:
                return
            path = Path(p)
        if path is None:
            path = candidate
        try:
            s = read_text(path)
            editor.delete("1.0", tk.END)
            editor.insert("1.0", s)
            if editor is getattr(self, "incar_text", None):
                self.refresh_incar_simple_panel()
        except Exception as e:
            messagebox.showerror(APP_NAME, f"读取失败：{e}")

    def save_from_editor(self, name: str, editor: tk.Text):
        proj = self.current_project_path()
        proj.mkdir(parents=True, exist_ok=True)
        p = proj / name
        try:
            write_text(p, editor.get("1.0", tk.END))
            messagebox.showinfo(APP_NAME, f"已保存 {name} -> {p}")
            self.refresh_project_overview()
        except Exception as e:
            messagebox.showerror(APP_NAME, f"保存失败：{e}")

    def show_poscar_elements(self):
        s = self.poscar_text.get("1.0", tk.END)
        elems = unique_elements_from_poscar(s)
        if elems:
            messagebox.showinfo(APP_NAME, f"POSCAR 元素：{', '.join(elems)}")
        else:
            messagebox.showwarning(APP_NAME, "未解析到元素，请检查第6/7行。")

    # ------------------------- 页面：POTCAR --------------------------------
    def _populate_potcar_section(self, container):
        row1 = ttk.Frame(container)
        row1.pack(fill=tk.X, padx=8, pady=8)
        ttk.Label(row1, text="赝势库根目录：").pack(side=tk.LEFT)
        self.pot_dir_var = tk.StringVar(value=str(Path.home() / "potcars"))
        ttk.Entry(row1, textvariable=self.pot_dir_var, width=80).pack(side=tk.LEFT, padx=6)
        ttk.Button(row1, text="选择…", command=self.choose_pot_dir).pack(side=tk.LEFT)
        ttk.Button(row1, text="探测赝势库", command=self.detect_pot_roots).pack(side=tk.LEFT, padx=6)

        row2 = ttk.Frame(container)
        row2.pack(fill=tk.X, padx=8, pady=4)
        ttk.Label(row2, text="从 POSCAR 自动解析元素并生成 POTCAR：").pack(side=tk.LEFT)
        ttk.Button(row2, text="生成 POTCAR", command=self.do_build_potcar).pack(side=tk.LEFT, padx=8)

        self.pot_msg = ScrolledText(container, height=12, wrap="word")
        self.pot_msg.pack(fill=tk.BOTH, expand=True, padx=8, pady=8)

        return container

    def _build_potcar_page(self, parent):
        frame = ttk.Frame(parent)
        self._populate_potcar_section(frame)
        return frame

    def choose_pot_dir(self):
        d = filedialog.askdirectory(initialdir=self.pot_dir_var.get(), title="选择赝势库根目录")
        if d:
            self.pot_dir_var.set(d)

    def do_build_potcar(self):
        proj = self.current_project_path()
        pos = proj / "POSCAR"
        if not pos.exists():
            # 尝试从编辑器
            s = self.poscar_text.get("1.0", tk.END).strip()
            if s:
                write_text(pos, s)
            else:
                messagebox.showwarning(APP_NAME, "项目目录中不存在 POSCAR，且编辑器为空。")
                return
        elems, _ = parse_poscar(read_text(pos))
        if not elems:
            messagebox.showwarning(APP_NAME, "未从 POSCAR 解析到元素。")
            return
        pot_base = Path(self.pot_dir_var.get())
        selections: list[Path] = []
        for e in elems:
            cands = find_potcar_candidates(e, pot_base)
            if not cands:
                msg = f"未找到元素 {e} 的 POTCAR（在 {pot_base} 下）。"
                self.pot_msg.insert(tk.END, msg + "\n")
                messagebox.showerror(APP_NAME, msg)
                return
            if len(cands) == 1:
                selected = cands[0]
            else:
                options = [str(p) for p in cands]
                sel = self.select_from_list(f"选择 {e} 的 POTCAR", options)
                if not sel:
                    cancel_msg = f"已取消 {e} 的 POTCAR 选择，终止生成。"
                    self.pot_msg.insert(tk.END, cancel_msg + "\n")
                    messagebox.showinfo(APP_NAME, cancel_msg)
                    return
                selected = Path(sel)
            selections.append(selected)
            self.pot_msg.insert(tk.END, f"{e}: 使用 {selected}\n")
            self.pot_msg.see(tk.END)
        ok, msg = build_potcar(selections, proj / "POTCAR")
        self.pot_msg.insert(tk.END, (msg + "\n"))
        self.pot_msg.see(tk.END)
        if not ok:
            messagebox.showerror(APP_NAME, msg)
        else:
            messagebox.showinfo(APP_NAME, msg)
            self.refresh_project_overview()

    # --------- 赝势库探测与选择 ---------
    def detect_pot_roots(self):
        cands = self.scan_pot_roots(limit=30)
        if not cands:
            messagebox.showwarning(APP_NAME, "未在常见位置发现赝势库候选。你也可以手动选择根目录。")
            return
        if len(cands) == 1:
            self.pot_dir_var.set(cands[0])
            messagebox.showinfo(APP_NAME, f"已设置赝势库根目录：\n{cands[0]}")
            return
        sel = self.select_from_list("选择赝势库根目录", cands)
        if sel:
            self.pot_dir_var.set(sel)

    def select_from_list(self, title, items):
        top = tk.Toplevel(self)
        top.title(title)
        top.geometry("720x380")
        try:
            top.update_idletasks()
            top.wm_minsize(640, 320)
        except Exception:
            pass
        lb = tk.Listbox(top, selectmode=tk.SINGLE)
        for it in items:
            lb.insert(tk.END, it)
        lb.pack(fill=tk.BOTH, expand=True, padx=8, pady=8)
        sel = {"val": None}
        def ok():
            try:
                i = lb.curselection()
                sel["val"] = items[i[0]] if i else None
            except Exception:
                sel["val"] = None
            top.destroy()
        ttk.Button(top, text="使用选中", command=ok).pack(pady=6)
        top.transient(self); top.grab_set(); self.wait_window(top)
        return sel["val"]

    def scan_pot_roots(self, limit=20):
        bases = []
        # 当前设置与常见路径为起点
        try:
            bases.append(Path(self.pot_dir_var.get()).expanduser())
        except Exception:
            pass
        for p in [Path.home()/"potcars", Path.home()/"vasp", Path.home()/"apps", Path.home()/"Downloads", Path.home()/"下载", Path("/opt/vasp"), Path("/usr/local/share/vasp"), Path("/mnt/c/Users")]:
            if p.exists():
                bases.append(p)
        seen = set(); cands = []
        def looks_like_root(d: Path):
            try:
                cnt = 0
                for child in d.iterdir():
                    if child.is_dir() and (child/"POTCAR").exists():
                        cnt += 1
                        if cnt >= 3:
                            return True
                return False
            except Exception:
                return False
        # BFS 限深 3
        from collections import deque
        for base in list(dict.fromkeys(bases)):
            if not base.exists():
                continue
            q = deque([(base, 0)])
            while q and len(cands) < limit:
                cur, dep = q.popleft()
                try:
                    key = str(cur.resolve())
                except Exception:
                    key = str(cur)
                if key in seen:
                    continue
                seen.add(key)
                if looks_like_root(cur):
                    cands.append(key)
                if dep < 3:
                    try:
                        for ch in cur.iterdir():
                            if ch.is_dir():
                                q.append((ch, dep+1))
                    except Exception:
                        pass
        # 去重与排序（包含关键词的优先）
        def score(path):
            name = path.lower(); s = 0
            for kw in ("potpaw","paw","pbe","lda","potential","psp"):
                if kw in name:
                    s += 1
            return (-s, len(path))
        cands = sorted(list(dict.fromkeys(cands)), key=score)
        return cands[:limit]

    # ------------------------- 页面：KPOINTS -------------------------------
    def _populate_kpoints_section(self, container):
        box = ttk.LabelFrame(container, text="Monkhorst-Pack 网格")
        box.pack(fill=tk.X, padx=8, pady=8)

        self.k_nx = tk.IntVar(value=5)
        self.k_ny = tk.IntVar(value=5)
        self.k_nz = tk.IntVar(value=5)
        self.k_gamma = tk.BooleanVar(value=True)

        row = ttk.Frame(box)
        row.pack(fill=tk.X, pady=4)
        ttk.Label(row, text="Nx").pack(side=tk.LEFT)
        ttk.Spinbox(row, from_=1, to=50, textvariable=self.k_nx, width=5).pack(side=tk.LEFT, padx=6)
        ttk.Label(row, text="Ny").pack(side=tk.LEFT)
        ttk.Spinbox(row, from_=1, to=50, textvariable=self.k_ny, width=5).pack(side=tk.LEFT, padx=6)
        ttk.Label(row, text="Nz").pack(side=tk.LEFT)
        ttk.Spinbox(row, from_=1, to=50, textvariable=self.k_nz, width=5).pack(side=tk.LEFT, padx=6)
        ttk.Checkbutton(box, text="Gamma 中心网格 (Gamma-centered)", variable=self.k_gamma).pack(anchor=tk.W, padx=8)

        btns = ttk.Frame(container)
        btns.pack(fill=tk.X, padx=8, pady=4)
        ttk.Button(btns, text="生成到编辑器", command=self.kpoints_to_editor).pack(side=tk.LEFT)
        ttk.Button(btns, text="保存到项目(KPOINTS)", command=self.kpoints_save).pack(side=tk.LEFT, padx=8)

        tip = ttk.Label(container, text="提示：也可在 INCAR 使用 KSPACING，省去 KPOINTS（VASP 5.4.4+）")
        tip.pack(anchor=tk.W, padx=12, pady=4)

        return container

    def _build_kpoints_page(self, parent):
        frame = ttk.Frame(parent)
        self._populate_kpoints_section(frame)
        return frame

    # === CODEX BEGIN: twist/shift helpers ===
    def _show_help_dialog(self, title: str, message: str) -> None:
        """弹出一个带滚动文本的帮助对话框。"""
        dialog = tk.Toplevel(self)
        dialog.title(title)
        dialog.transient(self)
        dialog.resizable(True, True)
        dialog.grab_set()

        frame = ttk.Frame(dialog, padding=12)
        frame.pack(fill=tk.BOTH, expand=True)

        text = ScrolledText(frame, wrap=tk.WORD, width=68, height=20)
        text.insert(tk.END, message)
        text.configure(state=tk.DISABLED)
        text.pack(fill=tk.BOTH, expand=True)

        btn_row = ttk.Frame(frame)
        btn_row.pack(fill=tk.X, pady=(12, 0))
        ttk.Button(btn_row, text="关闭", command=dialog.destroy).pack(side=tk.RIGHT)

        dialog.update_idletasks()
        try:
            self.update_idletasks()
            w = dialog.winfo_width()
            h = dialog.winfo_height()
            x = self.winfo_rootx() + (self.winfo_width() - w) // 2
            y = self.winfo_rooty() + (self.winfo_height() - h) // 2
            dialog.geometry(f"+{max(x, 0)}+{max(y, 0)}")
        except Exception:
            pass
        dialog.bind("<Escape>", lambda _e: dialog.destroy())

    def _add_help_button(self, parent, title: str, message: str) -> ttk.Button:
        btn = ttk.Button(parent, text="？", width=2,
                         command=lambda: self._show_help_dialog(title, message))
        btn.pack(side=tk.RIGHT, padx=(4, 0))
        return btn

    def _add_section_heading(self, parent, caption: str, help_text: str,
                              *, title: Optional[str] = None, pady=(8, 4)) -> ttk.Frame:
        row = ttk.Frame(parent)
        row.pack(fill=tk.X, pady=pady)
        ttk.Label(row, text=caption, font=("TkDefaultFont", 10, "bold")).pack(side=tk.LEFT)
        self._add_help_button(row, title or caption, help_text)
        return row

    def _tw_detect_structure_context(self) -> dict[str, Any]:
        context: dict[str, Any] = {
            "is_slab": False,
            "vacuum": None,
            "c_length": None,
            "elements": [],
            "source": None,
        }
        candidates: list[tuple[str, Path]] = []
        for attr in ("tw_top_path", "tw_bot_path"):
            var = getattr(self, attr, None)
            if isinstance(var, tk.StringVar):
                try:
                    p = Path(var.get())
                except Exception:
                    continue
                if p.exists():
                    candidates.append((attr, p))
        proj_poscar = self.current_project_path() / "POSCAR"
        if not candidates and proj_poscar.exists():
            candidates.append(("project", proj_poscar))

        poscar_text = ""
        source_label: Optional[str] = None
        for tag, path in candidates:
            try:
                poscar_text = read_text(path)
                source_label = str(path)
                break
            except Exception:
                continue
        if not poscar_text and getattr(self, "poscar_text", None) is not None:
            try:
                poscar_text = self.poscar_text.get("1.0", tk.END)
                source_label = "编辑器中的 POSCAR"
            except Exception:
                poscar_text = ""

        if poscar_text.strip():
            elems, _ = parse_poscar(poscar_text)
            if elems:
                context["elements"] = elems
        if source_label:
            context["source"] = source_label

        if HAS_PYMATGEN and poscar_text.strip():
            try:
                from pymatgen.core import Structure  # type: ignore

                if source_label and isinstance(source_label, str) and Path(source_label).exists():
                    structure = Structure.from_file(source_label)
                else:
                    structure = Structure.from_str(poscar_text, fmt="poscar")
                c_len = float(structure.lattice.c)
                context["c_length"] = c_len
                cart_z = [structure.lattice.get_cartesian_coords(site.frac_coords)[2] for site in structure]
                if cart_z:
                    z_span = max(cart_z) - min(cart_z)
                    vacuum = max(c_len - z_span, 0.0)
                    context["vacuum"] = vacuum
                is_low_dim = False
                try:
                    if hasattr(structure, "is_low_dimensional") and structure.is_low_dimensional(2):
                        is_low_dim = True
                except Exception:
                    is_low_dim = False
                if not is_low_dim:
                    vac = context.get("vacuum")
                    if vac is not None and c_len:
                        is_low_dim = vac > 6.0 and c_len > 15.0
                context["is_slab"] = bool(is_low_dim)
            except Exception:
                pass

        if context.get("is_slab") and context.get("vacuum") is not None:
            vac = float(context["vacuum"])
            c_len = float(context.get("c_length") or 0.0)
            context["reason"] = (
                f"检测到 c≈{c_len:.1f} Å，真空≈{vac:.1f} Å → 判定为 2D/薄膜体系。"
            )
        elif context.get("c_length"):
            c_len = float(context["c_length"])
            context["reason"] = (
                f"晶胞 c 轴≈{c_len:.1f} Å，未检测到明显真空层，将采用通用默认。"
            )
        else:
            context["reason"] = "未检测到 POSCAR，沿用通用默认。"
        return context

    def _tw_collect_history_defaults(self) -> dict[str, tuple[Any, str]]:
        history: dict[str, tuple[Any, str]] = {}

        def _set_once(key: str, value: Any, origin: str) -> None:
            if value is None:
                return
            if key not in history:
                history[key] = (value, origin)

        proj = self.current_project_path()
        incar_path = proj / "INCAR"
        incar_text = ""
        if incar_path.exists():
            try:
                incar_text = read_text(incar_path)
            except Exception:
                incar_text = ""
        elif getattr(self, "incar_text", None) is not None:
            try:
                incar_text = self.incar_text.get("1.0", tk.END)
            except Exception:
                incar_text = ""
        if incar_text.strip():
            incar_map, _typos = self._parse_incar_map(incar_text)
            for key in ("KSPACING", "ISMEAR", "SIGMA", "LDIPOL", "IDIPOL", "ENCUT", "KGAMMA"):
                if key in incar_map:
                    val = incar_map[key]
                    if key == "KGAMMA":
                        val = str(val).strip().upper() in {"T", ".TRUE.", "TRUE", "1"}
                        key_norm = "gamma_center"
                    else:
                        key_norm = key if key not in {"KSPACING"} else "kspacing"
                    _set_once(key_norm, val, "项目 INCAR")

        meta_candidates: list[Path] = []
        root_meta = proj / "meta.json"
        if root_meta.exists():
            meta_candidates.append(root_meta)
        sweep_root = proj / "twist_sweep"
        if sweep_root.exists():
            try:
                meta_candidates.extend(
                    sorted(
                        (p for p in sweep_root.glob("*/meta.json") if p.is_file()),
                        key=lambda x: x.stat().st_mtime,
                        reverse=True,
                    )
                )
            except Exception:
                pass
        for meta_path in meta_candidates:
            try:
                data = json.loads(read_text(meta_path))
            except Exception:
                continue
            label = "项目 meta.json" if meta_path == root_meta else f"{meta_path.parent.name}/meta.json"
            for key, alias in (
                ("vacuum", "vacuum"),
                ("interlayer", "interlayer"),
                ("allow_strain", "allow_strain"),
                ("kspacing", "kspacing"),
                ("ismear", "ISMEAR"),
                ("sigma", "SIGMA"),
                ("ldipol", "LDIPOL"),
                ("idipol", "IDIPOL"),
                ("gamma_center", "gamma_center"),
                ("gamma_only", "force_gamma_only"),
            ):
                val = data.get(key)
                if val is None:
                    continue
                if key in {"ldipol", "gamma_center", "gamma_only"}:
                    if isinstance(val, str):
                        val = val.strip().upper() in {"T", ".TRUE.", "TRUE", "1"}
                    else:
                        val = bool(val)
                _set_once(alias, val, label)

        kpoints_path = proj / "KPOINTS"
        if kpoints_path.exists():
            _set_once("kpoints_file", str(kpoints_path), "项目 KPOINTS")

        return history

    def _tw_guess_template_key(self, context: dict[str, Any]) -> str:
        elems = {str(e).capitalize() for e in context.get("elements", [])}
        if elems and elems.issubset({"C", "B", "N"}):
            return "graphene_bn"
        tmd_metals = {"Mo", "W"}
        chalcogens = {"S", "Se", "Te"}
        if elems and elems & tmd_metals and elems & chalcogens:
            return "mos2_tmd"
        return "hetero_moire"

    def _tw_resolve_recommended_config(self) -> dict[str, Any]:
        context = self._tw_detect_structure_context()
        history = self._tw_collect_history_defaults()

        template_choice_label = "auto"
        if hasattr(self, "tw_template_var") and isinstance(self.tw_template_var, tk.StringVar):
            template_choice_label = self.tw_template_var.get() or "auto"
        choice_map = getattr(self, "_tw_template_choice_map", {})
        template_key = choice_map.get(template_choice_label, template_choice_label)
        if hasattr(self, "_tw_selected_template"):
            template_key = getattr(self, "_tw_selected_template") or template_key
        if template_key in {"auto", ""}:
            template_key = self._tw_guess_template_key(context)
        template = TW_TEMPLATE_LIBRARY.get(template_key)

        sources_chain: list[str] = []
        values: dict[str, Any] = {}
        origins: dict[str, str] = {}

        def _set_value(key: str, value: Any, origin: str) -> None:
            if value is None or key in values:
                return
            values[key] = value
            origins[key] = origin

        if history:
            sources_chain.append("项目历史")
            for key in (
                "vacuum",
                "interlayer",
                "allow_strain",
                "kspacing",
                "ISMEAR",
                "SIGMA",
                "LDIPOL",
                "IDIPOL",
                "ENCUT",
                "gamma_center",
                "force_gamma_only",
            ):
                if key in history:
                    val, origin = history[key]
                    if key == "kspacing":
                        try:
                            val = float(val)
                        except Exception:
                            pass
                    if key in {"vacuum", "interlayer", "allow_strain"}:
                        try:
                            val = float(val)
                        except Exception:
                            pass
                    _set_value(key, val, origin)

        if template:
            sources_chain.append(f"材料模板：{template['label']}")
            _set_value("vacuum", template.get("vacuum"), template["label"])
            _set_value("interlayer", template.get("interlayer"), template["label"])
            _set_value("allow_strain", template.get("allow_strain"), template["label"])
            _set_value("kspacing", template.get("kspacing"), template["label"])
            _set_value("gamma_center", template.get("gamma_center"), template["label"])
            _set_value("force_gamma_only", template.get("force_gamma_only"), template["label"])
            for key, val in template.get("incar", {}).items():
                _set_value(key.upper(), val, template["label"])

        sources_chain.append("通用默认")
        for key, val in TW_FALLBACK_DEFAULTS.items():
            _set_value(key, val, "通用默认")

        incar_patch: dict[str, str] = {}
        if "kspacing" in values and not values.get("force_gamma_only"):
            try:
                incar_patch["KSPACING"] = f"{float(values['kspacing']):.3f}"
            except Exception:
                incar_patch["KSPACING"] = str(values["kspacing"])
        for key in ("ISMEAR", "SIGMA", "LDIPOL", "IDIPOL", "ENCUT"):
            if key in values:
                incar_patch[key] = str(values[key])
        if values.get("gamma_center") is not None:
            incar_patch["KGAMMA"] = ".TRUE." if bool(values["gamma_center"]) else ".FALSE."

        summary = "来源：" + " → ".join(sources_chain)
        reason = context.get("reason", "")
        if template_choice_label in {"auto", "自动推荐（根据结构推断）"} and template:
            reason = f"自动推荐模板：{template['label']}。" + reason

        return {
            "context": context,
            "history": history,
            "template_key": template_key,
            "template_choice": template_choice_label,
            "template": template,
            "values": values,
            "origins": origins,
            "sources_chain": sources_chain,
            "summary": summary,
            "reason": reason,
            "incar_patch": incar_patch,
        }

    def _tw_update_config_summary(self, *, apply_initial: bool = False) -> None:
        info = self._tw_resolve_recommended_config()
        self._tw_config_cache = info

        summary = info.get("summary", "来源：通用默认")
        reason = info.get("reason", "")
        if hasattr(self, "tw_config_summary_var"):
            self.tw_config_summary_var.set(summary)
        if hasattr(self, "tw_config_reason_var"):
            self.tw_config_reason_var.set(reason)

        template = info.get("template")
        if hasattr(self, "tw_template_desc_var"):
            if info.get("template_choice") in {"auto", "自动推荐（根据结构推断）"} and template:
                self.tw_template_desc_var.set(
                    f"自动推荐：{template['label']} — {template.get('summary', '')}"
                )
            elif template:
                self.tw_template_desc_var.set(template.get("summary", ""))
            else:
                self.tw_template_desc_var.set("使用通用默认参数，可根据体系自行调整。")

        if hasattr(self, "tw_apply_source_var"):
            chain = info.get("sources_chain", [])
            self.tw_apply_source_var.set("来源：" + " / ".join(chain))

        tree = getattr(self, "tw_config_tree", None)
        if tree is not None:
            try:
                tree.delete(*tree.get_children())
            except Exception:
                pass
            display_order = [
                ("vacuum", "真空 (Å)", lambda v: f"{float(v):.1f}"),
                ("interlayer", "层间距 (Å)", lambda v: f"{float(v):.2f}"),
                ("allow_strain", "容许面内等比例应变(%)", lambda v: f"{float(v):.2f}"),
                ("kspacing", "KSPACING (Å⁻¹)", lambda v: f"{float(v):.3f}"),
                ("ISMEAR", "ISMEAR", str),
                ("SIGMA", "SIGMA", str),
                ("LDIPOL", "LDIPOL", str),
                ("IDIPOL", "IDIPOL", str),
                ("ENCUT", "ENCUT", str),
                ("gamma_center", "Gamma 中心网格", lambda v: "是" if bool(v) else "否"),
                ("force_gamma_only", "仅 Γ 点 (Γ-only)", lambda v: "是" if bool(v) else "否"),
            ]
            for key, label, fmt in display_order:
                if key not in info["values"]:
                    continue
                val = info["values"][key]
                try:
                    disp = fmt(val)
                except Exception:
                    disp = str(val)
                origin = info["origins"].get(key, "通用默认")
                tree.insert("", tk.END, values=(label, disp, origin))

        if apply_initial and not getattr(self, "_tw_defaults_applied", False):
            mapping = [
                ("vacuum", "tw_vacuum", float),
                ("interlayer", "tw_interlayer", float),
                ("allow_strain", "tw_allow_strain", float),
                ("kspacing", "tw_kspacing", float),
                ("gamma_center", "tw_gamma_center", bool),
                ("force_gamma_only", "tw_force_gamma_only", bool),
            ]
            self._tw_setting_defaults = True
            try:
                for key, attr, caster in mapping:
                    if key not in info["values"] or not hasattr(self, attr):
                        continue
                    var = getattr(self, attr)
                    try:
                        val = caster(info["values"][key])
                    except Exception:
                        val = info["values"][key]
                    try:
                        var.set(val)
                    except Exception:
                        pass
            finally:
                self._tw_setting_defaults = False
                self._tw_defaults_applied = True

        self._tw_update_task_summary()

    def _tw_apply_recommended_config(self) -> None:
        info = getattr(self, "_tw_config_cache", None) or self._tw_resolve_recommended_config()
        values: dict[str, Any] = info.get("values", {})
        incar_patch: dict[str, str] = info.get("incar_patch", {})

        current_text = ""
        incar_path = self.current_project_path() / "INCAR"
        if incar_path.exists():
            try:
                current_text = read_text(incar_path)
            except Exception:
                current_text = ""
        elif getattr(self, "incar_text", None) is not None:
            try:
                current_text = self.incar_text.get("1.0", tk.END)
            except Exception:
                current_text = ""
        current_map, _ = self._parse_incar_map(current_text)

        incar_changes: list[str] = []
        patch_final: dict[str, Optional[str]] = {}
        for key, new_val in incar_patch.items():
            old_val = current_map.get(key)
            if str(old_val).strip() == str(new_val).strip():
                continue
            incar_changes.append(f"{key}: {old_val or '未设置'} → {new_val}")
            patch_final[key] = new_val

        local_changes: list[str] = []
        local_mapping = [
            ("vacuum", "tw_vacuum"),
            ("interlayer", "tw_interlayer"),
            ("allow_strain", "tw_allow_strain"),
            ("kspacing", "tw_kspacing"),
            ("gamma_center", "tw_gamma_center"),
            ("force_gamma_only", "tw_force_gamma_only"),
        ]
        for key, attr in local_mapping:
            if key not in values or not hasattr(self, attr):
                continue
            var = getattr(self, attr)
            try:
                current = var.get()
            except Exception:
                current = None
            target = values[key]
            if isinstance(var, tk.BooleanVar):
                current = bool(current)
                target_bool = bool(target)
                if current != target_bool:
                    local_changes.append(f"{attr[3:]}: {current} → {target_bool}")
            else:
                try:
                    current_val = float(current)
                    target_val = float(target)
                except Exception:
                    current_val = current
                    target_val = target
                if current_val != target_val:
                    local_changes.append(f"{attr[3:]}: {current_val} → {target_val}")

        if not incar_changes and not local_changes:
            messagebox.showinfo(APP_NAME, "当前参数已与推荐值一致，无需改动。")
            return

        lines = []
        if incar_changes:
            lines.append("INCAR 将更新：\n - " + "\n - ".join(incar_changes))
        if local_changes:
            lines.append("界面参数将更新：\n - " + "\n - ".join(local_changes))
        msg = "\n\n".join(lines)
        if not messagebox.askyesno(APP_NAME, f"确认应用推荐参数？\n\n{msg}"):
            return

        if patch_final:
            self._apply_incar_patch(patch_final, message="[twist] 已应用推荐 INCAR 参数")

        self._tw_setting_defaults = True
        try:
            for key, attr in local_mapping:
                if key not in values or not hasattr(self, attr):
                    continue
                var = getattr(self, attr)
                try:
                    var.set(values[key])
                except Exception:
                    pass
        finally:
            self._tw_setting_defaults = False

        self._tw_update_config_summary()
        self._tw_append_log("已应用二维材料推荐参数。")

    def _tw_update_task_summary(self, *_args) -> None:
        if getattr(self, "_tw_setting_defaults", False):
            return
        summary_var = getattr(self, "tw_task_summary_var", None)
        rule_var = getattr(self, "tw_task_rule_var", None)
        if summary_var is None:
            return
        try:
            theta_a = float(self.tw_theta_a.get())
            theta_b = float(self.tw_theta_b.get())
            theta_step = float(self.tw_theta_step.get())
        except Exception:
            summary_var.set("角度范围无效")
            return
        twist_enabled = bool(getattr(self, "tw_enable_twist", tk.BooleanVar(value=True)).get())
        slide_enabled = bool(getattr(self, "tw_enable_slide", tk.BooleanVar(value=True)).get())
        try:
            ux_steps = int(self.tw_ux_steps.get())
            uy_steps = int(self.tw_uy_steps.get())
        except Exception:
            summary_var.set("滑移网格无效")
            return
        try:
            max_tasks = int(self.tw_max_tasks.get())
        except Exception:
            max_tasks = 0
        if twist_enabled:
            thetas = self._tw_linspace(theta_a, theta_b, theta_step if theta_step else 1.0)
        else:
            thetas = [theta_a]
        n_theta = len(thetas)
        n_ux = ux_steps if slide_enabled else 1
        n_uy = uy_steps if slide_enabled else 1
        total = n_theta * n_ux * n_uy
        text = f"Nθ={n_theta} × Nₓ={n_ux} × Nᵧ={n_uy} = {total} 个任务"
        try:
            gamma_forced = bool(self.tw_force_gamma_only.get())
        except Exception:
            gamma_forced = False
        if gamma_forced:
            text += "（已手动仅 Γ 点）"
        if max_tasks > 0 and total > max_tasks:
            text += f"  ⚠️ 超出上限 {max_tasks}"
            if hasattr(self, "tw_task_summary_label"):
                self.tw_task_summary_label.configure(foreground="#b35c00")
        else:
            if max_tasks > 0:
                text += f"（上限 {max_tasks}）"
            if hasattr(self, "tw_task_summary_label"):
                self.tw_task_summary_label.configure(foreground="#1a1a1a")
        summary_var.set(text)

        if rule_var is not None and hasattr(self, "tw_gamma_atom_threshold"):
            try:
                threshold = int(self.tw_gamma_atom_threshold.get())
            except Exception:
                threshold = 500
            if gamma_forced:
                rule_var.set(
                    f"规则：已强制仅 Γ 点；预计原子数超过 ~{threshold} × 2 层时也会记录自动触发条件。"
                )
            else:
                rule_var.set(
                    f"规则：预计原子数超过 ~{threshold} × 2 层时自动切换仅 Γ 点。"
                )

    def _tw_on_template_change(self, *_args) -> None:
        choice_label = "auto"
        if hasattr(self, "tw_template_var") and isinstance(self.tw_template_var, tk.StringVar):
            try:
                choice_label = self.tw_template_var.get() or "auto"
            except Exception:
                choice_label = "auto"
        choice_map = getattr(self, "_tw_template_choice_map", {})
        self._tw_selected_template = choice_map.get(choice_label, choice_label)
        self._tw_update_config_summary()

    def _tw_on_structure_change(self, *_args) -> None:
        self._tw_update_config_summary()
        self._update_tw_entry_banner()

    def _update_tw_entry_banner(self) -> None:
        frame = getattr(self, "tw_banner_frame", None)
        if frame is None:
            return
        info = self._tw_detect_structure_context()
        is_slab = bool(info.get("is_slab"))
        if is_slab:
            c_len = info.get("c_length")
            vacuum = info.get("vacuum")
            parts = ["检测到 2D/薄膜结构"]
            if c_len:
                parts.append(f"c≈{float(c_len):.1f} Å")
            if vacuum:
                parts.append(f"真空≈{float(vacuum):.1f} Å")
            message = "，".join(parts) + "，是否进入『二维材料扫描』？"
            self.tw_banner_var.set(message)
            if not getattr(self, "_tw_banner_visible", False):
                try:
                    frame.pack(fill=tk.X, padx=8, pady=(4, 0))
                except Exception:
                    pass
                self._tw_banner_visible = True
        else:
            if getattr(self, "_tw_banner_visible", False):
                try:
                    frame.pack_forget()
                except Exception:
                    pass
                self._tw_banner_visible = False

    def _tw_launch_wizard(self) -> None:
        """四步式向导：统一引导二维材料扫描默认。"""
        existing = getattr(self, "_tw_wizard", None)
        if existing is not None:
            try:
                if existing.winfo_exists():
                    existing.lift()
                    existing.focus_set()
                    return
            except Exception:
                self._tw_wizard = None

        context = self._tw_detect_structure_context()

        def _get_float(name: str, default: float) -> float:
            var = getattr(self, name, None)
            if var is None:
                return default
            try:
                return float(var.get())
            except Exception:
                return default

        def _get_int(name: str, default: int) -> int:
            var = getattr(self, name, None)
            if var is None:
                return default
            try:
                return int(var.get())
            except Exception:
                return default

        try:
            top_default = self.tw_top_path.get()
        except Exception:
            top_default = ""
        try:
            bot_default = self.tw_bot_path.get()
        except Exception:
            bot_default = ""
        proj_poscar = self.current_project_path() / "POSCAR"
        if not top_default and proj_poscar.exists():
            top_default = str(proj_poscar)
        if not bot_default and proj_poscar.exists():
            bot_default = str(proj_poscar)
        if not bot_default:
            bot_default = top_default

        template_labels = list(getattr(self, "_tw_template_choice_map", {}).keys())
        if not template_labels:
            template_labels = ["自动推荐（根据结构推断）"]
        try:
            template_default = self.tw_template_var.get()
            if template_default not in template_labels:
                raise ValueError
        except Exception:
            template_default = template_labels[0]

        theta_a_default = _get_float("tw_theta_a", 0.0)
        theta_b_default = _get_float("tw_theta_b", 5.0)
        theta_step_default = max(_get_float("tw_theta_step", 1.0), 1e-3)
        ux_steps_default = max(_get_int("tw_ux_steps", 5), 1)
        uy_steps_default = max(_get_int("tw_uy_steps", 5), 1)
        max_tasks_default = max(_get_int("tw_max_tasks", 0), 0)

        top = tk.Toplevel(self)
        top.title("二维材料扫描快速向导")
        top.transient(self)
        top.grab_set()
        self._tw_wizard = top

        body = ttk.Frame(top, padding=12)
        body.pack(fill=tk.BOTH, expand=True)

        wizard_top_var = tk.StringVar(value=top_default)
        wizard_bot_var = tk.StringVar(value=bot_default)
        wizard_template_var = tk.StringVar(value=template_default)
        wizard_theta_a = tk.DoubleVar(value=theta_a_default)
        wizard_theta_b = tk.DoubleVar(value=theta_b_default)
        wizard_theta_step = tk.DoubleVar(value=theta_step_default)
        wizard_ux_steps = tk.IntVar(value=ux_steps_default)
        wizard_uy_steps = tk.IntVar(value=uy_steps_default)

        step_frames: list[ttk.Frame] = []
        context_reason = context.get("reason", "") or "未检测到 POSCAR，沿用通用默认。"
        context_source = context.get("source")

        step1 = ttk.Frame(body)
        step_frames.append(step1)
        ttk.Label(step1, text="步骤 1/4：选择上下层结构 (POSCAR)", font=("TkDefaultFont", 10, "bold")).pack(anchor=tk.W)
        if context_source:
            ttk.Label(
                step1,
                text=f"识别到结构来源：{context_source}",
                foreground="#555",
                wraplength=420,
                justify=tk.LEFT,
            ).pack(anchor=tk.W, pady=(2, 6))

        def _browse(var: tk.StringVar) -> None:
            p = filedialog.askopenfilename(
                title="选择 POSCAR",
                filetypes=[("POSCAR", "POSCAR"), ("All", "*")],
                initialdir=self.project_dir,
            )
            if p:
                var.set(p)

        row_top = ttk.Frame(step1)
        row_top.pack(fill=tk.X, pady=4)
        ttk.Label(row_top, text="上层 (T)").pack(side=tk.LEFT)
        ttk.Entry(row_top, textvariable=wizard_top_var, width=50).pack(side=tk.LEFT, padx=4, fill=tk.X, expand=True)
        ttk.Button(row_top, text="浏览…", command=lambda: _browse(wizard_top_var)).pack(side=tk.LEFT)

        row_bot = ttk.Frame(step1)
        row_bot.pack(fill=tk.X, pady=4)
        ttk.Label(row_bot, text="下层 (B)").pack(side=tk.LEFT)
        ttk.Entry(row_bot, textvariable=wizard_bot_var, width=50).pack(side=tk.LEFT, padx=4, fill=tk.X, expand=True)
        ttk.Button(row_bot, text="浏览…", command=lambda: _browse(wizard_bot_var)).pack(side=tk.LEFT)

        def _use_project_poscar() -> None:
            if proj_poscar.exists():
                wizard_top_var.set(str(proj_poscar))
                wizard_bot_var.set(str(proj_poscar))
            else:
                messagebox.showinfo(APP_NAME, f"项目目录中未找到 {proj_poscar.name}")

        ttk.Button(step1, text="使用当前项目 POSCAR", command=_use_project_poscar).pack(anchor=tk.W, pady=(4, 0))
        ttk.Button(step1, text="复制上层路径到下层", command=lambda: wizard_bot_var.set(wizard_top_var.get())).pack(anchor=tk.W, pady=(2, 0))

        step2 = ttk.Frame(body)
        step_frames.append(step2)
        ttk.Label(step2, text="步骤 2/4：选择推荐模板", font=("TkDefaultFont", 10, "bold")).pack(anchor=tk.W)
        ttk.Label(
            step2,
            text=context_reason,
            foreground="#555",
            wraplength=420,
            justify=tk.LEFT,
        ).pack(anchor=tk.W, pady=(2, 6))

        ttk.Label(step2, text="材料模板：").pack(anchor=tk.W)
        template_combo = ttk.Combobox(
            step2,
            state="readonly",
            values=template_labels,
            textvariable=wizard_template_var,
        )
        template_combo.pack(fill=tk.X, pady=(2, 6))
        template_info_var = tk.StringVar(value="")
        ttk.Label(
            step2,
            textvariable=template_info_var,
            wraplength=420,
            foreground="#555",
            justify=tk.LEFT,
        ).pack(anchor=tk.W)

        def _update_template_info(*_args) -> None:
            label = wizard_template_var.get()
            key = getattr(self, "_tw_template_choice_map", {}).get(label, label)
            tpl = TW_TEMPLATE_LIBRARY.get(key)
            if tpl:
                template_info_var.set(f"推荐：{tpl['label']} — {tpl.get('summary', '')}")
            else:
                template_info_var.set("将使用通用默认参数，可在完成后自行微调。")
            refresh_summary()

        template_combo.bind("<<ComboboxSelected>>", _update_template_info)

        step3 = ttk.Frame(body)
        step_frames.append(step3)
        ttk.Label(step3, text="步骤 3/4：设置角度与滑移网格", font=("TkDefaultFont", 10, "bold")).pack(anchor=tk.W)

        row_angle = ttk.Frame(step3)
        row_angle.pack(fill=tk.X, pady=4)
        ttk.Label(row_angle, text="起始 θ (°)").pack(side=tk.LEFT)
        ttk.Entry(row_angle, textvariable=wizard_theta_a, width=8).pack(side=tk.LEFT, padx=4)
        ttk.Label(row_angle, text="结束 θ (°)").pack(side=tk.LEFT)
        ttk.Entry(row_angle, textvariable=wizard_theta_b, width=8).pack(side=tk.LEFT, padx=4)
        ttk.Label(row_angle, text="步长 (°)").pack(side=tk.LEFT)
        ttk.Entry(row_angle, textvariable=wizard_theta_step, width=8).pack(side=tk.LEFT, padx=4)

        row_slide = ttk.Frame(step3)
        row_slide.pack(fill=tk.X, pady=4)
        ttk.Label(row_slide, text="uₓ 步数").pack(side=tk.LEFT)
        ttk.Spinbox(row_slide, from_=1, to=32, textvariable=wizard_ux_steps, width=6).pack(side=tk.LEFT, padx=4)
        ttk.Label(row_slide, text="uᵧ 步数").pack(side=tk.LEFT)
        ttk.Spinbox(row_slide, from_=1, to=32, textvariable=wizard_uy_steps, width=6).pack(side=tk.LEFT, padx=4)

        ttk.Label(
            step3,
            text="六角或三角晶格 0–60° 已覆盖独立堆垛；滑移覆盖 [0,1)×[0,1)。",
            foreground="#555",
            wraplength=420,
            justify=tk.LEFT,
        ).pack(anchor=tk.W, pady=(2, 6))

        task_preview_var = tk.StringVar(value="预估任务数：—")
        ttk.Label(step3, textvariable=task_preview_var, foreground="#0a5cad").pack(anchor=tk.W)
        task_hint_var = tk.StringVar(value="")
        ttk.Label(step3, textvariable=task_hint_var, foreground="#b35c00", wraplength=420, justify=tk.LEFT).pack(anchor=tk.W)

        step4 = ttk.Frame(body)
        step_frames.append(step4)
        ttk.Label(step4, text="步骤 4/4：确认并进入二维面板", font=("TkDefaultFont", 10, "bold")).pack(anchor=tk.W)
        summary_var = tk.StringVar(value="")
        ttk.Label(step4, textvariable=summary_var, wraplength=420, justify=tk.LEFT).pack(anchor=tk.W, pady=(4, 6))
        ttk.Button(step4, text="一键快速体检并修复", command=self.quick_preflight).pack(anchor=tk.W)
        ttk.Label(
            step4,
            text="完成后将跳转至二维页，可立即运行“开始批量扫描”或“只生成当前构型”。",
            foreground="#555",
            wraplength=420,
            justify=tk.LEFT,
        ).pack(anchor=tk.W, pady=(6, 0))

        def _compute_counts():
            try:
                a = float(wizard_theta_a.get())
                b = float(wizard_theta_b.get())
                step = float(wizard_theta_step.get())
            except Exception:
                return None
            if step <= 0:
                step = 1.0
            if abs(b - a) < 1e-9:
                thetas = [a]
            else:
                thetas = self._tw_linspace(a, b, step)
            ux = max(int(wizard_ux_steps.get()), 1)
            uy = max(int(wizard_uy_steps.get()), 1)
            total = len(thetas) * ux * uy
            return len(thetas), ux, uy, total

        def refresh_summary(*_args) -> None:
            counts = _compute_counts()
            lines: list[str] = []
            top_path = wizard_top_var.get().strip()
            bot_path = wizard_bot_var.get().strip()
            lines.append(f"结构：上层 {Path(top_path).name or '未选'} / 下层 {Path(bot_path).name or '未选'}")
            lines.append(f"模板：{wizard_template_var.get()}")
            if counts:
                n_theta, n_ux, n_uy, total = counts
                lines.append(f"角度 Nθ={n_theta}, 滑移 Nₓ={n_ux} × Nᵧ={n_uy}, 任务数≈{total}")
            if context_reason:
                lines.append(context_reason)
            summary_var.set("\n".join(lines))

        def update_task_preview(*_args) -> None:
            counts = _compute_counts()
            if not counts:
                task_preview_var.set("预估任务数：参数未设置完整")
                task_hint_var.set("")
            else:
                n_theta, n_ux, n_uy, total = counts
                msg = f"预估任务数：Nθ={n_theta} × Nₓ={n_ux} × Nᵧ={n_uy} = {total}"
                if max_tasks_default and total > max_tasks_default:
                    msg += f"  ⚠️ 超过上限 {max_tasks_default}"
                    task_hint_var.set("超过上限时会自动启用仅 Γ 点策略。")
                elif max_tasks_default:
                    msg += f"（上限 {max_tasks_default}）"
                    task_hint_var.set("")
                else:
                    task_hint_var.set("")
                task_preview_var.set(msg)
            refresh_summary()

        for var in (
            wizard_theta_a,
            wizard_theta_b,
            wizard_theta_step,
            wizard_ux_steps,
            wizard_uy_steps,
        ):
            try:
                var.trace_add("write", update_task_preview)
            except Exception:
                pass

        for var in (wizard_top_var, wizard_bot_var, wizard_template_var):
            try:
                var.trace_add("write", refresh_summary)
            except Exception:
                pass

        _update_template_info()
        update_task_preview()

        nav = ttk.Frame(top, padding=(12, 0, 12, 12))
        nav.pack(fill=tk.X)

        current = {"index": 0}

        def show_step(idx: int) -> None:
            idx = max(0, min(idx, len(step_frames) - 1))
            for frame in step_frames:
                frame.pack_forget()
            step_frames[idx].pack(fill=tk.BOTH, expand=True)
            current["index"] = idx
            prev_btn.configure(state=tk.NORMAL if idx > 0 else tk.DISABLED)
            next_btn.configure(state=tk.NORMAL if idx < len(step_frames) - 1 else tk.DISABLED)
            finish_btn.configure(state=tk.NORMAL if idx == len(step_frames) - 1 else tk.DISABLED)

        def _validate(idx: int) -> bool:
            if idx == 0:
                top_path = wizard_top_var.get().strip()
                bot_path = wizard_bot_var.get().strip()
                if not top_path or not bot_path:
                    messagebox.showwarning(APP_NAME, "请为上下层选择 POSCAR。")
                    return False
                missing = []
                if top_path and not Path(top_path).exists():
                    missing.append(top_path)
                if bot_path and not Path(bot_path).exists():
                    missing.append(bot_path)
                if missing:
                    messagebox.showwarning(APP_NAME, "以下路径不存在：\n" + "\n".join(missing))
                    return False
            if idx >= 2:
                if not _compute_counts():
                    messagebox.showwarning(APP_NAME, "请填写有效的角度与滑移参数。")
                    return False
            return True

        def go_next() -> None:
            idx = current["index"]
            if not _validate(idx):
                return
            show_step(idx + 1)

        def go_prev() -> None:
            show_step(current["index"] - 1)

        def _apply_to_main() -> None:
            top_path = wizard_top_var.get().strip()
            bot_path = wizard_bot_var.get().strip()
            template_label = wizard_template_var.get()
            if top_path and hasattr(self, "tw_top_path"):
                self.tw_top_path.set(top_path)
            if bot_path and hasattr(self, "tw_bot_path"):
                self.tw_bot_path.set(bot_path)
            if template_label and hasattr(self, "tw_template_var"):
                try:
                    self.tw_template_var.set(template_label)
                except Exception:
                    pass
                self._tw_on_template_change()
            try:
                self.tw_theta_a.set(float(wizard_theta_a.get()))
                self.tw_theta_b.set(float(wizard_theta_b.get()))
                self.tw_theta_step.set(max(float(wizard_theta_step.get()), 1e-3))
            except Exception:
                pass
            try:
                self.tw_ux_steps.set(max(int(wizard_ux_steps.get()), 1))
                self.tw_uy_steps.set(max(int(wizard_uy_steps.get()), 1))
            except Exception:
                pass
            for attr in ("tw_enable_twist", "tw_enable_slide"):
                var = getattr(self, attr, None)
                if isinstance(var, tk.BooleanVar):
                    try:
                        var.set(True)
                    except Exception:
                        pass
            self._tw_update_config_summary()
            self._tw_update_task_summary()
            self._update_tw_entry_banner()
            self.goto_tab(getattr(self, "page_twist", None) or self.page_inputs)
            self._tw_append_log("二维扫描向导已应用所选设置。")

        def _finish() -> None:
            if not _validate(current["index"]):
                return
            _apply_to_main()
            _close()

        def _close() -> None:
            try:
                top.grab_release()
            except Exception:
                pass
            try:
                top.destroy()
            finally:
                self._tw_wizard = None

        nav.pack_propagate(False)
        ttk.Separator(nav, orient=tk.HORIZONTAL).pack(fill=tk.X, side=tk.TOP, pady=(0, 8))
        btn_row = ttk.Frame(nav)
        btn_row.pack(fill=tk.X)
        cancel_btn = ttk.Button(btn_row, text="取消", command=_close)
        cancel_btn.pack(side=tk.RIGHT)
        finish_btn = ttk.Button(btn_row, text="完成", command=_finish)
        finish_btn.pack(side=tk.RIGHT, padx=(6, 0))
        next_btn = ttk.Button(btn_row, text="下一步", command=go_next)
        next_btn.pack(side=tk.RIGHT, padx=(6, 0))
        prev_btn = ttk.Button(btn_row, text="上一步", command=go_prev)
        prev_btn.pack(side=tk.RIGHT)

        show_step(0)
        try:
            top.update_idletasks()
            w = top.winfo_width()
            h = top.winfo_height()
            x = self.winfo_rootx() + (self.winfo_width() - w) // 2
            y = self.winfo_rooty() + (self.winfo_height() - h) // 2
            top.geometry(f"+{max(x, 0)}+{max(y, 0)}")
        except Exception:
            pass
        top.protocol("WM_DELETE_WINDOW", _close)

    def _tw_update_tw_post_hint(self) -> None:
        frame = getattr(self, "tw_post_hint_frame", None)
        if frame is None:
            return
        var = getattr(self, "tw_post_hint_var", None)
        root = self.current_project_path() / "twist_sweep"
        exists = root.exists()
        best_hint = ""
        csv_path = root / "results.csv"
        if csv_path.exists():
            try:
                import csv
                best_energy = None
                with csv_path.open("r", encoding="utf-8", errors="ignore") as f:
                    reader = csv.DictReader(f)
                    for rec in reader:
                        try:
                            energy = float(rec.get("E") or rec.get("totalE_eV") or "nan")
                            theta = float(rec.get("theta") or "nan")
                            ux = float(rec.get("ux") or "nan")
                            uy = float(rec.get("uy") or "nan")
                        except Exception:
                            continue
                        if math.isnan(energy) or math.isnan(theta) or math.isnan(ux) or math.isnan(uy):
                            continue
                        if best_energy is None or energy < best_energy:
                            best_energy = energy
                            best_hint = f"最优候选 θ≈{theta:.3f}°, u≈({ux:.3f},{uy:.3f})"
            except Exception:
                best_hint = ""
        if exists:
            message = "检测到 twist_sweep 批量目录，可快速复算最优 θ,u 组合。"
            if best_hint:
                message += " " + best_hint
            if var is not None:
                var.set(message)
            if not getattr(self, "_tw_post_hint_visible", False):
                frame.pack(fill=tk.X, pady=(0, 6))
                self._tw_post_hint_visible = True
        else:
            if var is not None:
                var.set("")
            if getattr(self, "_tw_post_hint_visible", False):
                try:
                    frame.pack_forget()
                except Exception:
                    pass
                self._tw_post_hint_visible = False

    def _tw_jump_to_best_for_refine(self) -> None:
        root = self.current_project_path() / "twist_sweep"
        rows = self._tw_load_results_table(root)
        if not rows:
            messagebox.showwarning(APP_NAME, "未在项目中找到 twist_sweep 结果。")
            return
        best = None
        best_key = None
        for row in rows:
            energy = row.get("E")
            try:
                energy_val = float(energy)
            except Exception:
                energy_val = float("nan")
            if math.isnan(energy_val):
                continue
            gap = row.get("gap")
            try:
                gap_val = float(gap)
            except Exception:
                gap_val = float("nan")
            gap_metric = abs(gap_val) if not math.isnan(gap_val) else float("inf")
            key = (energy_val, gap_metric)
            if best_key is None or key < best_key:
                best_key = key
                best = row
        if best is None:
            best = rows[0]

        def _safe_float(val: object, default: float = 0.0) -> float:
            try:
                num = float(val)
            except Exception:
                return default
            return default if math.isnan(num) else num

        theta = _safe_float(best.get("theta"), 0.0)
        ux = _safe_float(best.get("ux"), 0.0)
        uy = _safe_float(best.get("uy"), 0.0)
        note = best.get("note") or ""
        rel_path = best.get("path") or ""
        self._tw_single_override = (ux, uy)
        try:
            self.tw_theta_a.set(theta)
            self.tw_theta_b.set(theta)
        except Exception:
            pass
        try:
            self.tw_enable_twist.set(False)
        except Exception:
            pass
        try:
            self.tw_enable_slide.set(False)
        except Exception:
            pass
        self._tw_update_task_summary()
        self.goto_tab(getattr(self, "page_twist", None) or self.page_inputs)
        self._tw_append_log(
            f"已定位最优候选：θ={theta:.3f}°, u=({ux:.3f},{uy:.3f})。建议使用“只生成当前构型”并在 INCAR 中切换 HSE06。"
        )
        lines = [
            f"θ ≈ {theta:.3f}°", f"uₓ ≈ {ux:.3f}", f"uᵧ ≈ {uy:.3f}",
        ]
        if rel_path:
            lines.append(f"目录：{rel_path}")
        if note:
            lines.append(f"备注：{note}")
        lines.append("下一步：点击“只生成当前构型”生成精修目录，并运行快速体检。")
        messagebox.showinfo(APP_NAME, "已定位最优 θ,u", "\n".join(lines))

    # === CODEX END: twist/shift helpers ===

    # === CODEX BEGIN: twist/shift page UI ===
    def _build_twistshift_page(self, parent):
        frame = ttk.Frame(parent)

        # 左栏：输入与控制（带滚动条）
        left_container = ttk.Frame(frame)
        left_container.pack(side=tk.LEFT, fill=tk.Y)
        left_canvas = tk.Canvas(left_container, borderwidth=0, highlightthickness=0, width=420)
        left_scroll = ttk.Scrollbar(left_container, orient=tk.VERTICAL, command=left_canvas.yview)
        left_canvas.configure(yscrollcommand=left_scroll.set)
        left_canvas.pack(side=tk.LEFT, fill=tk.Y, expand=False)
        left_scroll.pack(side=tk.RIGHT, fill=tk.Y)

        left = ttk.Frame(left_canvas, padding=8)
        left_window = left_canvas.create_window((0, 0), window=left, anchor="nw")


        style = ttk.Style()
        style.configure("TwBanner.TFrame", background="#e7f1ff")
        style.configure("TwBanner.TLabel", background="#e7f1ff", foreground="#0a5cad")

        self.tw_post_hint_frame = ttk.Frame(left, padding=6, style="TwBanner.TFrame")
        self.tw_post_hint_var = tk.StringVar(value="")
        ttk.Label(
            self.tw_post_hint_frame,
            textvariable=self.tw_post_hint_var,
            wraplength=320,
            justify=tk.LEFT,
            style="TwBanner.TLabel",
        ).pack(side=tk.LEFT, fill=tk.X, expand=True)
        ttk.Button(
            self.tw_post_hint_frame,
            text="快速复算最优 θ,u",
            command=self._tw_jump_to_best_for_refine,
        ).pack(side=tk.RIGHT, padx=(8, 0))
        self._tw_post_hint_visible = False

        def _sync_scrollregion(event):
            left_canvas.configure(scrollregion=left_canvas.bbox("all"))

        def _match_width(event):
            left_canvas.itemconfigure(left_window, width=event.width)

        left.bind("<Configure>", _sync_scrollregion)
        left_canvas.bind("<Configure>", _match_width)

        def _on_mousewheel(event):
            delta = 0
            if event.delta:
                delta = -int(event.delta / 120)
            elif event.num in (4, 5):
                delta = -1 if event.num == 4 else 1
            if delta:
                left_canvas.yview_scroll(delta, "units")
                return "break"

        for widget in (left_canvas, left):
            widget.bind("<MouseWheel>", _on_mousewheel)
            widget.bind("<Button-4>", _on_mousewheel)
            widget.bind("<Button-5>", _on_mousewheel)
        ttk.Label(left, text="二维材料扭转/滑移 | 生成批量 POSCAR 与扫参任务").pack(anchor=tk.W, pady=(0, 6))

        template_choices = {
            "自动推荐（根据结构推断）": "auto",
            "石墨烯 / h-BN（六角）": "graphene_bn",
            "MoS₂ / WS₂（TMD）": "mos2_tmd",
            "异质双层 / 莫尔预筛": "hetero_moire",
        }
        self._tw_template_choice_map = template_choices

        provenance_box = ttk.LabelFrame(left, text="配置来源与推荐")
        provenance_box.pack(fill=tk.X, pady=(0, 8))

        combo_row = ttk.Frame(provenance_box)
        combo_row.pack(fill=tk.X, pady=(4, 2))
        ttk.Label(combo_row, text="材料模板：").pack(side=tk.LEFT)
        self.tw_template_var = tk.StringVar(value=list(template_choices.keys())[0])
        template_combo = ttk.Combobox(
            combo_row,
            state="readonly",
            values=list(template_choices.keys()),
            textvariable=self.tw_template_var,
            width=28,
        )
        template_combo.pack(side=tk.LEFT, padx=(4, 0))
        template_combo.bind("<<ComboboxSelected>>", lambda _e: self._tw_on_template_change())
        self.tw_apply_source_var = tk.StringVar(value="来源：通用默认")
        ttk.Label(combo_row, textvariable=self.tw_apply_source_var, foreground="#555").pack(side=tk.RIGHT, padx=(0, 6))
        ttk.Button(combo_row, text="应用推荐参数", command=self._tw_apply_recommended_config).pack(side=tk.RIGHT, padx=(6, 0))

        self.tw_config_summary_var = tk.StringVar(value="来源：通用默认")
        ttk.Label(
            provenance_box,
            textvariable=self.tw_config_summary_var,
            wraplength=360,
            justify=tk.LEFT,
        ).pack(fill=tk.X, pady=(2, 2))

        self.tw_config_reason_var = tk.StringVar(value="为何是这个默认：—")
        ttk.Label(
            provenance_box,
            textvariable=self.tw_config_reason_var,
            wraplength=360,
            justify=tk.LEFT,
            foreground="#555",
        ).pack(fill=tk.X, pady=(0, 4))

        self.tw_template_desc_var = tk.StringVar(value="")
        ttk.Label(
            provenance_box,
            textvariable=self.tw_template_desc_var,
            wraplength=360,
            justify=tk.LEFT,
            foreground="#555",
        ).pack(fill=tk.X, pady=(0, 4))

        self.tw_config_tree = ttk.Treeview(
            provenance_box,
            columns=("param", "value", "source"),
            show="headings",
            height=5,
        )
        self.tw_config_tree.heading("param", text="参数")
        self.tw_config_tree.heading("value", text="推荐值")
        self.tw_config_tree.heading("source", text="来源")
        self.tw_config_tree.column("param", width=140, anchor=tk.W)
        self.tw_config_tree.column("value", width=90, anchor=tk.W)
        self.tw_config_tree.column("source", anchor=tk.W)
        self.tw_config_tree.pack(fill=tk.X, pady=(0, 4))

        help_poscar = textwrap.dedent("""
            【基础输入】
            • 先后选择底层 (B) 与上层 (T) 的 POSCAR；优先使用已经几何优化的结构。
            • 默认假设 POSCAR 的 c 轴沿层法向；如不满足，请先在外部完成对齐。
            • 真空厚度与偶极修正建议在上方“配置来源”中查看推荐值与来源解释。
        """).strip()
        help_vacuum = textwrap.dedent("""
            【真空与容许应变】
            • 真空(Å) = 层间距 + 空腔厚度，二维体系常用 15–20 Å，并配合 LDIPOL=.TRUE., IDIPOL=3。
            • 容许面内等比例应变(%) 控制近共格匹配的松紧，通常 0.5–1.0%；值越大超胞越小，但物理偏差增大。
            • 推荐流程：先在较松参数下收敛，再逐步放宽偶极修正或收紧应变阈值。
        """).strip()
        help_twist = textwrap.dedent("""
            【扭转角扫描】
            • 起/止/步长按闭区间生成角度序列；若步长无法整除区间，末端会自动截断。
            • 六角/三角晶格 0–60° 已覆盖独立堆垛；其它体系请根据对称性调整范围。
            • 角度数量 Nθ = floor((止 − 起)/步长) + 1，会在任务统计中实时显示。
        """).strip()
        help_slide = textwrap.dedent("""
            【滑移网格】
            • 滑移以分数坐标 uₓ,uᵧ 表示：t = uₓ·a₁ + uᵧ·a₂，取值范围 [0,1)。
            • 设 uₓ 步数 = nₓ、uᵧ 步数 = nᵧ，共生成 nₓ×nᵧ 组合；六角晶格会自动消除对称重复。
            • 可先用稀疏网格预筛，再在感兴趣区间细化滑移步数。
        """).strip()
        help_compute = textwrap.dedent("""
            【K 点策略与任务规模】
            • KSPACING (Å⁻¹) 控制自动网格密度；若项目已有 KPOINTS，则 KPOINTS 优先生效。
            • Gamma 中心网格 (Gamma-centered) 通过 KGAMMA 控制；“仅 Γ 点 (Γ-only)” 将写入 1×1×1 KPOINTS。
            • 总任务数 ≈ Nθ × Nₓ × Nᵧ；超过阈值会自动记录并触发仅 Γ 点策略。
        """).strip()
        help_actions = textwrap.dedent("""
            【操作按钮】
            • “预览当前构型（θ,u）”：即时生成当前组合并绘制俯视结构，不写入磁盘。
            • “只生成当前构型”：创建单独子目录，便于针对性调参。
            • “开始批量扫描”：依据当前网格构建 twist_sweep/* 子目录并写入 INCAR/KPOINTS/meta.json。
            • “生成后自动运行”：复制项目脚本并尝试调用 run_local.sh（实验性功能）。
            • “解析 sweep 结果 → CSV”：统计能量/带隙/备注，便于后续筛选与复算。
        """).strip()
        help_defaults = textwrap.dedent("""
            【科研说明】
            • PBE 带隙偏低，关键构型可在“配置来源”内一键切换 HSE06 核心标签。
            • 真空 15–20 Å、LDIPOL/IDIPOL=3 是薄膜/2D 体系的常规做法；记录来源便于审稿复现。
            • 扫描参数、K 点密度、偶极修正均会写入 meta.json，方便导出 run_meta.json。
        """).strip()
        help_notes = textwrap.dedent("""
            【常见注意事项】
            • 角度越小原子数越大，可结合任务上限与“仅 Γ 点”策略控制规模。
            • 滑移采用 [0,1) 分数坐标，可借助预览面板核对 t = uₓ·a₁ + uᵧ·a₂。
            • 扫描前建议运行“快速体检 (Preflight)”并应用推荐修复，避免粗糙默认网格。
        """).strip()

        # 路径选择
        self._add_section_heading(left, "路径选择", help_poscar, title="上/下层 POSCAR 指南", pady=(0, 4))
        self.tw_top_path = tk.StringVar()
        self.tw_bot_path = tk.StringVar()

        row = ttk.Frame(left); row.pack(fill=tk.X, pady=2)
        ttk.Label(row, text="上层 POSCAR:").pack(side=tk.LEFT)
        ttk.Entry(row, textvariable=self.tw_top_path, width=30).pack(side=tk.LEFT, padx=4)
        ttk.Button(row, text="选择…", command=lambda: self._tw_pick_poscar(self.tw_top_path)).pack(side=tk.LEFT)

        row = ttk.Frame(left); row.pack(fill=tk.X, pady=2)
        ttk.Label(row, text="下层 POSCAR:").pack(side=tk.LEFT)
        ttk.Entry(row, textvariable=self.tw_bot_path, width=30).pack(side=tk.LEFT, padx=4)
        ttk.Button(row, text="选择…", command=lambda: self._tw_pick_poscar(self.tw_bot_path)).pack(side=tk.LEFT)

        try:
            self.tw_top_path.trace_add("write", self._tw_on_structure_change)
            self.tw_bot_path.trace_add("write", self._tw_on_structure_change)
        except Exception:
            pass

        ttk.Separator(left, orient=tk.HORIZONTAL).pack(fill=tk.X, pady=6)

        # 基本几何参数
        self.tw_vacuum = tk.DoubleVar(value=20.0)     # 真空厚度 (Å)
        self.tw_interlayer = tk.DoubleVar(value=3.35)  # 层间距 (Å)
        self.tw_allow_strain = tk.DoubleVar(value=0.8)  # 允许等效小应变（%）
        self.tw_gamma_center = tk.BooleanVar(value=True)
        self.tw_force_gamma_only = tk.BooleanVar(value=False)
        self.tw_gamma_atom_threshold = tk.IntVar(value=500)  # 超大超胞→Gamma-only
        self.tw_enable_twist = tk.BooleanVar(value=True)
        self.tw_enable_slide = tk.BooleanVar(value=True)

        self._add_section_heading(left, "基本几何参数", help_vacuum, title="真空与容许应变")
        row = ttk.Frame(left); row.pack(fill=tk.X, pady=2)
        ttk.Label(row, text="真空(Å):").pack(side=tk.LEFT)
        ttk.Entry(row, textvariable=self.tw_vacuum, width=5).pack(side=tk.LEFT, padx=4)
        ttk.Label(row, text="层间距(Å)").pack(side=tk.LEFT, padx=(8, 0))
        ttk.Entry(row, textvariable=self.tw_interlayer, width=5).pack(side=tk.LEFT, padx=4)
        ttk.Label(row, text="容许面内等比例应变(%)").pack(side=tk.LEFT, padx=(8,0))
        ttk.Entry(row, textvariable=self.tw_allow_strain, width=5).pack(side=tk.LEFT, padx=4)

        dim_frame = ttk.LabelFrame(left, text="扫描维度")
        dim_frame.pack(fill=tk.X, pady=4)
        ttk.Checkbutton(dim_frame, text="启用扭转角扫描", variable=self.tw_enable_twist).pack(anchor=tk.W, padx=6, pady=2)
        ttk.Checkbutton(dim_frame, text="启用滑移网格扫描", variable=self.tw_enable_slide).pack(anchor=tk.W, padx=6, pady=2)
        ttk.Label(dim_frame, text="可按需只做扭转或只做滑移，两者都开时则全量组合。", wraplength=340, justify=tk.LEFT, foreground="#555").pack(anchor=tk.W, padx=6, pady=(0, 4))

        ttk.Separator(left, orient=tk.HORIZONTAL).pack(fill=tk.X, pady=6)

        # 扭转角扫描
        self._add_section_heading(left, "扭转角扫描", help_twist, title="扭转角 θ（度）")
        ttk.Label(left, text="扭转角 θ (度)：").pack(anchor=tk.W)
        self.tw_theta_a = tk.DoubleVar(value=0.0)
        self.tw_theta_b = tk.DoubleVar(value=10.0)
        self.tw_theta_step = tk.DoubleVar(value=2.0)
        r=ttk.Frame(left); r.pack(fill=tk.X, pady=2)
        ttk.Label(r, text="起").pack(side=tk.LEFT); ttk.Entry(r, textvariable=self.tw_theta_a, width=7).pack(side=tk.LEFT, padx=4)
        ttk.Label(r, text="止").pack(side=tk.LEFT); ttk.Entry(r, textvariable=self.tw_theta_b, width=7).pack(side=tk.LEFT, padx=4)
        ttk.Label(r, text="步").pack(side=tk.LEFT); ttk.Entry(r, textvariable=self.tw_theta_step, width=7).pack(side=tk.LEFT, padx=4)
        ttk.Label(left, text="注：六角晶格通常只需 0–60° 区间。", foreground="#666").pack(anchor=tk.W, pady=(0,4))

        # 滑移扫描（分数坐标）
        self._add_section_heading(left, "滑移网格", help_slide, title="滑移 (分数坐标)")
        ttk.Label(left, text="滑移 (分数坐标 uₓ,uᵧ，取值 [0,1) )：").pack(anchor=tk.W)
        self.tw_ux_steps = tk.IntVar(value=5)
        self.tw_uy_steps = tk.IntVar(value=5)
        r=ttk.Frame(left); r.pack(fill=tk.X, pady=2)
        ttk.Label(r, text="u_x 步数").pack(side=tk.LEFT); ttk.Spinbox(r, from_=1, to=32, textvariable=self.tw_ux_steps, width=6).pack(side=tk.LEFT, padx=4)
        ttk.Label(r, text="u_y 步数").pack(side=tk.LEFT, padx=(8,0)); ttk.Spinbox(r, from_=1, to=32, textvariable=self.tw_uy_steps, width=6).pack(side=tk.LEFT, padx=4)
        ttk.Label(left, text="网格覆盖 [0,1)×[0,1)，自动等间隔。", foreground="#666").pack(anchor=tk.W)

        ttk.Separator(left, orient=tk.HORIZONTAL).pack(fill=tk.X, pady=6)

        # 计算与并行策略
        self.tw_kspacing = tk.DoubleVar(value=0.22)
        self.tw_max_tasks = tk.IntVar(value=200)
        self.tw_autorun = tk.BooleanVar(value=False)  # 可选：生成后立刻运行（默认关）

        self._add_section_heading(left, "计算与并行策略", help_compute, title="KSPACING 与任务上限")
        r=ttk.Frame(left); r.pack(fill=tk.X, pady=2)
        ttk.Label(r, text="KSPACING (Å⁻¹)").pack(side=tk.LEFT)
        ttk.Entry(r, textvariable=self.tw_kspacing, width=7).pack(side=tk.LEFT, padx=4)
        ttk.Label(r, text="最大任务数 N（硬阈值）").pack(side=tk.LEFT, padx=(8,0)); ttk.Entry(r, textvariable=self.tw_max_tasks, width=7).pack(side=tk.LEFT, padx=4)
        ttk.Label(left, text="若存在 KPOINTS 文件则优先生效；缺省两者时 VASP 会回退粗糙网格。", foreground="#666", wraplength=360, justify=tk.LEFT).pack(fill=tk.X, pady=(0,4))
        ttk.Checkbutton(left, text="Gamma 中心网格 (Gamma-centered)", variable=self.tw_gamma_center).pack(anchor=tk.W, pady=(0,2))
        ttk.Checkbutton(left, text="仅 Γ 点 (Γ-only)", variable=self.tw_force_gamma_only).pack(anchor=tk.W, pady=(0,4))
        ttk.Checkbutton(left, text="生成后自动运行（试验性）", variable=self.tw_autorun).pack(anchor=tk.W, pady=(2,4))

        self.tw_task_summary_var = tk.StringVar(value="Nθ × Nₓ × Nᵧ = —")
        self.tw_task_summary_label = ttk.Label(left, textvariable=self.tw_task_summary_var)
        self.tw_task_summary_label.pack(anchor=tk.W, pady=(0,2))
        self.tw_task_rule_var = tk.StringVar(value="规则：预计原子数超过 ~500 × 2 层时自动切换仅 Γ 点。")
        ttk.Label(left, textvariable=self.tw_task_rule_var, foreground="#555", wraplength=360, justify=tk.LEFT).pack(anchor=tk.W, pady=(0,6))

        # 操作按钮
        self._add_section_heading(left, "任务操作", help_actions, title="选项与按钮")
        btns = ttk.Frame(left); btns.pack(fill=tk.X, pady=8)
        ttk.Button(btns, text="预览当前构型（θ,u）", command=self._tw_preview_once).pack(side=tk.LEFT)
        ttk.Button(btns, text="只生成当前构型", command=lambda: self._tw_generate(single=True)).pack(side=tk.LEFT, padx=6)
        ttk.Button(btns, text="开始批量扫描", command=lambda: self._tw_generate(single=False)).pack(side=tk.LEFT)

        ttk.Separator(left, orient=tk.HORIZONTAL).pack(fill=tk.X, pady=6)
        ttk.Button(left, text="解析 sweep 结果 → CSV", command=self._tw_collect_results_btn).pack(anchor=tk.W)
        ttk.Button(left, text="绘制 gap 热图（用当前 θ）", command=self._tw_plot_gap_heatmap_btn).pack(anchor=tk.W, pady=(4, 0))
        ttk.Button(left, text="绘制 gap–θ 曲线（min/mean/max）", command=self._tw_plot_gap_vs_theta_btn).pack(anchor=tk.W, pady=(4, 8))

        for var in (
            self.tw_theta_a,
            self.tw_theta_b,
            self.tw_theta_step,
            self.tw_ux_steps,
            self.tw_uy_steps,
            self.tw_enable_twist,
            self.tw_enable_slide,
            self.tw_max_tasks,
        ):
            try:
                var.trace_add("write", self._tw_update_task_summary)
            except Exception:
                pass
        try:
            def _on_gamma_center_change(*_args):
                self._tw_update_config_summary()

            def _on_gamma_only_change(*_args):
                self._tw_update_config_summary()
                self._tw_update_task_summary()

            self.tw_gamma_center.trace_add("write", _on_gamma_center_change)
            self.tw_force_gamma_only.trace_add("write", _on_gamma_only_change)
        except Exception:
            pass

        self._tw_on_template_change()
        self._tw_update_config_summary(apply_initial=True)

        self._add_section_heading(left, "推荐默认值", help_defaults, title="计算与物理的默认值", pady=(8, 4))
        self._add_section_heading(left, "常见注意事项", help_notes, title="常见注意事项", pady=(0, 8))

        log_box = ttk.LabelFrame(left, text="运行日志")
        log_box.pack(fill=tk.BOTH, expand=True, pady=(0, 8))
        self.tw_log = ScrolledText(log_box, height=10, wrap="word")
        self.tw_log.pack(fill=tk.BOTH, expand=True, padx=4, pady=4)
        self.tw_log.insert(tk.END, "扭转/滑移任务的进度消息会显示在此处。\n")
        self.tw_log.configure(state=tk.DISABLED)

        # 右栏：俯视预览
        right = ttk.Frame(frame, padding=8); right.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True)
        self.fig_tw = Figure(figsize=(6.0,4.5), dpi=100)
        self.ax_tw = self.fig_tw.add_subplot(111)
        self.ax_tw.set_title("Top view preview")
        self.ax_tw.set_xlabel("x (Å)"); self.ax_tw.set_ylabel("y (Å)")
        self.canvas_tw = FigureCanvasTkAgg(self.fig_tw, master=right)
        self.canvas_tw.draw(); self.canvas_tw.get_tk_widget().pack(fill=tk.BOTH, expand=True)

        return frame

    def _tw_append_log(self, message: str) -> None:
        if not hasattr(self, "tw_log"):
            return
        timestamp = time.strftime("%H:%M:%S")
        try:
            self.tw_log.configure(state=tk.NORMAL)
            self.tw_log.insert(tk.END, f"[{timestamp}] {message}\n")
            self.tw_log.see(tk.END)
            self.tw_log.configure(state=tk.DISABLED)
            self.tw_log.update_idletasks()
        except Exception:
            try:
                self.tw_log.configure(state=tk.DISABLED)
            except Exception:
                pass

    def _tw_apply_incar_template(self, key: str) -> None:
        templates = {
            "metal_film": {
                "patch": {
                    "ISMEAR": "1",
                    "SIGMA": "0.2",
                    "ISYM": "0",
                    "KSPACING": "0.22",
                    "LDIPOL": ".TRUE.",
                    "IDIPOL": "3",
                    "LCHARG": ".TRUE.",
                    "LWAVE": ".FALSE.",
                },
                "kspacing": 0.22,
                "summary": "已应用金属薄膜模板：ISMEAR=1, SIGMA=0.2, ISYM=0, LDIPOL/IDIPOL=3, KSPACING=0.22。",
            },
            "hetero_semi": {
                "patch": {
                    "ISMEAR": "0",
                    "SIGMA": "0.05",
                    "ISYM": "0",
                    "KSPACING": "0.24",
                    "LDIPOL": ".TRUE.",
                    "IDIPOL": "3",
                    "EDIFF": "1e-6",
                    "EDIFFG": "-0.02",
                    "LCHARG": ".TRUE.",
                    "LWAVE": ".FALSE.",
                },
                "kspacing": 0.24,
                "summary": "已应用半导体异质结模板：ISMEAR=0, SIGMA=0.05, ISYM=0, LDIPOL/IDIPOL=3, KSPACING≈0.24。",
            },
            "moire_screen": {
                "patch": {
                    "ISMEAR": "0",
                    "SIGMA": "0.05",
                    "ISYM": "0",
                    "KSPACING": "0.35",
                    "LREAL": "Auto",
                    "NELM": "120",
                    "ALGO": "Normal",
                    "PREC": "Normal",
                    "LDIPOL": ".TRUE.",
                    "IDIPOL": "3",
                    "LCHARG": ".TRUE.",
                    "LWAVE": ".FALSE.",
                },
                "kspacing": 0.35,
                "summary": "已应用超大莫尔预筛模板：Γ-only 友好参数，KSPACING≈0.35，并保留 LDIPOL/IDIPOL 设置。",
            },
        }

        tpl = templates.get(key)
        if not tpl:
            return
        patch = tpl.get("patch", {})
        summary = tpl.get("summary", "已应用模板。")
        self._apply_incar_patch(patch, message=f"[twist-template] {summary}")
        kspacing_val = tpl.get("kspacing")
        if kspacing_val is not None and hasattr(self, "tw_kspacing"):
            try:
                self.tw_kspacing.set(float(kspacing_val))
            except Exception:
                pass
        self._tw_append_log(summary)
        try:
            messagebox.showinfo(APP_NAME, summary + "\n如需进一步调整，可在输入页继续修改 INCAR。")
        except Exception:
            pass

    def _set_busy(self, busy: bool, message: str | None = None) -> None:
        """轻量设置 Busy 光标，并可选记录日志。"""
        try:
            self.configure(cursor="watch" if busy else "")
        except Exception:
            pass
        if message:
            self._tw_append_log(message)
        try:
            self.update_idletasks()
        except Exception:
            pass

    def _run_bg(self, target: Callable, *args, on_done=None, on_error=None):
        """在后台线程执行 target，完成后在主线程回调。"""
        import threading
        import queue

        q: "queue.Queue[tuple[str, object]]" = queue.Queue(maxsize=1)

        def _worker():
            try:
                res = target(*args)
                q.put(("ok", res))
            except Exception as exc:  # noqa: BLE001
                q.put(("err", exc))

        threading.Thread(target=_worker, daemon=True).start()

        def _poll():
            try:
                kind, payload = q.get_nowait()
            except Exception:
                try:
                    self.after(120, _poll)
                except Exception:
                    pass
                return
            if kind == "ok":
                if callable(on_done):
                    on_done(payload)
            else:
                if callable(on_error):
                    on_error(payload)

        self.after(120, _poll)
    # === CODEX END: twist/shift page UI ===

    # === CODEX BEGIN: twist/shift geometry core ===
    def _tw_pick_poscar(self, var):
        p = filedialog.askopenfilename(title="选择 POSCAR", filetypes=[("POSCAR","POSCAR*"),("All","*")])
        if p: var.set(p)

    def _tw_preview_once(self):
        """使用当前 θ = theta_a、u=(0,0) 快速构造一次并俯视预览。"""
        try:
            st, meta = self._tw_build_structure(
                Path(self.tw_top_path.get()), Path(self.tw_bot_path.get()),
                theta_deg=float(self.tw_theta_a.get()), ux=0.0, uy=0.0,
                vacuum=float(self.tw_vacuum.get()),
                interlayer=float(self.tw_interlayer.get()),
                allow_strain=float(self.tw_allow_strain.get())/100.0,
                search_limit=8
            )
        except Exception as e:
            messagebox.showerror(APP_NAME, f"预览失败：{e}")
            return
        self._tw_draw_topview(st, meta)
        self._tw_append_log(f"预览已更新：θ={meta.get('theta_deg', 0.0):.3f}°, u=(0.000,0.000)")

    def _tw_draw_topview(self, st, meta):
        """简单俯视：投影到 x-y，按层分色。"""
        try:
            from pymatgen.core import Structure  # noqa: F401
        except Exception:
            messagebox.showerror(APP_NAME, "未安装 pymatgen，无法预览结构。")
            return
        self.ax_tw.clear()
        # 取原子与层标签（site.properties.get("layer")）
        xs0, ys0, xs1, ys1 = [], [], [], []
        for site in st.sites:
            x,y,z = site.coords
            if site.properties.get("layer","bot") == "top":
                xs1.append(x); ys1.append(y)
            else:
                xs0.append(x); ys0.append(y)
        self.ax_tw.scatter(xs0, ys0, s=14, alpha=0.8, label="bottom")
        self.ax_tw.scatter(xs1, ys1, s=14, alpha=0.6, label="top")
        # 画边框（新晶格）
        M = st.lattice.matrix
        import numpy as _np
        a = _np.array(M[0]); b = _np.array(M[1])
        poly = _np.array([[0,0],[a[0],a[1]],[a[0]+b[0],a[1]+b[1]],[b[0],b[1]],[0,0]])
        self.ax_tw.plot(poly[:,0], poly[:,1], linestyle="--", linewidth=1.0)
        self.ax_tw.set_aspect("equal", adjustable="datalim")
        self.ax_tw.grid(True, linestyle=":", linewidth=0.6)
        self.ax_tw.legend()
        tdeg = meta.get("theta_deg")
        ux,uy = meta.get("ux"), meta.get("uy")
        self.ax_tw.set_title(f"θ={tdeg:.3f}°, u=({ux:.3f},{uy:.3f}), atoms={len(st)}")
        try:
            self.canvas_tw.draw()
            widget = self.canvas_tw.get_tk_widget()
            widget.update_idletasks()
            widget.update()
            self.update_idletasks()
        except Exception:
            pass

    def _tw_find_match(self, A_top_rot, A_bot, allow_strain: float, search_limit: int):
        """返回最优匹配 dict(S1,S2,mult_top,mult_bot,s,resid,area,atoms)。"""
        import numpy as np

        best: Optional[Dict[str, float]] = None
        # 优先使用 ZSL（若可用），失败则自动回退
        if HAS_ZSL:
            try:
                zsl = ZSLGenerator(
                    max_area_ratio=(1.0 + allow_strain),
                    max_misfit=allow_strain,
                    max_angle_diff=allow_strain * 10.0,
                )

                def to3(mat):
                    return np.array(
                        [
                            [mat[0, 0], mat[0, 1], 0.0],
                            [mat[1, 0], mat[1, 1], 0.0],
                            [0.0, 0.0, 1.0],
                        ],
                        dtype=float,
                    )

                matches = zsl.get_zsl_matches(to3(A_top_rot), to3(A_bot), max_search=search_limit)
                for m in matches:
                    S1 = np.array(m.get("matrix_1"), dtype=float)[:2, :2]
                    S2 = np.array(m.get("matrix_2"), dtype=float)[:2, :2]
                    if not (np.allclose(S1, np.rint(S1)) and np.allclose(S2, np.rint(S2))):
                        continue
                    S1 = np.rint(S1).astype(int)
                    S2 = np.rint(S2).astype(int)
                    det1 = float(np.linalg.det(S1))
                    det2 = float(np.linalg.det(S2))
                    if np.isclose(det1, 0.0) or np.isclose(det2, 0.0):
                        continue
                    mult_top = int(round(abs(det1)))
                    mult_bot = int(round(abs(det2)))
                    if mult_top <= 0 or mult_bot <= 0:
                        continue
                    T = A_top_rot @ S1
                    B = A_bot @ S2
                    denom = float(np.trace(T.T @ T))
                    if denom <= 0:
                        continue
                    s_star = float(np.trace(T.T @ B) / denom)
                    resid = np.linalg.norm(B - s_star * T, ord="fro") / max(
                        1.0, np.linalg.norm(B, ord="fro")
                    )
                    area = abs(float(np.linalg.det(B)))
                    cand = dict(
                        S1=S1,
                        S2=S2,
                        mult_top=mult_top,
                        mult_bot=mult_bot,
                        s=s_star,
                        resid=resid,
                        area=area,
                        atoms=-1,
                    )
                    if best is None or (resid, area) < (best["resid"], best["area"]):
                        best = cand
                if best is not None:
                    return best
            except Exception:
                pass

        # 回退到对角穷举
        best = None
        for n1 in range(1, search_limit + 1):
            for m1 in range(1, search_limit + 1):
                S1 = np.array([[n1, 0], [0, m1]], dtype=int)
                T = A_top_rot @ S1
                denom = float(np.trace(T.T @ T))
                if denom <= 0:
                    continue
                for n2 in range(1, search_limit + 1):
                    for m2 in range(1, search_limit + 1):
                        S2 = np.array([[n2, 0], [0, m2]], dtype=int)
                        B = A_bot @ S2
                        s_star = float(np.trace(T.T @ B) / denom)
                        if not (1.0 - allow_strain <= s_star <= 1.0 + allow_strain):
                            continue
                        resid = np.linalg.norm(B - s_star * T, ord="fro") / max(
                            1.0, np.linalg.norm(B, ord="fro")
                        )
                        area = abs(float(np.linalg.det(B)))
                        cand = dict(
                            S1=S1,
                            S2=S2,
                            mult_top=int(n1 * m1),
                            mult_bot=int(n2 * m2),
                            s=s_star,
                            resid=resid,
                            area=area,
                            atoms=-1,
                        )
                        if best is None or (resid, area) < (best["resid"], best["area"]):
                            best = cand
        return best

    def _estimate_atoms(self, st_top, st_bot, best):
        import numpy as np

        mult_top = best.get("mult_top")
        mult_bot = best.get("mult_bot")
        if mult_top is None:
            S1 = np.array(best.get("S1", np.eye(2, dtype=int)), dtype=float)
            mult_top = int(round(abs(np.linalg.det(S1))))
        if mult_bot is None:
            S2 = np.array(best.get("S2", np.eye(2, dtype=int)), dtype=float)
            mult_bot = int(round(abs(np.linalg.det(S2))))
        mult_top = max(1, int(mult_top))
        mult_bot = max(1, int(mult_bot))
        return len(st_top) * mult_top + len(st_bot) * mult_bot

    def _tw_build_structure(
        self,
        top_path: Path,
        bot_path: Path,
        theta_deg: float,
        ux: float,
        uy: float,
        vacuum: float,
        interlayer: float,
        allow_strain: float,
        search_limit: int = 8,
    ):
        """
        构造扭转(θ) + 滑移(u_x,u_y) 的双层结构，并尽量用对角超胞近似共格。
        返回 (Structure, meta)；如果找不到低应变解，抛出异常。
        """
        if not HAS_PYMATGEN or not HAS_NUMPY:
            raise RuntimeError("需要 pymatgen + numpy")
        from pymatgen.core import Structure, Lattice
        import numpy as np

        if not top_path.exists() or not bot_path.exists():
            raise FileNotFoundError("POSCAR 路径不存在")

        st_top = Structure.from_file(str(top_path))
        st_bot = Structure.from_file(str(bot_path))

        # 取 in-plane 基矢（假定 z 为法向；若用户 POSCAR 不是这样，应先在外部对齐）
        A_bot = np.array(st_bot.lattice.matrix[:2, :2])  # (2,2)
        A_top = np.array(st_top.lattice.matrix[:2, :2])  # (2,2)

        # 绕 z 旋转上层 in-plane 基矢
        th = np.deg2rad(theta_deg)
        Rz = np.array([[np.cos(th), -np.sin(th)],
                       [np.sin(th),  np.cos(th)]], dtype=float)
        A_top_rot = Rz @ A_top  # (2,2)

        best = self._tw_find_match(A_top_rot, A_bot, allow_strain, search_limit)

        if best is None:
            raise RuntimeError("在给定容许应变与搜索限内未找到可接受的超胞匹配。")

        atom_est = self._estimate_atoms(st_top, st_bot, best)
        best["atoms"] = atom_est
        gamma_limit = int(self.tw_gamma_atom_threshold.get()) if hasattr(self, "tw_gamma_atom_threshold") else 500
        if atom_est > gamma_limit * 8:
            raise RuntimeError(
                f"预计原子数≈{atom_est}，过大；请调大步长或缩小角度/网格。"
            )

        # 构造下层超胞
        S2 = np.array(best.get("S2"), dtype=int)
        if S2.shape != (2, 2):
            raise ValueError("匹配结果缺少有效的下层超胞矩阵")
        S_bot = np.eye(3, dtype=int)
        S_bot[:2, :2] = S2
        bot_sc = st_bot.copy()
        bot_sc.make_supercell(S_bot)

        # 构造上层超胞 + 旋转 + 等比例变形
        S1 = np.array(best.get("S1"), dtype=int)
        if S1.shape != (2, 2):
            raise ValueError("匹配结果缺少有效的上层超胞矩阵")
        S_top = np.eye(3, dtype=int)
        S_top[:2, :2] = S1
        top_sc = st_top.copy()
        top_sc.make_supercell(S_top)

        # 先设一个临时晶格做笛卡尔变换
        # 上层：旋转 + in-plane 等比例 s
        s = float(best["s"])
        # 取上层原笛卡尔 → 应用 Rz 与 s
        t_cart = np.array([site.coords for site in top_sc.sites], dtype=float)  # (Nt,3)
        t_cart[:,:2] = (Rz @ t_cart[:,:2].T).T * s

        # 最终公共 in-plane 晶格使用 B（下层超胞矩阵 B）
        B = A_bot @ S2
        # 组 3×3 晶格矩阵：c 轴由层间距 + 真空决定
        interlayer = float(interlayer)
        if interlayer <= 0:
            raise ValueError("层间距需为正数")
        c_len = float(vacuum) + interlayer
        L_final = np.array([[B[0,0], B[0,1], 0.0],
                            [B[1,0], B[1,1], 0.0],
                            [0.0,    0.0,    c_len]], dtype=float)

        # 把上下层点坐标映射到最终晶格分数坐标
        def cart_to_frac(L, r):
            return np.linalg.solve(L.T, r.T).T  # (N,3)

        b_cart = np.array([site.coords for site in bot_sc.sites], dtype=float)
        # 先把下层坐标重映射到以 B 为 in-plane 的晶格（原 in-plane 已经是 A_bot*n2,m2；z 保持）
        # bot_sc 现有晶格：
        # 先把它的 frac → cart（已是 cart），我们只需要映射到 L_final 的 frac：
        # 分层放置在 z：底层位于真空中心偏下，上层位于其上 interlayer 处
        z_bot = 0.5 * c_len - 0.5 * interlayer
        z_top = z_bot + interlayer

        # 以各层自身重心为参考保持层内厚度
        b_center = float(np.mean(b_cart[:, 2])) if len(b_cart) else 0.0
        t_center = float(np.mean(t_cart[:, 2])) if len(t_cart) else 0.0
        b_cart[:, 2] = b_cart[:, 2] - b_center + z_bot
        t_cart[:, 2] = t_cart[:, 2] - t_center + z_top

        b_frac_final = cart_to_frac(L_final, b_cart)
        t_frac_final = cart_to_frac(L_final, t_cart)

        # 施加滑移（分数坐标，沿 a1,a2）
        t_frac_final[:,0] = (t_frac_final[:,0] + ux) % 1.0
        t_frac_final[:,1] = (t_frac_final[:,1] + uy) % 1.0

        # 合并为一个 Structure
        species = []
        frac = []
        props = []
        for site, f in zip(bot_sc.sites, b_frac_final):
            species.append(site.species)
            frac.append(f.tolist())
            props.append({"layer":"bot"})
        for site, f in zip(top_sc.sites, t_frac_final):
            species.append(site.species)
            frac.append(f.tolist())
            props.append({"layer":"top"})

        st_final = Structure(Lattice(L_final), species, frac, site_properties=props)

        mult_top = int(best.get("mult_top") or round(abs(np.linalg.det(S1))))
        mult_bot = int(best.get("mult_bot") or round(abs(np.linalg.det(S2))))
        meta = dict(
            theta_deg=float(theta_deg),
            ux=float(ux),
            uy=float(uy),
            atoms=len(st_final),
            strain_scale=s,
            resid=best["resid"],
            vacuum=float(vacuum),
            interlayer=interlayer,
            supercell_top=np.array(best["S1"], dtype=int).tolist(),
            supercell_bot=np.array(best["S2"], dtype=int).tolist(),
            mult_top=mult_top,
            mult_bot=mult_bot,
        )
        if np.allclose(S1, np.diag(np.diag(S1))):
            meta["n1"] = int(S1[0, 0])
            meta["m1"] = int(S1[1, 1])
        if np.allclose(S2, np.diag(np.diag(S2))):
            meta["n2"] = int(S2[0, 0])
            meta["m2"] = int(S2[1, 1])
        return st_final, meta
    # === CODEX END: twist/shift geometry core ===

    # === CODEX BEGIN: generate twist/shift tasks ===
    def _tw_canonical_registry(self, ux: float, uy: float, lattice2x2):
        """规约 (ux, uy) 到具有代表性的等价点以减少重复。"""
        try:
            import numpy as _np
            import math as _math
        except Exception:
            return (float(ux % 1.0), float(uy % 1.0))

        vec_a = _np.asarray(lattice2x2)[:, 0]
        vec_b = _np.asarray(lattice2x2)[:, 1]
        if vec_a.shape[0] != 2 or vec_b.shape[0] != 2:
            return (float(ux % 1.0), float(uy % 1.0))

        a_len = _np.linalg.norm(vec_a)
        b_len = _np.linalg.norm(vec_b)
        if a_len == 0 or b_len == 0:
            return (float(ux % 1.0), float(uy % 1.0))

        cosang = _np.clip(_np.dot(vec_a, vec_b) / (a_len * b_len), -1.0, 1.0)
        ang = _math.degrees(_math.acos(cosang))

        ux_mod = float(ux % 1.0)
        uy_mod = float(uy % 1.0)

        def _rotate_candidates(order):
            cands = []
            for k in range(order):
                th = 2 * _math.pi * k / order
                rot = _np.array([[_math.cos(th), -_math.sin(th)], [_math.sin(th), _math.cos(th)]])
                u = (rot @ _np.array([ux_mod, uy_mod])) % 1.0
                cands.append((float(u[0]), float(u[1])))
            return min(cands)

        if abs(a_len - b_len) / max(a_len, b_len) < 0.02:
            if abs(ang - 60.0) < 2.0:
                return _rotate_candidates(6)
            if abs(ang - 90.0) < 2.0:
                return _rotate_candidates(4)

        return (ux_mod, uy_mod)

    def _tw_generate(self, single: bool):
        """在后台生成单例或批量遍历任务目录。"""
        try:
            theta_a = float(self.tw_theta_a.get())
            theta_b = float(self.tw_theta_b.get())
            theta_step = float(self.tw_theta_step.get())
            vacuum = float(self.tw_vacuum.get())
            interlayer = float(self.tw_interlayer.get())
            allow_strain = float(self.tw_allow_strain.get()) / 100.0
            kspacing = float(self.tw_kspacing.get())
            ux_steps = int(self.tw_ux_steps.get())
            uy_steps = int(self.tw_uy_steps.get())
            max_tasks = int(self.tw_max_tasks.get())
            gamma_center = bool(self.tw_gamma_center.get())
            force_gamma_only = bool(self.tw_force_gamma_only.get())
            gamma_threshold = int(self.tw_gamma_atom_threshold.get())
        except Exception as e:
            messagebox.showerror(APP_NAME, f"参数错误：{e}")
            return

        twist_enabled = bool(self.tw_enable_twist.get()) if hasattr(self, "tw_enable_twist") else True
        slide_enabled = bool(self.tw_enable_slide.get()) if hasattr(self, "tw_enable_slide") else True
        issues = []
        if vacuum <= 0:
            issues.append("真空(Å) 必须为正数。")
        if interlayer <= 0:
            issues.append("层间距(Å) 必须为正数。")
        if allow_strain < 0:
            issues.append("容许应变(%) 不能为负值。")
        if kspacing <= 0:
            issues.append("KSPACING 需为正数。")
        if max_tasks <= 0:
            issues.append("任务上限需为正整数。")
        if twist_enabled and not single and abs(theta_b - theta_a) > 1e-9 and theta_step <= 0:
            issues.append("扭转角步长需为正数，以便生成多角度扫描。")
        if slide_enabled and ux_steps <= 0:
            issues.append("u_x 步数需为正整数。")
        if slide_enabled and uy_steps <= 0:
            issues.append("u_y 步数需为正整数。")
        if issues:
            messagebox.showwarning(APP_NAME, "\n".join(issues))
            self._tw_append_log("参数校验失败：" + "；".join(issues))
            return

        top_p = Path(self.tw_top_path.get())
        bot_p = Path(self.tw_bot_path.get())
        if not top_p.exists() or not bot_p.exists():
            messagebox.showwarning(APP_NAME, "请先选择上/下层 POSCAR")
            self._tw_append_log("未找到上/下层 POSCAR，生成流程已中止。")
            return

        project_path = self.current_project_path()
        autorun = bool(self.tw_autorun.get()) if hasattr(self, "tw_autorun") else False

        incar_src = project_path / "INCAR"
        if incar_src.exists():
            incar_text = read_text(incar_src)
        else:
            try:
                incar_text = self.incar_text.get("1.0", tk.END)
            except Exception:
                incar_text = ""

        single_override = getattr(self, "_tw_single_override", None)
        single_ux = None
        single_uy = None
        if single and isinstance(single_override, tuple) and len(single_override) == 2:
            try:
                single_ux = float(single_override[0])
                single_uy = float(single_override[1])
            except Exception:
                single_ux = single_override[0]
                single_uy = single_override[1]
        params = dict(
            single=single,
            theta_a=theta_a,
            theta_b=theta_b,
            theta_step=theta_step,
            vacuum=vacuum,
            interlayer=interlayer,
            allow_strain=allow_strain,
            kspacing=kspacing,
            ux_steps=ux_steps,
            uy_steps=uy_steps,
            max_tasks=max_tasks,
            twist_enabled=twist_enabled,
            slide_enabled=slide_enabled,
            top_path=top_p,
            bot_path=bot_p,
            project_path=project_path,
            incar_text=incar_text,
            autorun=autorun,
            gamma_center=gamma_center,
            force_gamma_only=force_gamma_only,
            gamma_threshold=gamma_threshold,
            single_ux=single_ux,
            single_uy=single_uy,
        )

        busy_msg = "正在生成单例任务…" if single else "正在批量生成 twist_sweep 任务…"
        self._set_busy(True, busy_msg)

        def _on_done(result: dict):
            self._set_busy(False)
            if not isinstance(result, dict):
                return
            for msg in result.get("logs", []):
                self._tw_append_log(msg)
            preview = result.get("preview")
            if preview:
                try:
                    st_obj, meta = preview
                    self._tw_draw_topview(st_obj, meta)
                except Exception as exc:  # noqa: BLE001
                    self._tw_append_log(f"预览绘制失败：{exc}")
            info_msg = result.get("info_msg")
            if info_msg:
                messagebox.showinfo(APP_NAME, info_msg)
            warn_msg = result.get("warn_msg")
            if warn_msg:
                messagebox.showwarning(APP_NAME, warn_msg)
            self.refresh_project_overview()
            self._tw_update_tw_post_hint()

        def _on_error(exc: Exception):
            self._set_busy(False)
            self._tw_append_log(f"生成失败：{exc}")
            messagebox.showerror(APP_NAME, f"生成失败：{exc}")

        if single:
            self._tw_single_override = None
        self._run_bg(self._tw_generate_core, params, on_done=_on_done, on_error=_on_error)

    def _tw_generate_core(self, params: dict) -> dict:
        """后台执行的核心逻辑：返回日志与结果摘要。"""
        logs: list[str] = []
        single = params["single"]
        theta_a = float(params["theta_a"])
        theta_b = float(params["theta_b"])
        theta_step = float(params["theta_step"])
        vacuum = float(params["vacuum"])
        interlayer = float(params["interlayer"])
        allow_strain = float(params["allow_strain"])
        kspacing = float(params["kspacing"])
        ux_steps = int(params["ux_steps"])
        uy_steps = int(params["uy_steps"])
        max_tasks = int(params["max_tasks"])
        twist_enabled = bool(params["twist_enabled"])
        slide_enabled = bool(params["slide_enabled"])
        top_p: Path = Path(params["top_path"])
        bot_p: Path = Path(params["bot_path"])
        project_path: Path = Path(params["project_path"])
        incar_text: str = params.get("incar_text", "")
        autorun = bool(params.get("autorun", False))
        gamma_center = bool(params.get("gamma_center", True))
        force_gamma_only = bool(params.get("force_gamma_only", False))
        try:
            gamma_threshold = int(params.get("gamma_threshold", 500))
        except Exception:
            gamma_threshold = 500
        single_ux = params.get("single_ux")
        single_uy = params.get("single_uy")
        if gamma_threshold <= 0:
            gamma_threshold = 500

        import importlib

        np_mod = None
        if HAS_NUMPY:
            try:
                np_mod = importlib.import_module("numpy")
            except Exception:  # noqa: BLE001
                np_mod = None

        if single or not twist_enabled:
            thetas = [theta_a]
        else:
            thetas = self._tw_linspace(theta_a, theta_b, step=theta_step)

        if single:
            try:
                ux_val = float(single_ux) if single_ux is not None else 0.0
            except Exception:
                ux_val = single_ux or 0.0
            try:
                uy_val = float(single_uy) if single_uy is not None else 0.0
            except Exception:
                uy_val = single_uy or 0.0
            uxs = [ux_val]
            uys = [uy_val]
        elif not slide_enabled:
            uxs = [0.0]
            uys = [0.0]
        else:
            uxs = [i / ux_steps for i in range(ux_steps)]
            uys = [j / uy_steps for j in range(uy_steps)]

        lattice2x2 = None
        if (not single) and slide_enabled and HAS_PYMATGEN and HAS_NUMPY:
            try:
                from pymatgen.core import Structure as _Structure

                st_bot_sample = _Structure.from_file(str(bot_p))
                if np_mod is None:
                    raise RuntimeError("numpy 未可用")
                lattice2x2 = np_mod.array(st_bot_sample.lattice.matrix[:2, :2])
            except Exception:
                lattice2x2 = None

        combos: list[tuple[float, float, float]] = []
        seen: set[tuple[float, float, float]] = set()
        for th in thetas:
            for ux in uxs:
                for uy in uys:
                    if slide_enabled and lattice2x2 is not None:
                        cu = self._tw_canonical_registry(ux, uy, lattice2x2)
                    else:
                        cu = (float(ux % 1.0), float(uy % 1.0))
                    key = (round(th, 6), round(cu[0], 6), round(cu[1], 6))
                    if key in seen:
                        continue
                    seen.add(key)
                    combos.append((th, float(cu[0]), float(cu[1])))

        if single and (single_ux is not None or single_uy is not None):
            try:
                logs.append(f"单构型模式：使用滑移 u=({uxs[0]:.3f},{uys[0]:.3f})")
            except Exception:
                logs.append("单构型模式：使用指定滑移 u 值。")
        logs.append(
            f"开始生成：θ 数量={len(thetas)}, u_x 数量={len(uxs)}, u_y 数量={len(uys)}，总计 {len(combos)} 个组合"
        )
        if len(combos) > max_tasks:
            raise RuntimeError(f"任务数 {len(combos)} > 上限 {max_tasks}，请调整步长或网格。")

        root = project_path / "twist_sweep"
        root.mkdir(parents=True, exist_ok=True)

        made = 0
        skipped = 0
        last_preview: tuple | None = None
        warn_msg = None
        auto_gamma_dirs: list[str] = []

        for th, ux, uy in combos:
            name = f"theta_{th:+06.2f}_ux_{ux:0.3f}_uy_{uy:0.3f}".replace("+", "")
            workdir = root / name
            workdir.mkdir(parents=True, exist_ok=True)
            logs.append(f"构建 θ={th:.3f}°, u=({ux:.3f},{uy:.3f}) → {workdir.name}")
            try:
                st, meta = self._tw_build_structure(
                    top_p,
                    bot_p,
                    th,
                    ux,
                    uy,
                    vacuum,
                    interlayer,
                    allow_strain,
                    search_limit=8,
                )
            except Exception as exc:  # noqa: BLE001
                write_text(workdir / "FAILED.txt", f"{exc}\n")
                skipped += 1
                logs.append(
                    f"构建失败：θ={th:.3f}°, u=({ux:.3f},{uy:.3f})，原因：{exc}"
                )
                continue

            try:
                st.to(fmt="poscar", filename=str(workdir / "POSCAR"))
            except Exception as exc:  # noqa: BLE001
                write_text(workdir / "FAILED.txt", f"写 POSCAR 失败: {exc}\n")
                skipped += 1
                logs.append(f"写入 POSCAR 失败：{exc}")
                continue

            gamma_only = bool(force_gamma_only)
            if not gamma_only and gamma_threshold > 0:
                gamma_only = len(st) >= gamma_threshold
            if gamma_only:
                auto_gamma_dirs.append(workdir.name)

            patch = {
                "ISYM": "0",
                "LWAVE": ".FALSE.",
                "LCHARG": ".TRUE.",
                "LDIPOL": ".TRUE.",
                "IDIPOL": "3",
            }
            if not gamma_only:
                patch["KSPACING"] = f"{kspacing}"
            patch["KGAMMA"] = ".TRUE." if gamma_center else ".FALSE."

            incar_new = self._update_incar_text(incar_text, patch)
            write_text(workdir / "INCAR", incar_new)

            kpoints_path = workdir / "KPOINTS"
            if gamma_only:
                kpt_txt = "\n".join([
                    "Gamma-only mesh",
                    "0",
                    "Gamma",
                    "1 1 1",
                    "0 0 0",
                    "",
                ])
                atomic_write_text(kpoints_path, kpt_txt, encoding="utf-8")
            else:
                if kpoints_path.exists():
                    try:
                        kpoints_path.unlink()
                    except Exception:
                        pass

            pot = project_path / "POTCAR"
            if pot.exists():
                try:
                    shutil.copyfile(pot, workdir / "POTCAR")
                except Exception:
                    pass

            meta_path = workdir / "meta.json"
            meta2 = dict(meta)
            meta2.update(
                dict(
                    path=str(workdir),
                    gamma_only=bool(gamma_only),
                    gamma_center=bool(gamma_center),
                )
            )
            if not gamma_only:
                meta2["kspacing"] = float(kspacing)
            atomic_write_text(meta_path, json.dumps(meta2, ensure_ascii=False, indent=2), encoding="utf-8")

            made += 1
            last_preview = (st, meta2)
            logs.append(f"完成：{workdir.name}，原子数 {len(st)}")

            if autorun:
                try:
                    for script in ("run_local.sh", "run_slurm.sh"):
                        src = project_path / script
                        if src.exists():
                            shutil.copyfile(src, workdir / script)
                            os.chmod(workdir / script, 0o755)
                    run_script = workdir / "run_local.sh"
                    if run_script.exists():
                        subprocess.Popen(
                            ["bash", "-lc", f"cd '{workdir}' && ./run_local.sh"],
                            stdout=subprocess.DEVNULL,
                            stderr=subprocess.DEVNULL,
                            start_new_session=True,
                        )
                        logs.append(f"已触发自动运行：{workdir.name}/run_local.sh")
                except Exception as exc:  # noqa: BLE001
                    warn_msg = f"自动运行触发失败：{workdir.name}，原因：{exc}"
                    logs.append(warn_msg)

        info_msg = f"生成完成：成功 {made}，跳过 {skipped}（详见各子目录）。输出根目录：{root}"
        logs.append(f"生成完成：成功 {made}，跳过 {skipped}，输出目录 {root}")

        if auto_gamma_dirs:
            sample = ", ".join(auto_gamma_dirs[:4])
            msg = f"{len(auto_gamma_dirs)} 个任务因原子数较大已设置为仅 Γ 点：{sample}" + (" …" if len(auto_gamma_dirs) > 4 else "")
            logs.append(msg)
            if warn_msg is None:
                warn_msg = msg

        return {
            "logs": logs,
            "info_msg": info_msg,
            "warn_msg": warn_msg,
            "preview": last_preview,
        }

    def _tw_linspace(self, a: float, b: float, step: float) -> list:
        if step <= 0: return [a]
        out = []
        x = a
        if b >= a:
            while x <= b + 1e-9:
                out.append(round(x, 10)); x += step
        else:
            while x >= b - 1e-9:
                out.append(round(x, 10)); x -= step
        # 防止小数误差重复
        return sorted(list(dict.fromkeys(out)))
    # === CODEX END: generate twist/shift tasks ===

    # === CODEX BEGIN: collect sweep results ===
    def _tw_collect_results_btn(self):
        project_path = self.current_project_path()
        root = project_path / "twist_sweep"
        self._set_busy(True, "正在汇总 sweep 结果…")

        def _on_done(result: dict):
            self._set_busy(False)
            if not isinstance(result, dict):
                return
            for msg in result.get("logs", []):
                self._tw_append_log(msg)
            info_msg = result.get("info_msg")
            if info_msg:
                messagebox.showinfo(APP_NAME, info_msg)

        def _on_error(exc: Exception):
            self._set_busy(False)
            missing_path = root / "results.csv"
            if isinstance(exc, FileNotFoundError):
                msg = f"未找到 {missing_path}，请先完成计算或启用演示模式。"
                self._tw_append_log(msg)
                messagebox.showwarning(APP_NAME, msg)
            else:
                self._tw_append_log(f"结果汇总失败：{exc}")
                messagebox.showerror(APP_NAME, f"结果汇总失败：{exc}")

        self._run_bg(self._tw_collect_results_core, root, True, on_done=_on_done, on_error=_on_error)

    def _tw_collect_results(self, *, show_ui: bool = True, root: Path | None = None):
        project_path = self.current_project_path()
        root = root or (project_path / "twist_sweep")
        try:
            result = self._tw_collect_results_core(root, allow_demo=self.demo_mode)
        except FileNotFoundError as exc:
            if show_ui:
                missing = root / "results.csv"
                messagebox.showwarning(APP_NAME, f"未找到 {missing}，请先完成计算或启用演示模式。")
                self._tw_append_log(str(exc))
            raise
        except Exception as exc:
            if show_ui:
                messagebox.showerror(APP_NAME, f"汇总结果失败：{exc}")
                self._tw_append_log(f"汇总失败：{exc}")
            raise
        else:
            if show_ui:
                for msg in result.get("logs", []):
                    self._tw_append_log(msg)
                info_msg = result.get("info_msg")
                if info_msg:
                    messagebox.showinfo(APP_NAME, info_msg)
        return result

    def _tw_collect_results_core(self, root: Path, allow_demo: bool = False) -> dict:
        """遍历 twist_sweep/* 子目录，收集 gap / total energy / 备注，导出 CSV。"""
        logs: list[str] = []
        root = Path(root)
        if not root.exists():
            if allow_demo and self.demo_mode:
                root.mkdir(parents=True, exist_ok=True)
                csv_path = self._tw_write_demo_results(root)
                logs.append(f"演示模式：已生成示例 twist_sweep/results.csv → {csv_path}")
                return {"logs": logs, "info_msg": f"演示模式：已生成示例 results.csv → {csv_path}", "csv_path": csv_path, "rows": []}
            raise FileNotFoundError(f"未找到目录 {root}")

        logs.append("开始汇总 sweep 结果…")
        rows = []
        for sub in sorted(root.iterdir()):
            if not sub.is_dir():
                continue
            theta = ux = uy = None
            try:
                m = re.search(r"theta_([0-9.]+)_ux_([0-9.]+)_uy_([0-9.]+)", sub.name)
                if m:
                    theta = float(m.group(1))
                    ux = float(m.group(2))
                    uy = float(m.group(3))
            except Exception:
                pass

            note = ""
            failf = sub / "FAILED.txt"
            if failf.exists():
                try:
                    note_text = read_text(failf).strip()
                except Exception:
                    note_text = ""
                if note_text:
                    note = "FAILED: " + note_text.splitlines()[0][:120]

            gap_eV = None
            totalE = None
            vxml = sub / "vasprun.xml"
            if vxml.exists():
                try:
                    from pymatgen.io.vasp.outputs import Vasprun

                    v = Vasprun(str(vxml), parse_eigen=True, parse_projected_eigen=False)
                    bg = v.get_band_structure().get_band_gap()
                    gap_eV = float(bg.get("energy")) if bg else None
                    totalE = float(v.final_energy) if v.final_energy is not None else None
                except Exception as exc:
                    if not note:
                        note = f"vasprun parse err: {exc}"
            if gap_eV is None:
                gap_est, _ = self._tw_gap_from_eigenval(sub / "EIGENVAL", sub / "OUTCAR")
                if gap_est is not None:
                    gap_eV = gap_est
            if totalE is None:
                try:
                    outcar = read_text(sub / "OUTCAR")
                    mt = re.search(r"free\s+energy\s+TOTEN\s*=\s*([-\d.Ee+]+)", outcar, flags=re.I)
                    if mt:
                        totalE = float(mt.group(1))
                except Exception:
                    pass

            rows.append(
                dict(path=sub.name, theta=theta, ux=ux, uy=uy, gap_eV=gap_eV, totalE=totalE, note=note)
            )

        import csv

        csv_path = root / "results.csv"
        with csv_path.open("w", encoding="utf-8", newline="") as f:
            writer = csv.writer(f, quoting=csv.QUOTE_MINIMAL)
            writer.writerow(["theta", "ux", "uy", "gap", "E", "path", "note"])
            for r in rows:
                theta = r.get("theta")
                ux = r.get("ux")
                uy = r.get("uy")
                gap = r.get("gap_eV")
                energy = r.get("totalE")
                note = (r.get("note") or "").replace("\r", " ").replace("\n", " ").strip()

                def _fmt(val: Any) -> str:
                    if val is None:
                        return ""
                    if isinstance(val, float):
                        if math.isnan(val):
                            return ""
                        return f"{val:.6f}"
                    return str(val)

                writer.writerow([
                    _fmt(theta),
                    _fmt(ux),
                    _fmt(uy),
                    _fmt(gap),
                    _fmt(energy),
                    r.get("path", ""),
                    note,
                ])

        info_msg = f"结果汇总完成：共 {len(rows)} 条记录，输出 {csv_path}"
        logs.append(info_msg)
        return {"logs": logs, "info_msg": info_msg, "csv_path": csv_path, "rows": rows}

    def _tw_gap_from_eigenval(self, eig_path: Path, outcar_path: Path):
        """非常规兜底：从 EIGENVAL + OUTCAR(E_F) 粗略估算带隙。返回 (gap, is_direct?)；失败返回 (None,None)。"""
        try:
            if not eig_path.exists(): return (None, None)
            ef = None
            try:
                txt = read_text(outcar_path)
                m = re.search(r"(?mi)E-fermi\s*:\s*([-\d.Ee+]+)", txt)
                if m: ef = float(m.group(1))
            except Exception:
                pass
            lines = read_text(eig_path).splitlines()
            # 第6行包含 NKPTS, NBANDS
            nk, nb = map(int, lines[5].split()[:2])
            i = 6
            energies = []
            occs = []
            for _ in range(nk):
                # 跳 k 行前的空行
                while i < len(lines) and not lines[i].strip():
                    i += 1
                i += 1  # 跳 kx ky kz w
                ks = []
                os = []
                for b in range(nb):
                    parts = lines[i].split()
                    e = float(parts[1])
                    o = float(parts[2]) if len(parts) > 2 else 0.0
                    ks.append(e); os.append(o); i += 1
                energies.append(ks); occs.append(os)
            # 估计 VBM/CBM（以占据 0.5 为界，若有 EF 则先减 EF）
            if ef is not None:
                energies = [[e-ef for e in ks] for ks in energies]
            vbm = max(max(e for e,o in zip(ks,os) if o > 0.5) for ks,os in zip(energies,occs))
            cbm = min(min(e for e,o in zip(ks,os) if o < 0.5) for ks,os in zip(energies,occs))
            gap = max(0.0, cbm - vbm)
            return (gap, None)
        except Exception:
            return (None, None)
    # === CODEX END: collect sweep results ===

    # === 2D 滑移/扭转载：页面 + 演示数据 + 可视化（最小可用版） =====================

    def _build_twistshift_results_page(self, parent):
        """二维材料·滑移/扭转（演示/载入扫参）"""
        frame = ttk.Frame(parent, padding=8)

        # ---- 变量与状态 ----
        if not hasattr(self, "tw_top_path"):
            self.tw_top_path = tk.StringVar(value="")
        if not hasattr(self, "tw_bot_path"):
            self.tw_bot_path = tk.StringVar(value="")
        self.tw_dir = tk.StringVar(value="")
        self.tw_theta = tk.DoubleVar(value=0.0)
        self.tw_ux = tk.DoubleVar(value=0.0)
        self.tw_uy = tk.DoubleVar(value=0.0)
        self.tw_results = []  # 全部结果
        self.tw_filtered = []  # 过滤到某个 theta 的切片
        self.tw_cbar = None  # 记录 colorbar 以便重绘时清理

        # ---- 顶部：文件选择与动作 ----
        top = ttk.Frame(frame)
        top.pack(fill=tk.X)
        ttk.Label(top, text="上层 POSCAR:").pack(side=tk.LEFT)
        ttk.Entry(top, textvariable=self.tw_top_path, width=48).pack(side=tk.LEFT, padx=4)
        ttk.Button(top, text="选择…", command=self._tw_choose_top).pack(side=tk.LEFT)

        ttk.Label(top, text="  下层 POSCAR:").pack(side=tk.LEFT, padx=(8, 0))
        ttk.Entry(top, textvariable=self.tw_bot_path, width=48).pack(side=tk.LEFT, padx=4)
        ttk.Button(top, text="选择…", command=self._tw_choose_bot).pack(side=tk.LEFT)

        # 第二行：扫参目录 + 快捷按钮
        row2 = ttk.Frame(frame)
        row2.pack(fill=tk.X, pady=(6, 2))
        ttk.Label(row2, text="扫参目录:").pack(side=tk.LEFT)
        ttk.Entry(row2, textvariable=self.tw_dir, width=64).pack(side=tk.LEFT, padx=4)
        ttk.Button(row2, text="选择目录…", command=self._tw_choose_dir).pack(side=tk.LEFT)

        ttk.Button(row2, text="载入目录", command=lambda: self._tw_load_dir(self.tw_dir.get())).pack(
            side=tk.LEFT, padx=6
        )

        # 第三行：筛选与操作
        row3 = ttk.Frame(frame)
        row3.pack(fill=tk.X, pady=(2, 6))
        ttk.Label(row3, text="θ(°)：").pack(side=tk.LEFT)
        tk.Spinbox(row3, from_=0.0, to=30.0, increment=0.5, textvariable=self.tw_theta, width=6).pack(side=tk.LEFT)
        ttk.Label(row3, text="  ux：").pack(side=tk.LEFT)
        tk.Spinbox(row3, from_=0.0, to=1.0, increment=0.05, textvariable=self.tw_ux, width=6).pack(side=tk.LEFT)
        ttk.Label(row3, text="  uy：").pack(side=tk.LEFT)
        tk.Spinbox(row3, from_=0.0, to=1.0, increment=0.05, textvariable=self.tw_uy, width=6).pack(side=tk.LEFT)
        ttk.Button(row3, text="按 θ 过滤并重绘", command=self._tw_refilter_and_redraw).pack(side=tk.LEFT, padx=8)
        ttk.Button(row3, text="导出当前切片CSV", command=self._tw_export_slice_csv).pack(side=tk.LEFT, padx=4)
        self.tw_info = ttk.Label(row3, text="—")
        self.tw_info.pack(side=tk.LEFT, padx=8)

        # ---- 主体左右：表格 + 图 ----
        body = ttk.PanedWindow(frame, orient=tk.HORIZONTAL)
        body.pack(fill=tk.BOTH, expand=True)

        # 左：结果表
        left = ttk.Frame(body)
        body.add(left, weight=1)
        cols = ("theta", "ux", "uy", "gap", "E", "path")
        self.tw_tree = ttk.Treeview(left, columns=cols, show="headings", height=16)
        for c, w in zip(cols, (70, 60, 60, 70, 70, 240)):
            self.tw_tree.heading(c, text=c)
            self.tw_tree.column(c, width=w, anchor=tk.CENTER if c != "path" else tk.W)
        self.tw_tree.pack(fill=tk.BOTH, expand=True)
        self.tw_tree.bind("<<TreeviewSelect>>", self._on_tw_tree_select)

        # 右：Matplotlib 区
        right = ttk.Frame(body)
        body.add(right, weight=1)
        self.tw_fig = Figure(figsize=(5.6, 3.6))
        self.tw_ax = self.tw_fig.add_subplot(111)
        self.tw_canvas = FigureCanvasTkAgg(self.tw_fig, master=right)
        self.tw_canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)

        return frame

    # --- 目录/文件选择 ---
    def _tw_choose_top(self):
        p = filedialog.askopenfilename(title="选择上层 POSCAR", filetypes=[("POSCAR", "POSCAR"), ("All", "*")])
        if p:
            self.tw_top_path.set(p)

    def _tw_choose_bot(self):
        p = filedialog.askopenfilename(title="选择下层 POSCAR", filetypes=[("POSCAR", "POSCAR"), ("All", "*")])
        if p:
            self.tw_bot_path.set(p)

    def _tw_choose_dir(self):
        d = filedialog.askdirectory(title="选择扫参目录")
        if d:
            self.tw_dir.set(d)
            self._tw_load_dir(d)

    def _tw_write_demo_results(self, out_dir: Path) -> Path:
        """把内置 DEMO_TWIST_RESULTS 写到 results.csv"""
        out_dir = Path(out_dir)
        out_dir.mkdir(parents=True, exist_ok=True)
        csv_path = out_dir / "results.csv"
        with csv_path.open("w", encoding="utf-8") as f:
            f.write("theta,ux,uy,gap,E,path\n")
            for r in DEMO_TWIST_RESULTS:
                f.write(f"{r['theta']},{r['ux']},{r['uy']},{r['gap']},{r['E']},{r['path']}\n")
        readme = out_dir / "README.txt"
        write_text(
            readme,
            "本目录为演示生成的二维材料扭转/滑移扫参结果（CSV）。\n列含义：theta(°), ux, uy, gap(eV), E(eV), path\n",
        )
        return csv_path

    # --- 载入目录 ---
    def _tw_load_dir(self, dpath: str | Path):
        d = Path(dpath)
        if not d.exists():
            messagebox.showwarning(APP_NAME, f"目录不存在：{d}")
            return
        csv_path = d / "results.csv"
        rows: list[dict] = []
        if csv_path.exists():
            try:
                import csv

                with csv_path.open("r", encoding="utf-8", errors="ignore") as f:
                    reader = csv.DictReader(f)
                    if reader.fieldnames is None:
                        raise ValueError("CSV 缺少表头")
                    for rec in reader:
                        rows.append(self._tw_row_from_dict(rec))
            except Exception as e:
                messagebox.showerror(APP_NAME, f"读取 {csv_path} 失败：{e}")
                return
        else:
            for jf in sorted(d.glob("*.json*")):
                try:
                    txt = jf.read_text(encoding="utf-8", errors="ignore").strip()
                    if not txt:
                        continue
                    if txt.startswith("{"):
                        data = json.loads(txt)
                        rows.append(self._tw_row_from_dict(data))
                    else:
                        for line in txt.splitlines():
                            line = line.strip()
                            if not line:
                                continue
                            data = json.loads(line)
                            rows.append(self._tw_row_from_dict(data))
                except Exception:
                    continue

        rows = [r for r in rows if r]
        if not rows:
            messagebox.showwarning(APP_NAME, f"未在 {d} 发现可用的演示/扫参数据（results.csv 或 json/jsonl）。")
            return

        self.tw_results = rows
        thetas = sorted({round(r["theta"], 6) for r in rows})
        try:
            current_theta = float(self.tw_theta.get())
        except (tk.TclError, TypeError, ValueError):
            current_theta = 0.0
            self.tw_theta.set(current_theta)
        chosen = self._tw_pick_nearest_theta(current_theta, thetas)
        self.tw_theta.set(chosen)
        self._tw_refilter_and_redraw()
        self.tw_info.config(text=f"Loaded {len(rows)} records · theta slice {chosen:.2f}°")

    def _tw_row_from_dict(self, d: dict) -> dict:
        if not isinstance(d, dict):
            return {}

        def _first(keys: tuple[str, ...], default: float | str = 0.0):
            for key in keys:
                if key in d and d[key] not in ("", None):
                    return d[key]
            return default

        try:
            theta = float(_first(("theta", "theta_deg"), 0.0))
            ux = float(_first(("ux",), 0.0))
            uy = float(_first(("uy",), 0.0))
            gap = float(_first(("gap", "gap_eV"), 0.0))
            energy = float(_first(("E", "totalE", "totalE_eV"), 0.0))
        except Exception:
            return {}

        path = str(_first(("path", "name"), ""))
        return {"theta": theta, "ux": ux, "uy": uy, "gap": gap, "E": energy, "path": path}

    def _tw_pick_nearest_theta(self, val: float, thetas: list[float]) -> float:
        if not thetas:
            return 0.0
        return min(thetas, key=lambda t: abs(t - val))

    # --- 过滤并重绘 ---
    def _tw_refilter_and_redraw(self):
        if not getattr(self, "tw_results", None):
            return
        try:
            theta_val = float(self.tw_theta.get())
        except (tk.TclError, TypeError, ValueError):
            theta_val = 0.0
            self.tw_theta.set(theta_val)
        theta = round(theta_val, 6)
        thetas = sorted({round(r["theta"], 6) for r in self.tw_results})
        if theta not in thetas:
            theta = self._tw_pick_nearest_theta(theta, thetas)
            self.tw_theta.set(theta)
        self.tw_filtered = [r for r in self.tw_results if round(r["theta"], 6) == theta]
        self._tw_refresh_tree(self.tw_filtered)
        self._tw_redraw_heatmap(self.tw_filtered)

    def _tw_refresh_tree(self, rows: list[dict]):
        if not hasattr(self, "tw_tree"):
            return
        self.tw_tree.delete(*self.tw_tree.get_children())
        rows_sorted = sorted(rows, key=lambda r: (r["ux"], r["uy"]))
        for r in rows_sorted:
            self.tw_tree.insert(
                "",
                tk.END,
                values=(
                    f"{r['theta']:.2f}",
                    f"{r['ux']:.2f}",
                    f"{r['uy']:.2f}",
                    f"{r['gap']:.3f}",
                    f"{r['E']:.3f}",
                    r["path"],
                ),
            )

    def _tw_redraw_heatmap(self, rows: list[dict]):
        if not hasattr(self, "tw_ax"):
            return
        self.tw_ax.clear()
        if not rows:
            self.tw_ax.set_title("No data available")
            self.tw_canvas.draw_idle()
            return
        xs = [r["ux"] for r in rows]
        ys = [r["uy"] for r in rows]
        cs = [r["gap"] for r in rows]
        sc = self.tw_ax.scatter(xs, ys, c=cs)
        self.tw_ax.set_xlabel("ux")
        self.tw_ax.set_ylabel("uy")
        self.tw_ax.set_title(f"Band gap heatmap (theta={self.tw_theta.get():.2f} deg)")
        if self.tw_cbar is not None:
            try:
                self.tw_cbar.update_normal(sc)
                self.tw_cbar.set_label("gap (eV)")
            except Exception:
                try:
                    self.tw_cbar.remove()
                except Exception:
                    pass
                self.tw_cbar = self.tw_fig.colorbar(sc, ax=self.tw_ax, label="gap (eV)")
        else:
            self.tw_cbar = self.tw_fig.colorbar(sc, ax=self.tw_ax, label="gap (eV)")
        apply_style(self.tw_ax, _normalize_style(self.figure_style_var.get()))
        self.tw_fig.tight_layout()
        self.tw_canvas.draw_idle()

    # --- 表格选择 ---
    def _on_tw_tree_select(self, _evt=None):
        sel = self.tw_tree.selection()
        if not sel:
            return
        vals = self.tw_tree.item(sel[0], "values")
        try:
            self.tw_theta.set(float(vals[0]))
            self.tw_ux.set(float(vals[1]))
            self.tw_uy.set(float(vals[2]))
        except Exception:
            pass

    # --- 导出当前切片 CSV ---
    def _tw_export_slice_csv(self):
        if not getattr(self, "tw_filtered", None):
            messagebox.showwarning(APP_NAME, "当前 θ 切片为空。")
            return
        p = filedialog.asksaveasfilename(
            defaultextension=".csv",
            filetypes=[("CSV", "*.csv")],
            title="导出当前θ切片为 CSV",
        )
        if not p:
            return
        with open(p, "w", encoding="utf-8") as f:
            f.write("theta,ux,uy,gap,E,path\n")
            for r in self.tw_filtered:
                f.write(f"{r['theta']},{r['ux']},{r['uy']},{r['gap']},{r['E']},{r['path']}\n")
        messagebox.showinfo(APP_NAME, f"已导出：{p}")

    # === 2D 滑移/扭转载：页面 + 演示数据 + 可视化（最小可用版） END ===============

    # === POST: twist/slide maps & curves =========================================
    def _tw_load_results_table(self, root: Optional[Path] = None) -> List[Dict[str, Any]]:
        """加载 twist_sweep/results.csv；若不存在先调用 _tw_collect_results() 生成。"""
        root = root or (self.current_project_path() / "twist_sweep")
        csv_path = root / "results.csv"
        if not csv_path.exists():
            if self.demo_mode:
                try:
                    self._tw_write_demo_results(root)
                except Exception as exc:
                    messagebox.showerror(APP_NAME, f"生成演示数据失败：{exc}")
                    return []
            try:
                self._tw_collect_results()
            except Exception as e:
                messagebox.showerror(APP_NAME, f"缺少 results.csv 且自动收集失败：{e}")
                return []
        rows: List[Dict[str, Any]] = []
        try:
            import csv

            with csv_path.open("r", encoding="utf-8") as f:
                reader = csv.DictReader(f)
                for rec in reader:
                    try:
                        gap_val = rec.get("gap")
                        if gap_val in (None, ""):
                            gap_val = rec.get("gap_eV")
                        energy_val = rec.get("E")
                        if energy_val in (None, ""):
                            energy_val = rec.get("totalE_eV")
                        rows.append(
                            {
                                "theta": float(rec.get("theta") or "nan"),
                                "ux": float(rec.get("ux") or "nan"),
                                "uy": float(rec.get("uy") or "nan"),
                                "gap": float(gap_val or "nan"),
                                "E": float(energy_val or "nan"),
                                "path": rec.get("path", ""),
                                "note": rec.get("note", ""),
                            }
                        )
                    except Exception:
                        pass
        except Exception as e:
            messagebox.showerror(APP_NAME, f"读取 {csv_path} 失败：{e}")
            return []
        rows = [
            r
            for r in rows
            if (not math.isnan(r["theta"]))
            and (not math.isnan(r["ux"]))
            and (not math.isnan(r["uy"]))
        ]
        return rows

    def _tw_plot_gap_heatmap_btn(self):
        """按钮：用当前 θ（输入框 tw_theta_a）画 gap(u_x,u_y) 热图。"""

        try:
            theta = float(self.tw_theta_a.get())
        except Exception:
            messagebox.showwarning(APP_NAME, "当前 θ 无效。")
            return
        self._tw_plot_gap_heatmap(theta)

    def _tw_plot_gap_heatmap(self, theta: float):
        """固定 θ，画 gap 在 (ux,uy) 网格上的热图。"""

        if not HAS_NUMPY:
            messagebox.showerror(APP_NAME, "需要 numpy 才能绘制热图。")
            return
        import numpy as np

        all_rows = self._tw_load_results_table()
        if not all_rows:
            if not self.demo_mode:
                missing = self.current_project_path() / "twist_sweep" / "results.csv"
                messagebox.showwarning(APP_NAME, f"无法绘制热图：缺少 {missing}。")
            return
        rows = [r for r in all_rows if abs((r["theta"] or 0.0) - theta) < 1e-6]
        if not rows:
            messagebox.showwarning(APP_NAME, f"未在 results.csv 中找到 θ={theta} 的数据。")
            return

        ux_vals = sorted({round(r["ux"], 6) for r in rows})
        uy_vals = sorted({round(r["uy"], 6) for r in rows})
        nx, ny = len(ux_vals), len(uy_vals)
        grid = np.full((ny, nx), np.nan, dtype=float)
        ux_index = {v: j for j, v in enumerate(ux_vals)}
        uy_index = {v: i for i, v in enumerate(uy_vals)}

        for r in rows:
            g = r.get("gap", float("nan"))
            if g is None or math.isnan(g):
                continue
            j = ux_index.get(round(r["ux"], 6))
            i = uy_index.get(round(r["uy"], 6))
            if i is not None and j is not None:
                grid[i, j] = g

        top = tk.Toplevel(self)

        top.title(f"Band gap heatmap @ θ={theta:.2f}°")
        fig = Figure(figsize=(6.2, 5.2), dpi=110)
        ax = fig.add_subplot(111)
        im = ax.imshow(
            grid,
            origin="lower",
            extent=[min(ux_vals), max(ux_vals), min(uy_vals), max(uy_vals)],
            aspect="equal",
        )
        cbar = fig.colorbar(im, ax=ax)
        cbar.set_label("Band gap (eV)")
        ax.set_xlabel("u_x")
        ax.set_ylabel("u_y")
        ax.set_title(f"Band gap heatmap @ θ={theta:.2f}°  (N={int(np.isfinite(grid).sum())})")
        apply_style(ax, _normalize_style(self.figure_style_var.get()))
        fig.tight_layout()
        canvas = FigureCanvasTkAgg(fig, master=top)
        canvas.draw()
        canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)

        def _save():
            outdir = self.current_project_path() / "reports"
            outdir.mkdir(parents=True, exist_ok=True)
            png_path = outdir / f"gap_heatmap_theta_{theta:.2f}.png"
            csv_path = outdir / f"gap_heatmap_theta_{theta:.2f}.csv"
            try:
                fig.savefig(png_path, dpi=300)
                with csv_path.open("w", encoding="utf-8") as f:
                    f.write("uy,ux,gap_eV\n")
                    for i, uy in enumerate(uy_vals):
                        for j, ux in enumerate(ux_vals):
                            val = grid[i, j]
                            if math.isnan(val):
                                continue
                            f.write(f"{uy:.6f},{ux:.6f},{val:.6f}\n")
                messagebox.showinfo(APP_NAME, f"已导出\n{png_path}\n{csv_path}")
            except Exception as e:
                messagebox.showerror(APP_NAME, f"导出失败：{e}")

        ttk.Button(top, text="导出 PNG/CSV", command=_save).pack(pady=6)

    def _tw_plot_gap_vs_theta_btn(self):
        """按钮：汇总所有 θ 的 min/mean/max gap，画曲线 + 阴影带；并导出 CSV。"""

        self._tw_plot_gap_vs_theta()

    def _tw_plot_gap_vs_theta(self):
        if not HAS_NUMPY:
            messagebox.showerror(APP_NAME, "需要 numpy 才能绘制曲线。")
            return
        import numpy as np

        rows = self._tw_load_results_table()
        if not rows:
            if not self.demo_mode:
                missing = self.current_project_path() / "twist_sweep" / "results.csv"
                messagebox.showwarning(APP_NAME, f"无法绘制曲线：缺少 {missing}。")
            return
        by_theta: Dict[float, List[float]] = {}
        for r in rows:
            g = r.get("gap", float("nan"))
            if g is None or math.isnan(g):
                continue
            th = round(r.get("theta", float("nan")), 6)
            if math.isnan(th):
                continue
            by_theta.setdefault(th, []).append(float(g))
        thetas = sorted(by_theta.keys())
        if not thetas:
            messagebox.showwarning(APP_NAME, "结果中没有有效的带隙。")
            return
        g_min = np.array([np.min(by_theta[t]) for t in thetas], dtype=float)
        g_max = np.array([np.max(by_theta[t]) for t in thetas], dtype=float)
        g_mean = np.array([np.mean(by_theta[t]) for t in thetas], dtype=float)

        top = tk.Toplevel(self)

        top.title("Band gap vs. twist angle (min/mean/max)")
        fig = Figure(figsize=(6.4, 4.6), dpi=110)
        ax = fig.add_subplot(111)
        ax.plot(thetas, g_mean, label="mean gap")
        ax.fill_between(thetas, g_min, g_max, alpha=0.25, label="range [min, max]")
        ax.set_xlabel("Twist angle θ (deg)")
        ax.set_ylabel("Band gap (eV)")
        ax.set_title("Band gap vs. twist angle\n(shaded band = variation across slide grid)")
        ax.legend()
        apply_style(ax, _normalize_style(self.figure_style_var.get()))
        fig.tight_layout()
        canvas = FigureCanvasTkAgg(fig, master=top)
        canvas.draw()
        canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)

        def _save():
            outdir = self.current_project_path() / "reports"
            outdir.mkdir(parents=True, exist_ok=True)
            csv_path = outdir / "gap_vs_theta_min_mean_max.csv"
            png_path = outdir / "gap_vs_theta_min_mean_max.png"
            try:
                with csv_path.open("w", encoding="utf-8") as f:
                    f.write("theta_deg,gap_min_eV,gap_mean_eV,gap_max_eV,range_eV\n")
                    for t, mn, me, mx in zip(thetas, g_min, g_mean, g_max):
                        f.write(f"{t:.6f},{mn:.6f},{me:.6f},{mx:.6f},{(mx - mn):.6f}\n")
                fig.savefig(png_path, dpi=300)
                messagebox.showinfo(APP_NAME, f"已导出\n{png_path}\n{csv_path}")
            except Exception as e:
                messagebox.showerror(APP_NAME, f"导出失败：{e}")

        ttk.Button(top, text="导出 PNG/CSV", command=_save).pack(pady=6)

    # === END POST ================================================================

    # ------------------------- 页面：流程助手 ------------------------------
    def _build_workflow_page(self, parent):
        frame = ttk.Frame(parent)

        intro = ttk.Label(
            frame,
            text="按照从上到下的步骤完成一次 VASP 计算，可点击按钮快速跳转到对应面板。",
            wraplength=900,
            justify=tk.LEFT,
        )
        intro.pack(fill=tk.X, padx=12, pady=8)

        status_box = ttk.LabelFrame(frame, text="当前项目状态")
        status_box.pack(fill=tk.BOTH, expand=False, padx=12, pady=6)

        status_row = ttk.Frame(status_box)
        status_row.pack(fill=tk.X, padx=8, pady=6)
        ttk.Label(status_row, text="运行状态：").pack(side=tk.LEFT)
        ttk.Label(status_row, textvariable=self.run_status_var).pack(side=tk.LEFT, padx=4)
        ttk.Button(status_row, text="刷新状态", command=self.refresh_run_status).pack(side=tk.RIGHT)

        tree_frame = ttk.Frame(status_box)
        tree_frame.pack(fill=tk.BOTH, expand=True, padx=8, pady=(0, 6))
        columns = ("name", "status", "detail")
        self.workflow_tree = ttk.Treeview(tree_frame, columns=columns, show="headings", height=6)
        self.workflow_tree.heading("name", text="项目项")
        self.workflow_tree.heading("status", text="状态")
        self.workflow_tree.heading("detail", text="详情")
        self.workflow_tree.column("name", width=120, anchor=tk.W)
        self.workflow_tree.column("status", width=120, anchor=tk.W)
        self.workflow_tree.column("detail", anchor=tk.W, stretch=True)
        tree_scroll = ttk.Scrollbar(tree_frame, orient=tk.VERTICAL, command=self.workflow_tree.yview)
        self.workflow_tree.configure(yscrollcommand=tree_scroll.set)
        self.workflow_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        tree_scroll.pack(side=tk.RIGHT, fill=tk.Y)

        sugg = ttk.Frame(status_box)
        sugg.pack(fill=tk.BOTH, expand=False, padx=8, pady=(0, 6))
        ttk.Label(sugg, text="运行建议：").pack(anchor=tk.W)
        wf_suggest = ScrolledText(sugg, height=4, wrap="word", state="disabled")
        wf_suggest.pack(fill=tk.X, expand=True)
        self._register_suggestion_widget(wf_suggest)

        steps = [
            (
                "① 准备项目目录",
                "选择/新建项目文件夹，所有输入输出文件都保存在此处。",
                [
                    ("选择项目", self.choose_project),
                    ("新建项目", self.create_project),
                    ("快速体检 (Preflight)", self.quick_check),
                ],
                self.page_inputs,
            ),
            (
                "② 编辑输入文件",
                "填写 INCAR、POSCAR、KPOINTS 等输入，确保必要信息完整。",
                [
                    ("跳转到输入面板", lambda: self.goto_tab(self.page_inputs)),
                    ("跳转到 K 点设置", lambda: self.goto_tab(self.page_inputs)),
                ],
                self.page_inputs,
            ),
            (
                "③ 准备 POTCAR",
                "解析 POSCAR 元素并在 POTCAR 面板一键拼接所需赝势。",
                [
                    ("跳转到 POTCAR", lambda: self.goto_tab(self.page_inputs)),
                    ("解析元素", self.show_poscar_elements),
                ],
                self.page_inputs,
            ),
            (
                "③½ 二维材料批量（扭转/滑移）",
                "针对二维材料的扭转/滑移扫描，提供推荐模板、任务估算与批量生成。",
                [
                    ("开始二维材料扫描", self._tw_launch_wizard),
                    ("打开二维面板", lambda: self.goto_tab(self.page_twist)),
                ],
                self.page_twist,
            ),
            (
                "④ 配置运行方式",
                "根据实际环境选择本地/WSL/SLURM 运行，并生成脚本。",
                [
                    ("跳转到运行页", lambda: self.goto_tab(self.page_run)),
                    ("生成运行脚本", self.write_job_script),
                ],
                self.page_run,
            ),
            (
                "⑤ 启动并监视",
                "启动计算后，利用监视页关注能量收敛、CPU 使用率及文件增长。",
                [
                    ("启动/提交", self.start_run),
                    ("跳转到监视", lambda: self.goto_tab(self.page_monitor)),
                    ("开始监视", self.start_monitor),
                ],
                self.page_monitor,
            ),
            (
                "⑥ 后处理与结果",
                "提取最终能量或绘制一次性曲线，整理输出文件。",
                [
                    ("跳转到后处理", lambda: self.goto_tab(self.page_post)),
                    ("提取最终能量", self.extract_final_energy),
                ],
                self.page_post,
            ),
        ]

        steps_frame = ttk.Frame(frame)
        steps_frame.pack(fill=tk.BOTH, expand=True, padx=12, pady=6)
        steps_frame.grid_columnconfigure(0, weight=1)
        steps_frame.grid_columnconfigure(1, weight=1)
        for idx, (title, desc, buttons, page) in enumerate(steps):
            row, col = divmod(idx, 2)
            box = ttk.LabelFrame(steps_frame, text=title)
            box.grid(row=row, column=col, sticky="nsew", padx=6, pady=6)
            ttk.Label(box, text=desc, justify=tk.LEFT, wraplength=360).pack(anchor=tk.W, padx=8, pady=4)
            row_frame = ttk.Frame(box)
            row_frame.pack(anchor=tk.W, padx=8, pady=4)
            for txt, cmd in buttons:
                ttk.Button(row_frame, text=txt, command=cmd).pack(side=tk.LEFT, padx=4)
            ttk.Button(row_frame, text="打开此面板", command=lambda p=page: self.goto_tab(p)).pack(side=tk.LEFT, padx=8)

        notes = ttk.LabelFrame(frame, text="流程备注 / 待办")
        notes.pack(fill=tk.BOTH, expand=True, padx=12, pady=8)
        self.workflow_notes = ScrolledText(notes, height=8, wrap="word")
        self.workflow_notes.pack(fill=tk.BOTH, expand=True, padx=6, pady=6)
        self.workflow_notes.insert(
            tk.END,
            "可在此记录当前任务的特殊参数、检查列表或备注。内容不会自动保存。",
        )
        return frame

    def kpoints_to_editor(self):
        s = gen_kpoints_monkhorst(self.k_nx.get(), self.k_ny.get(), self.k_nz.get(), self.k_gamma.get())
        self.kpoints_text.delete("1.0", tk.END)
        self.kpoints_text.insert("1.0", s)

    def kpoints_save(self):
        proj = self.current_project_path()
        proj.mkdir(parents=True, exist_ok=True)
        s = self.kpoints_text.get("1.0", tk.END)
        write_text(proj / "KPOINTS", s)
        messagebox.showinfo(APP_NAME, f"KPOINTS 已保存到 {proj/'KPOINTS'}")
        self.refresh_project_overview()

    def goto_tab(self, page):
        try:
            self.nb.select(page)
        except Exception:
            pass


    def append_run_log(self, msg: str):
        text = (msg or "")
        lines = text.splitlines() or [""]
        for line in lines:
            self.run_log.insert(tk.END, line.rstrip("\n") + "\n")
        self.run_log.see(tk.END)

    # ====== 非阻塞跟随 vasp.out 到 GUI ======
    def _start_following_log(self, log_path: Path, interval_ms: int = 500):
        """非阻塞跟随 log_path，将新增内容追加到 self.run_log。"""
        self._log_path = Path(log_path)
        self._tail_pos = 0
        self._tail_interval = int(interval_ms)
        # 若之前有定时任务，先取消
        if hasattr(self, "_tail_job") and self._tail_job:
            try:
                self.after_cancel(self._tail_job)
            except Exception:
                pass
        # 立即触发一次
        self._follow_log_tick()

    def _follow_log_tick(self):
        chunk = ""
        try:
            with open(self._log_path, "r", encoding="utf-8", errors="ignore") as f:
                f.seek(getattr(self, "_tail_pos", 0))
                chunk = f.read(64 * 1024)  # 每 tick 最多 64KB
                self._tail_pos = f.tell()
        except FileNotFoundError:
            pass
        except Exception as e:
            chunk = f"[log-follow] 读取失败：{e}\n"
        if chunk:
            self.append_run_log(chunk)
        self._tail_job = self.after(getattr(self, "_tail_interval", 500), self._follow_log_tick)

    def _stop_following_log(self):
        if hasattr(self, "_tail_job") and self._tail_job:
            try:
                self.after_cancel(self._tail_job)
            except Exception:
                pass
            self._tail_job = None

    def _int_from_var(self, var, default=0) -> int:
        try:
            value = var.get()
        except Exception:
            value = default
        try:
            return int(value)
        except Exception:
            try:
                return int(default)
            except Exception:
                return 0

    # ------------------------- 页面：运行 / 提交 ----------------------------
    def _build_run_page(self, parent):
        frame = ttk.Frame(parent)

        status = ttk.LabelFrame(frame, text="运行状态")
        status.pack(fill=tk.X, padx=8, pady=6)
        row = ttk.Frame(status)
        row.pack(fill=tk.X, padx=6, pady=4)
        ttk.Label(row, text="当前状态：").pack(side=tk.LEFT)
        ttk.Label(row, textvariable=self.run_status_var).pack(side=tk.LEFT, padx=4)
        ttk.Button(row, text="刷新状态", command=self.refresh_run_status).pack(side=tk.RIGHT)
        run_suggest = ScrolledText(status, height=3, wrap="word", state="disabled")
        run_suggest.pack(fill=tk.X, padx=6, pady=(0, 6))
        self._register_suggestion_widget(run_suggest)

        # 运行方式
        row0 = ttk.LabelFrame(frame, text="运行方式")
        row0.pack(fill=tk.X, padx=8, pady=8)
        self.run_mode = tk.StringVar(value="local")
        ttk.Radiobutton(row0, text="本地 mpirun", value="local", variable=self.run_mode).pack(side=tk.LEFT, padx=8)
        ttk.Radiobutton(row0, text="WSL2 (Windows)", value="wsl", variable=self.run_mode).pack(side=tk.LEFT, padx=8)
        ttk.Radiobutton(row0, text="SLURM 集群", value="slurm", variable=self.run_mode).pack(side=tk.LEFT)

        # VASP 执行文件 & 核心数
        row1 = ttk.LabelFrame(frame, text="VASP 执行配置")
        row1.pack(fill=tk.X, padx=8, pady=4)
        ttk.Label(row1, text="VASP 命令").grid(row=0, column=0, sticky=tk.W, padx=6, pady=4)
        self.vasp_cmd = tk.StringVar(value="vasp_std")
        ttk.Entry(row1, textvariable=self.vasp_cmd, width=30).grid(row=0, column=1, sticky=tk.W)
        ttk.Button(row1, text="which?", command=self.which_vasp).grid(row=0, column=2, padx=6)

        ttk.Label(row1, text="MPI 进程数 -np").grid(row=1, column=0, sticky=tk.W, padx=6, pady=4)
        self.mpi_np = tk.IntVar(value=8)
        # 新增：自动并行
        self.auto_parallel = tk.BooleanVar(value=True)
        ttk.Checkbutton(row1, text="自动并行（智能设置 KPAR/NCORE）",
                        variable=self.auto_parallel).grid(row=2, column=0, columnspan=3, sticky=tk.W, padx=6)
        ttk.Spinbox(row1, from_=1, to=2048, textvariable=self.mpi_np, width=8).grid(row=1, column=1, sticky=tk.W)

        # SLURM 区域
        row2 = ttk.LabelFrame(frame, text="SLURM 提交（仅在选择 SLURM 运行时使用）")
        row2.pack(fill=tk.X, padx=8, pady=4)
        self.slurm_part = tk.StringVar(value="normal")
        self.slurm_time = tk.StringVar(value="02:00:00")
        self.slurm_nodes = tk.IntVar(value=1)
        self.slurm_ntasks = tk.IntVar(value=32)
        self.slurm_account = tk.StringVar(value="")
        ttk.Label(row2, text="分区").grid(row=0, column=0, sticky=tk.W, padx=6, pady=4)
        ttk.Entry(row2, textvariable=self.slurm_part, width=12).grid(row=0, column=1)
        ttk.Label(row2, text="时长").grid(row=0, column=2, sticky=tk.W, padx=6)
        ttk.Entry(row2, textvariable=self.slurm_time, width=12).grid(row=0, column=3)
        ttk.Label(row2, text="节点").grid(row=0, column=4, sticky=tk.W, padx=6)
        ttk.Spinbox(row2, from_=1, to=128, textvariable=self.slurm_nodes, width=6).grid(row=0, column=5)
        ttk.Label(row2, text="ntasks").grid(row=0, column=6, sticky=tk.W, padx=6)
        ttk.Spinbox(row2, from_=1, to=8192, textvariable=self.slurm_ntasks, width=8).grid(row=0, column=7)
        ttk.Label(row2, text="账号").grid(row=0, column=8, sticky=tk.W, padx=6)
        ttk.Entry(row2, textvariable=self.slurm_account, width=12).grid(row=0, column=9)

        btns = ttk.Frame(frame)
        btns.pack(fill=tk.X, padx=8, pady=8)
        ttk.Button(btns, text="生成运行脚本", command=self.write_job_script).pack(side=tk.LEFT)
        ttk.Button(btns, text="启动/提交", command=self.start_run).pack(side=tk.LEFT, padx=8)
        ttk.Button(btns, text="停止本地进程", command=self.stop_local).pack(side=tk.LEFT)

        self.run_log = ScrolledText(frame, height=14, wrap="word")
        self.run_log.pack(fill=tk.BOTH, expand=True, padx=8, pady=8)

        return frame

    @staticmethod
    def is_windows() -> bool:
        return os.name == "nt" or sys.platform.startswith("win")

    def win_to_wsl_path(self, p: Path) -> str:
        # 将 Windows 路径 C:\foo\bar 转为 /mnt/c/foo/bar
        s = str(p)
        if len(s) >= 2 and s[1] == ":":
            drive = s[0].lower()
            rest = s[2:].replace("\\", "/")
            return f"/mnt/{drive}{rest if rest.startswith('/') else '/' + rest}"
        return s.replace("\\", "/")

    def which_vasp(self):
        cmd = self.vasp_cmd.get().strip()
        path = which(cmd)
        if path:
            messagebox.showinfo(APP_NAME, f"{cmd} -> {path}")
        else:
            messagebox.showwarning(APP_NAME, f"未在 PATH 中找到 {cmd}")

    def write_job_script(self):
        """生成 run_local.sh / run_slurm.sh（含自动并行设置与稳健环境）。"""
        proj = self.current_project_path()
        proj.mkdir(parents=True, exist_ok=True)

        # —— 可选额外库（只拼接存在的路径，不会写坏环境）——
        extra_libs = []
        for pth in ["/home/yu/apps/aocl/4.1.0/aocc/lib",
                    "/home/yu/apps/aocc-compiler-4.1.0/lib"]:
            try:
                if Path(pth).exists():
                    extra_libs.append(pth)
            except Exception:
                pass
        extra_ld = ":".join(extra_libs)

        ld_line = (f'export LD_LIBRARY_PATH="{extra_ld}:${{LD_LIBRARY_PATH}}"\n'
                   if extra_ld else 'export LD_LIBRARY_PATH="${LD_LIBRARY_PATH:-}"\n')

        env_lines = (
            "# --- Runtime environment (auto generated) ---\n"
            ': "${LD_LIBRARY_PATH:=}"\n'
            f"{ld_line}"
            'export OMP_NUM_THREADS="${OMP_NUM_THREADS:-1}"\n'
            'export OMP_PROC_BIND="${OMP_PROC_BIND:-true}"\n'
            'export OMP_PLACES="${OMP_PLACES:-cores}"\n'
        )

        vcmd = (self.vasp_cmd.get().strip() if hasattr(self, "vasp_cmd") else "") or "vasp_std"
        mpirun_path = which("mpirun") or "mpirun"
        try:
            np = int(self.mpi_np.get()) if hasattr(self, "mpi_np") else 8
        except Exception:
            np = 8

        # —— 自动并行：写回 KPAR/NCORE（若提供了开关或未提供也尝试）——
        try:
            if hasattr(self, "auto_parallel"):
                if self.auto_parallel.get():
                    self._autotune_parallel_and_write(np)
            else:
                # 没有勾选框也尽量自动一次，不报错即可
                if hasattr(self, "_autotune_parallel_and_write"):
                    self._autotune_parallel_and_write(np)
        except Exception as e:
            self.append_run_log(f"[auto-parallel] 失败：{e}")

        # ===== 本地 run_local.sh =====
        local_script = f"""#!/bin/bash
    set -euo pipefail

    {env_lines}
    cd "{proj}"

    echo "[INFO] Workdir: $(pwd)"
    echo "[INFO] Using mpirun: {mpirun_path}"
    echo "[INFO] VASP cmd    : {vcmd}"
    echo "[INFO] NP          : {np}"
    echo "[INFO] LD_LIBRARY_PATH=$LD_LIBRARY_PATH"
    echo "[INFO] OMP_NUM_THREADS=$OMP_NUM_THREADS"

    # 降低调度与 I/O 优先级；并把 MPI 绑定到 core，降低任务迁移开销
    # 动态选择绑定策略：超过物理核数就用硬件线程
PHYS_CORES=$(lscpu -p=CORE 2>/dev/null | egrep -v '^#' | cut -d, -f2 | sort -u | wc -l | tr -d ' ')
if [ -n "$PHYS_CORES" ] && [ "$PHYS_CORES" -gt 0 ] && [ "{np}" -gt "$PHYS_CORES" ]; then
  BIND="--use-hwthread-cpus --bind-to hwthread --map-by ppr:1:hwthread"
else
  BIND="--bind-to core --map-by ppr:1:core"
fi

nice -n 5 ionice -c2 -n4 \
{mpirun_path} $BIND -np {np} {vcmd} > vasp.out 2>&1

    """

        # ===== SLURM run_slurm.sh =====
        slurm_part = self.slurm_part.get().strip() if hasattr(self, "slurm_part") else "normal"
        slurm_time = self.slurm_time.get().strip() if hasattr(self, "slurm_time") else "02:00:00"
        try:
            slurm_nodes = int(self.slurm_nodes.get()) if hasattr(self, "slurm_nodes") else 1
        except Exception:
            slurm_nodes = 1
        try:
            slurm_ntasks = int(self.slurm_ntasks.get()) if hasattr(self, "slurm_ntasks") else max(np, 1)
        except Exception:
            slurm_ntasks = max(np, 1)
        slurm_account = (self.slurm_account.get().strip() if hasattr(self, "slurm_account") else "")
        acc_line = f"#SBATCH --account={slurm_account}\n" if slurm_account else ""

        slurm_script = f"""#!/bin/bash
    #SBATCH --job-name=vasp
    #SBATCH --partition={slurm_part}
    #SBATCH --time={slurm_time}
    #SBATCH --nodes={slurm_nodes}
    #SBATCH --ntasks={slurm_ntasks}
    {acc_line}set -euo pipefail

    {env_lines}
    cd "{proj}"

    echo "SLURM_JOB_ID=$SLURM_JOB_ID"
    echo "[INFO] Workdir: $(pwd)"
    echo "[INFO] VASP cmd: {vcmd}"
    echo "[INFO] ntasks  : $SLURM_NTASKS"
    echo "[INFO] LD_LIBRARY_PATH=$LD_LIBRARY_PATH"
    echo "[INFO] OMP_NUM_THREADS=$OMP_NUM_THREADS"

    # 绑定到物理核，避免过度超线程导致的抖动
    srun --cpu-bind=cores {vcmd} > vasp.out 2>&1
    """

        # —— 写文件并授权 ——
        try:
            write_text(proj / "run_local.sh", local_script)
            os.chmod(proj / "run_local.sh", 0o755)
            self.append_run_log(f"已生成 {proj / 'run_local.sh'}")
        except Exception as e:
            self.append_run_log(f"[EXC] 写 run_local.sh 失败：{e}")

        try:
            write_text(proj / "run_slurm.sh", slurm_script)
            os.chmod(proj / "run_slurm.sh", 0o755)
            self.append_run_log(f"已生成 {proj / 'run_slurm.sh'}")
        except Exception as e:
            self.append_run_log(f"[EXC] 写 run_slurm.sh 失败：{e}")

        # 刷新界面状态
        self.refresh_project_overview()

    def start_run(self):
        proj = self.current_project_path()
        mode = self.run_mode.get()
        vcmd = self.vasp_cmd.get().strip()

        if not proj.exists():
            messagebox.showerror(APP_NAME, f"项目目录不存在：{proj}")
            return

        # 关键输入文件缺失时提示，但允许继续
        missing = [f for f in ["INCAR", "POSCAR", "POTCAR"] if not (proj / f).exists()]
        if missing:
            if not messagebox.askyesno(
                    APP_NAME,
                    "检测到以下关键输入文件缺失：\n"
                    + "\n".join(missing)
                    + "\n仍要继续启动吗？",
            ):
                return

        if mode == "local":
            # 防止重复起
            if self.proc and self.proc.poll() is None:
                messagebox.showwarning(APP_NAME, "已有本地 VASP 进程在运行。先停止或等待结束。")
                return

            # 基础可用性检查
            if not which("mpirun"):
                messagebox.showerror(APP_NAME, "未找到 mpirun。请安装 OpenMPI/IntelMPI 并加入 PATH。")
                return
            if not which(vcmd):
                messagebox.showerror(APP_NAME, f"未找到 VASP 命令：{vcmd}\n可改填绝对路径，例如 /opt/vasp/vasp_std")
                return

            # 总是重写一次脚本，确保环境最新
            self.write_job_script()
            # 替换 start_run() 内 local 分支里 “后台运行脚本” 那一段
            runsh = proj / "run_local.sh"
            try:
                # 使用 Popen 非阻塞启动脚本本身，而不是在主线程里 check_output
                self.proc = subprocess.Popen(
                    ["bash", "-lc", f"cd '{proj}' && exec './{runsh.name}'"],
                    stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL,
                    start_new_session=True  # 关键：新会话，便于后续整组终止
                )
                self.append_run_log(f"[run_local.sh pid] {self.proc.pid}")

                # 启动非阻塞日志跟随
                self._start_following_log(proj / "vasp.out")
                self.append_run_log("日志跟随 vasp.out（非阻塞）已启动。\n")

                # 改为 after 定时健康检查（避免 time.sleep 阻塞 Tk）
                def _health_check():
                    vout = proj / "vasp.out"
                    if not vout.exists() or vout.stat().st_size == 0:
                        # 再等 2 秒复查一次
                        self.after(2000, _health_check)
                        return
                    # 有输出就启动监视器
                    self.start_monitor()

                self.after(1500, _health_check)

            except Exception as e:
                self.append_run_log(f"[EXC] 启动失败：{e}")
                messagebox.showerror(APP_NAME, f"启动失败：{e}")
                return

        elif mode == "wsl":
            messagebox.showerror(APP_NAME, "WSL 分支未内置 AOCL/AOCC 环境设置，请使用本地或 SLURM。")
            return

        else:
            # SLURM：写脚本并 sbatch
            if not which("sbatch"):
                messagebox.showerror(APP_NAME, "未找到 sbatch。请在 SLURM 节点上运行或配置环境。")
                return
            self.write_job_script()
            script = proj / "run_slurm.sh"
            try:
                out = subprocess.check_output(["bash", "-lc", f"cd '{proj}' && sbatch '{script.name}'"], text=True)
                if out:
                    self.append_run_log(out)
                self.start_monitor()
            except subprocess.CalledProcessError as e:
                messagebox.showerror(APP_NAME, f"sbatch 失败：{e}{e.output}")

    def stop_local(self):
        try:
            if self.proc and self.proc.poll() is None:
                # 发送到整组（需要 start_new_session=True）
                os.killpg(os.getpgid(self.proc.pid), 15)  # SIGTERM
                time.sleep(0.5)
                if self.proc.poll() is None:
                    os.killpg(os.getpgid(self.proc.pid), 9)  # SIGKILL
                self.append_run_log("已停止本地 VASP 进程组。\n")
            else:
                # 兜底：旧行为
                subprocess.call(["bash", "-lc", f"pkill -f 'vasp' || true"])
                self.append_run_log("已尝试 pkill -f 'vasp'。\n")
            self.refresh_run_status()
        except Exception as e:
            messagebox.showerror(APP_NAME, f"停止失败：{e}")

    # ------------------------- 页面：监视 ----------------------------------
    def _build_monitor_page(self, parent):
        frame = ttk.Frame(parent)

        status_box = ttk.LabelFrame(frame, text="运行状态概览")
        status_box.pack(fill=tk.X, padx=8, pady=10)
        row = ttk.Frame(status_box)
        row.pack(fill=tk.X, padx=6, pady=8)
        ttk.Label(row, text="当前状态：").pack(side=tk.LEFT)
        ttk.Label(row, textvariable=self.run_status_var).pack(side=tk.LEFT, padx=4)
        ttk.Button(row, text="刷新状态", command=self.refresh_run_status).pack(side=tk.RIGHT)
        monitor_suggest = ScrolledText(status_box, height=3, wrap="word", state="disabled")
        monitor_suggest.pack(fill=tk.X, padx=6, pady=(2, 8))
        self._register_suggestion_widget(monitor_suggest)

        top = ttk.Frame(frame)
        top.pack(fill=tk.X, padx=8, pady=6)
        ttk.Button(top, text="开始监视", command=self.start_monitor).pack(side=tk.LEFT)
        ttk.Button(top, text="停止监视", command=self.stop_monitor).pack(side=tk.LEFT, padx=6)
        ttk.Label(top, text="文件列表(逗号分隔)").pack(side=tk.LEFT, padx=6)
        self.file_watch_var = tk.StringVar(value="vasp.out,OSZICAR,OUTCAR")
        ttk.Entry(top, textvariable=self.file_watch_var, width=36).pack(side=tk.LEFT)

        fig = Figure(figsize=(6, 4), dpi=100)
        self.ax = fig.add_subplot(111)
        self.ax.set_xlabel("Step")
        self.ax.set_ylabel("Total energy (F or E0) [eV]")
        self.ax.grid(True, linestyle=":", linewidth=0.8)
        self.line, = self.ax.plot([], [], marker="o", linestyle="-")

        self.canvas = FigureCanvasTkAgg(fig, master=frame)
        self.canvas.draw()
        self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True, padx=8, pady=8)

        self.mon_info = ScrolledText(frame, height=6, wrap="word")
        self.mon_info.pack(fill=tk.BOTH, expand=False, padx=8, pady=4)

        sys_frame = ttk.LabelFrame(frame, text="系统状态：CPU / 进程 / 文件增长")
        sys_frame.pack(fill=tk.BOTH, expand=False, padx=8, pady=6)
        self.sys_info = ScrolledText(sys_frame, height=10, wrap="word")
        self.sys_info.pack(fill=tk.BOTH, expand=True, padx=6, pady=6)

        self.sys_info.insert(tk.END, "点击“开始监视”以获取实时系统信息。\n")

        return frame

    def start_monitor(self):
        self.stop_monitor()
        proj = self.current_project_path()
        self.monitor = EnergyMonitor(proj, self.on_energy_update)
        self.monitor.start()
        self.mon_info.insert(tk.END, f"开始监视 {proj / 'OSZICAR'}\n")
        self.mon_info.see(tk.END)
        watch_files = [s.strip() for s in self.file_watch_var.get().split(",") if s.strip()]
        self.sys_monitor = SystemStatsMonitor(proj, watch_files, self.on_system_update)
        self.sys_monitor.start()
        self.sys_info.delete("1.0", tk.END)
        self.sys_info.insert(tk.END, "系统监视线程已启动……\n")
        self.apply_run_status("🟡 正在监视…", ["系统监视线程已启动，等待数据更新。"])

    def stop_monitor(self):
        if self.monitor:
            self.monitor.stop()
            self.monitor = None
        if self.sys_monitor:

            monitor = self.sys_monitor
            self.sys_monitor = None
            monitor.stop()
        self.mon_info.insert(tk.END, "已停止监视。\n")
        self.mon_info.see(tk.END)
        self.sys_info.insert(tk.END, "系统监视已停止。\n")
        self.refresh_run_status()
        self._stop_following_log()

    def on_energy_update(self, steps, energies):
        def _upd():
            # 初始化坐标轴标签只做一次
            if not hasattr(self, "_plot_inited"):
                self.ax.set_xlabel("Step")
                self.ax.set_ylabel("Total energy (F or E0) [eV]")
                self.ax.grid(True, linestyle=":", linewidth=0.8)
                self._plot_inited = True

            # ★ 不再 cla：直接更新 Line2D 数据
            self.line.set_data(steps or [], energies or [])
            self.ax.relim()
            self.ax.autoscale_view()

            self.canvas.draw_idle()
            # 保证布局立即刷新
            self.canvas.get_tk_widget().update_idletasks()

            if energies:
                self.mon_info.insert(tk.END, f"最新步：{steps[-1]}, 能量：{energies[-1]:.6f} eV\n")
                self.mon_info.see(tk.END)

        self.after(0, _upd)

    def on_system_update(self, stats):
        def _upd():
            self._handle_stats(stats)
            lines = []
            run_state = stats.get("run_state")
            run_pids = stats.get("run_pids", [])
            if run_state == "running" and run_pids:
                lines.append(f"运行状态：运行中 (PID {', '.join(run_pids)})")
            elif run_state == "idle":
                lines.append("运行状态：未检测到 VASP 进程")
            else:
                lines.append("运行状态：未知")
            lines.append(f"时间：{stats.get('timestamp', '-')}")
            cpu = stats.get("cpu_usage")
            if cpu is not None:
                lines.append(f"CPU 使用率：{cpu:.1f}%")
            load = stats.get("loadavg")
            if load:
                lines.append(f"平均负载：{load[0]:.2f}, {load[1]:.2f}, {load[2]:.2f}")
            lines.append("监视文件：")
            for item in stats.get("files", []):
                name = item.get("name", "-")
                if item.get("exists"):
                    size = format_bytes(item.get("size"))
                    delta = format_bytes(item.get("delta"))
                    lines.append(f"  {name}: {size} (Δ {delta})")
                else:
                    lines.append(f"  {name}: 未找到")
            procs = stats.get("processes", [])
            if procs:
                lines.append("相关进程 (前5按CPU)：")
                for p in procs:
                    mark = "★" if p.get("is_vasp") else " "
                    lines.append(
                        f" {mark} PID {p.get('pid')} {p.get('cmd')} | CPU {p.get('cpu')} | MEM {p.get('mem')}"
                    )
            else:
                lines.append("未获取到进程信息 (可能无 ps 命令或权限不足)。")
            self.sys_info.delete("1.0", tk.END)
            self.sys_info.insert(tk.END, "\n".join(lines) + "\n")

        self.after(0, _upd)

    # ------------------------- 页面：后处理 ---------------------------
    def _build_post_page(self, parent):
        frame = ttk.Frame(parent)

        # 左栏：带滚动条的控制与日志
        left_container = ttk.Frame(frame)
        left_container.pack(side=tk.LEFT, fill=tk.Y)
        left_canvas = tk.Canvas(left_container, borderwidth=0, highlightthickness=0, width=360)
        left_scroll = ttk.Scrollbar(left_container, orient=tk.VERTICAL, command=left_canvas.yview)
        left_canvas.configure(yscrollcommand=left_scroll.set)
        left_canvas.pack(side=tk.LEFT, fill=tk.Y, expand=False)
        left_scroll.pack(side=tk.RIGHT, fill=tk.Y)

        left = ttk.Frame(left_canvas, padding=8)
        left_window = left_canvas.create_window((0, 0), window=left, anchor="nw")

        style = ttk.Style()
        style.configure("TwBanner.TFrame", background="#e7f1ff")
        style.configure("TwBanner.TLabel", background="#e7f1ff", foreground="#0a5cad")

        self.tw_post_hint_frame = ttk.Frame(left, padding=6, style="TwBanner.TFrame")
        self.tw_post_hint_var = tk.StringVar(value="")
        ttk.Label(
            self.tw_post_hint_frame,
            textvariable=self.tw_post_hint_var,
            wraplength=320,
            justify=tk.LEFT,
            style="TwBanner.TLabel",
        ).pack(side=tk.LEFT, fill=tk.X, expand=True)
        ttk.Button(
            self.tw_post_hint_frame,
            text="快速复算最优 θ,u",
            command=self._tw_jump_to_best_for_refine,
        ).pack(side=tk.RIGHT, padx=(8, 0))
        self._tw_post_hint_visible = False


        def _sync_scrollregion(event):
            left_canvas.configure(scrollregion=left_canvas.bbox("all"))

        def _match_width(event):
            left_canvas.itemconfigure(left_window, width=event.width)

        left.bind("<Configure>", _sync_scrollregion)
        left_canvas.bind("<Configure>", _match_width)

        def _on_mousewheel(event):
            delta = 0
            if event.delta:
                delta = -int(event.delta / 120)
            elif event.num in (4, 5):
                delta = -1 if event.num == 4 else 1
            if delta:
                left_canvas.yview_scroll(delta, "units")
                return "break"

        for widget in (left_canvas, left):
            widget.bind("<MouseWheel>", _on_mousewheel)
            widget.bind("<Button-4>", _on_mousewheel)
            widget.bind("<Button-5>", _on_mousewheel)

        help_overview = textwrap.dedent("""
            【后处理速览】
            • 从当前项目目录读取 vasprun.xml、EIGENVAL、LOCPOT 等文件，一键生成论文级别的图表。
            • 运行任务会把 PNG/CSV 等输出写入 reports/post_时间戳/ 子目录，可随时导出或复用。
            • 勾选多个任务时将按顺序执行，避免同时解析大文件导致内存占用峰值。
        """).strip()
        self._add_section_heading(left, "一键后处理 | 论文级出图/表", help_overview, title="后处理说明", pady=(0, 6))

        row2 = ttk.Frame(left)
        row2.pack(fill=tk.X, pady=2)
        ttk.Label(row2, text="金属性阈值 DOS(E_F) ≤").pack(side=tk.LEFT)
        self.metal_threshold_var = tk.DoubleVar(value=0.02)
        ttk.Entry(row2, textvariable=self.metal_threshold_var, width=8).pack(side=tk.LEFT, padx=4)

        help_tasks = textwrap.dedent("""
            【任务清单】
            • DOS / PDOS：需要 vasprun.xml；PDOS 可按元素、轨道或前 8 个原子分组。
            • bands / bands_lbl：优先使用非自洽 vasprun.xml；若缺失则回退到 EIGENVAL+OUTCAR。
            • emass：在带边邻域做抛物线拟合，给出电子/空穴有效质量估计。
            • pot_z：读取 LOCPOT/CHGCAR，输出平面平均势沿 z 的轮廓。
        """).strip()
        tasks_box = ttk.LabelFrame(left, text="任务勾选")
        tasks_box.pack(fill=tk.X, pady=6)

        self._add_section_heading(left, "可用后处理", help_tasks, title="可用后处理", pady=(0, 4))
        task_defs = [
            ("dos", "总 DOS"),
            ("pdos", "投影 DOS"),
            ("bands", "基础能带"),
            ("bands_lbl", "能带（路径标签）"),
            ("emass", "有效质量 m*"),
            ("pot_z", "平面平均势 V(z)"),
        ]
        self._post_task_vars = {}
        for key, desc in task_defs:
            var = tk.BooleanVar(value=key in ("dos", "bands_lbl"))
            self._post_task_vars[key] = var
            ttk.Checkbutton(tasks_box, text=f"{key} — {desc}", variable=var).pack(anchor=tk.W)

        help_pdos = textwrap.dedent("""
            【PDOS 设置】
            • 运行前请确认 DOS 计算写出了投影（LORBIT=11/12）并保留 vasprun.xml。
            • “按元素/轨道/原子”会聚合不同的投影，导出的 CSV 便于后续在 Origin/Matplotlib 中再加工。
        """).strip()
        pdos_box = ttk.LabelFrame(left, text="投影选项")
        pdos_box.pack(fill=tk.X, pady=6)
        self._add_section_heading(left, "PDOS 设置", help_pdos, title="PDOS 设置", pady=(0, 4))
        self._pdos_group = tk.StringVar(value="element")
        rb_row = ttk.Frame(pdos_box)
        rb_row.pack(fill=tk.X, pady=2)
        ttk.Radiobutton(rb_row, text="按元素", variable=self._pdos_group, value="element").pack(side=tk.LEFT)
        ttk.Radiobutton(rb_row, text="按轨道", variable=self._pdos_group, value="orbital").pack(side=tk.LEFT, padx=(8, 0))
        ttk.Radiobutton(rb_row, text="按原子(前8)", variable=self._pdos_group, value="site").pack(side=tk.LEFT, padx=(8, 0))

        help_emass = textwrap.dedent("""
            【m* 拟合】
            • “窗口 ±k 点” 控制抛物线拟合使用的临近采样，默认取带边两侧各 4 个点。
            • 有效质量仅针对当前路径方向，强各向异性体系请在多个路径上重复评估。
        """).strip()
        em_box = ttk.LabelFrame(left, text="拟合参数")
        em_box.pack(fill=tk.X, pady=6)

        self._add_section_heading(left, "m* 拟合", help_emass, title="有效质量 m*", pady=(0, 4))
        ttk.Label(em_box, text="窗口 ±k 点").pack(side=tk.LEFT)
        self._em_win = tk.IntVar(value=4)
        ttk.Spinbox(em_box, from_=2, to=12, textvariable=self._em_win, width=5).pack(side=tk.LEFT, padx=4)

        help_actions = textwrap.dedent("""
            【运行与导出】
            • “运行所选” 将串行启动后台线程，完成后自动在右侧显示生成的图像预览。
            • 报告目录统一保存在项目 reports/ 下，可通过“打开报告文件夹”快速定位最新一次输出。
            • 日志窗口会记录每个任务的指标 metrics、备注 notes 以及潜在错误信息。
        """).strip()

        self._add_section_heading(left, "运行与导出", help_actions, title="运行与导出", pady=(8, 4))
        btns = ttk.Frame(left)
        btns.pack(fill=tk.X, pady=4)
        ttk.Button(btns, text="运行所选", command=self._run_selected_postprocs).pack(side=tk.LEFT)
        ttk.Button(btns, text="打开报告文件夹", command=self._open_latest_report_dir).pack(side=tk.LEFT, padx=6)
        ttk.Button(btns, text="关闭当前图页", command=self._close_current_post_tab).pack(side=tk.LEFT)

        log_frame = ttk.LabelFrame(left, text="运行日志")
        log_frame.pack(fill=tk.BOTH, expand=True, pady=(4, 0))
        self.post_metrics = ScrolledText(log_frame, height=12, wrap="word")
        self.post_metrics.pack(fill=tk.BOTH, expand=True, padx=4, pady=4)
        self.post_metrics.insert(tk.END, "运行结果与备注将在此显示。\n")
        self.post_metrics.configure(state=tk.DISABLED)

        # 右栏：图像预览
        right = ttk.Frame(frame, padding=8)
        right.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True)
        self.post_fig_area = ttk.Notebook(right)
        self.post_fig_area.pack(fill=tk.BOTH, expand=True)
        self._tw_update_tw_post_hint()

        return frame

    def _run_selected_postprocs(self):
        workdir = self.current_project_path()
        ts = _dt.datetime.now().strftime("%Y%m%d-%H%M%S")
        report_dir = workdir / "reports" / f"post_{ts}"
        style = _normalize_style(self.figure_style_var.get())
        metal_th = float(self.metal_threshold_var.get() or 0.02)

        queue: list[tuple[str, Dict[str, Any]]] = []
        for key, var in self._post_task_vars.items():
            if not var.get():
                continue
            proc = POSTPROCS.get(key)
            if not proc:
                messagebox.showwarning(APP_NAME, f"未知的后处理任务：{key}")
                continue
            has_demo_payload = self.demo_mode and key in DEMO_POSTPROCS
            missing: list[str] = []
            for need in proc.needs:
                options = [n.strip() for n in need.split("|") if n.strip()]
                if not options:
                    continue
                if not any((workdir / opt).exists() for opt in options):
                    missing.append(" 或 ".join(str(workdir / opt) for opt in options))
            if missing and not has_demo_payload:
                messagebox.showwarning(APP_NAME, f"[{key}] 缺少必要文件：\n" + "\n".join(missing))
                continue
            opts: Dict[str, Any] = {
                "style": style,
                "report_dir": report_dir,
                "metal_threshold": metal_th,
                "workdir": workdir,
            }
            if key == "pdos":
                opts.update({"group": self._pdos_group.get(), "energy_window": (-6, 6)})
            if key == "emass":
                opts.update({"window_k": int(self._em_win.get())})
            if self.demo_mode:
                demo_payload = DEMO_POSTPROCS.get(key)
                if demo_payload:
                    opts["demo_payload"] = demo_payload
            queue.append((key, opts))

        if not queue:
            messagebox.showinfo(APP_NAME, "未选择可运行的后处理任务。")
            return

        for key, opts in queue:
            worker = PostprocWorker(self, key, opts)
            worker.start()

    def _open_latest_report_dir(self):
        root = self.current_project_path() / "reports"
        if not root.exists():
            messagebox.showwarning(APP_NAME, "当前项目尚未生成报告。")
            return
        try:
            latest = max((p for p in root.iterdir() if p.is_dir()), key=lambda p: p.stat().st_mtime)
        except ValueError:
            messagebox.showwarning(APP_NAME, "当前项目尚未生成报告。")
            return
        try:
            if sys.platform.startswith("darwin"):
                subprocess.Popen(["open", str(latest)])
            elif os.name == "nt":
                os.startfile(str(latest))  # type: ignore[attr-defined]
            else:
                subprocess.Popen(["xdg-open", str(latest)])
        except Exception as exc:
            messagebox.showerror(APP_NAME, f"打开目录失败：{exc}")

    def _close_current_post_tab(self):
        if not hasattr(self, "post_fig_area"):
            return
        current = self.post_fig_area.select()
        if not current:
            messagebox.showinfo(APP_NAME, "当前没有需要关闭的图页。")
            return
        self.post_fig_area.forget(current)

    def _on_postproc_success(self, key: str, result: PostResult, workdir: Path, opts: Dict[str, Any]):
        self.post_results[key] = result
        report_dir = Path(opts.get("report_dir", workdir / "reports"))
        self.post_latest_reports[key] = report_dir

        self.post_metrics.configure(state=tk.NORMAL)
        self.post_metrics.insert(tk.END, f"[{key}] 成功：{json.dumps(result.metrics, ensure_ascii=False)}\n")
        for note in result.notes:
            self.post_metrics.insert(tk.END, f"  - {note}\n")
        self.post_metrics.see(tk.END)
        self.post_metrics.configure(state=tk.DISABLED)

        for name, path in result.figs.items():
            try:
                tab = ttk.Frame(self.post_fig_area)
                fig = Figure(figsize=(5.0, 3.2))
                ax = fig.add_subplot(111)
                import matplotlib.image as mpimg

                img = mpimg.imread(str(path))
                ax.imshow(img)
                ax.axis("off")
                canvas = FigureCanvasTkAgg(fig, master=tab)
                canvas.draw()
                canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
                self.post_fig_area.add(tab, text=f"{key}:{name}")
            except Exception as exc:
                self.post_metrics.configure(state=tk.NORMAL)
                self.post_metrics.insert(tk.END, f"  ! 图像加载失败：{exc}\n")
                self.post_metrics.configure(state=tk.DISABLED)

    def _on_postproc_error(self, key: str, message: str):
        self.post_metrics.configure(state=tk.NORMAL)
        self.post_metrics.insert(tk.END, f"[{key}] 失败：{message}\n")
        self.post_metrics.see(tk.END)
        self.post_metrics.configure(state=tk.DISABLED)

    def _append_post_log(self, text: str):
        if not hasattr(self, "post_metrics"):
            return
        timestamp = time.strftime("%H:%M:%S")
        self.post_metrics.configure(state=tk.NORMAL)
        self.post_metrics.insert(tk.END, f"[{timestamp}] {text}\n")
        self.post_metrics.see(tk.END)
        self.post_metrics.configure(state=tk.DISABLED)
    def plot_once_from_oszicar(self):
        proj = self.current_project_path()
        osz = proj / "OSZICAR"
        if not osz.exists():
            messagebox.showwarning(APP_NAME, f"{osz} 不存在。")
            return
        steps, energies = [], []
        try:
            with osz.open("r", encoding="utf-8", errors="ignore") as f:
                i = 0
                for line in f:
                    m = ENERGY_RX.search(line)
                    if m:
                        val = m.group(1) or m.group(2)
                        try:
                            e = float(val)
                            i += 1
                            steps.append(i)
                            energies.append(e)
                        except Exception:
                            pass
        except Exception as e:
            messagebox.showerror(APP_NAME, f"解析失败：{e}")
            return
        # 复用监视页画布
        self.on_energy_update(steps, energies)
        self._append_post_log(f"[oszicar] 一次性绘制完成，点数：{len(steps)}")

    def extract_final_energy(self):
        proj = self.current_project_path()
        osz = proj / "OSZICAR"
        if not osz.exists():
            messagebox.showwarning(APP_NAME, f"{osz} 不存在。")
            return
        last_e = None
        try:
            for line in osz.read_text(encoding="utf-8", errors="ignore").splitlines():
                m = ENERGY_RX.search(line)
                if m:
                    val = m.group(1) or m.group(2)
                    try:
                        last_e = float(val)
                    except Exception:
                        pass
        except Exception as e:
            messagebox.showerror(APP_NAME, f"解析失败：{e}")
            return
        if last_e is None:
            messagebox.showwarning(APP_NAME, "未解析到能量。")
        else:
            self._append_post_log(f"[oszicar] 最终能量（最后一步）：{last_e:.6f} eV")

    # ------------------------- 配置读写（保存用户设置） ---------------------
    def load_config(self):
        if not CONFIG_PATH.exists():
            return
        try:
            data = json.loads(CONFIG_PATH.read_text(encoding="utf-8"))
        except Exception:
            return
        # 窗口几何
        geom = data.get("geometry")
        if geom:
            try:
                self.geometry(geom)
            except Exception:
                pass
        # 基本变量
        project_path = data.get("project", self.project_var.get())
        self.pot_dir_var.set(data.get("pot_dir", self.pot_dir_var.get()))
        self.run_mode.set(data.get("run_mode", self.run_mode.get()))
        self.vasp_cmd.set(data.get("vasp_cmd", self.vasp_cmd.get()))
        self.figure_style_var.set(_normalize_style(data.get("figure_style")))
        self.emit_report_var.set(bool(data.get("emit_report", self.emit_report_var.get())))
        try:
            self.mpi_np.set(int(data.get("mpi_np", self.mpi_np.get())))
        except Exception:
            pass
        self.file_watch_var.set(data.get("file_watch", self.file_watch_var.get()))
        # SLURM
        self.slurm_part.set(data.get("slurm_part", self.slurm_part.get()))
        self.slurm_time.set(data.get("slurm_time", self.slurm_time.get()))
        try:
            self.slurm_nodes.set(int(data.get("slurm_nodes", self.slurm_nodes.get())))
            self.slurm_ntasks.set(int(data.get("slurm_ntasks", self.slurm_ntasks.get())))
        except Exception:
            pass
        self.slurm_account.set(data.get("slurm_account", self.slurm_account.get()))
        # K 网格
        k = data.get("kgrid", {})
        for var, key in [(self.k_nx, "nx"),(self.k_ny, "ny"),(self.k_nz, "nz")]:
            try:
                var.set(int(k.get(key, var.get())))
            except Exception:
                pass
        try:
            self.k_gamma.set(bool(k.get("gamma", self.k_gamma.get())))
        except Exception:
            pass
        # 选中的页签
        try:
            idx = int(data.get("tab_index", 0))
            self.nb.select(idx)
        except Exception:
            pass
        self.set_project(project_path)

    def save_config(self):
        project_value = self.project_var.get()
        if self.demo_mode and self._pre_demo_project is not None:
            project_value = str(self._pre_demo_project)
        data = {
            "geometry": self.geometry(),
            "project": project_value,
            "pot_dir": self.pot_dir_var.get(),
            "run_mode": self.run_mode.get(),
            "vasp_cmd": self.vasp_cmd.get(),
            "mpi_np": self._int_from_var(self.mpi_np, 8),
            "figure_style": _normalize_style(self.figure_style_var.get()),
            "emit_report": bool(self.emit_report_var.get()),
            "slurm_part": self.slurm_part.get(),
            "slurm_time": self.slurm_time.get(),
            "slurm_nodes": self._int_from_var(self.slurm_nodes, 1),
            "slurm_ntasks": self._int_from_var(self.slurm_ntasks, 32),
            "slurm_account": self.slurm_account.get(),
            "kgrid": {
                "nx": self._int_from_var(self.k_nx, 5),
                "ny": self._int_from_var(self.k_ny, 5),
                "nz": self._int_from_var(self.k_nz, 5),
                "gamma": bool(self.k_gamma.get()),
            },
            "tab_index": self.nb.index("current"),
            "file_watch": self.file_watch_var.get(),
        }
        try:
            CONFIG_DIR.mkdir(parents=True, exist_ok=True)
            atomic_write_text(CONFIG_PATH, json.dumps(data, ensure_ascii=False, indent=2), encoding="utf-8")
        except Exception:
            pass

    def _register_suggestion_widget(self, widget: tk.Text):
        self.run_suggestion_widgets.append(widget)

    def current_project_path(self) -> Path:
        val = self.project_var.get()
        try:
            proj = Path(val).expanduser()
        except Exception:
            proj = Path(val)
        self.project_dir = proj
        return proj

    @staticmethod
    def _format_elapsed(seconds: Any) -> str:
        if not isinstance(seconds, (int, float)):
            return ""
        total = int(seconds)
        if total < 0:
            return ""
        hours, rem = divmod(total, 3600)
        minutes, secs = divmod(rem, 60)
        return f"已运行 {hours:02d}:{minutes:02d}:{secs:02d}"

    def apply_run_status(self, status_text: str, suggestions: list[str] | None = None):
        self.run_status_var.set(status_text)
        text = "暂无建议。"
        if suggestions:
            text = "\n".join(f"• {s}" for s in suggestions)
        for widget in self.run_suggestion_widgets:
            try:
                widget.configure(state="normal")
                widget.delete("1.0", tk.END)
                widget.insert("1.0", text)
                widget.configure(state="disabled")
            except Exception:
                pass

    def refresh_run_status(self):
        """后台采样 + 主线程更新；带防抖，确保同一时刻最多一个采样线程。"""
        proj = self.current_project_path()
        if not proj.exists():
            self.apply_run_status("⚠️ 项目目录不存在", ["请选择有效的项目路径。"])
            return

        # --- 防抖：已有一次刷新在路上，就直接跳过 ---
        if getattr(self, "_refresh_busy", False):
            return
        self._refresh_busy = True

        watch_files = [s.strip() for s in self.file_watch_var.get().split(",") if s.strip()]

        def _worker():
            try:
                stats = SystemStatsMonitor.snapshot(proj, watch_files)
            except Exception:
                stats = {"run_state": "unknown", "suggestions": ["状态刷新失败。"]}
            finally:
                # 回到主线程：更新 UI，并清除 busy 标记
                def _apply():
                    try:
                        self._handle_stats(stats)
                    finally:
                        self._refresh_busy = False

                self.after(0, _apply)

        threading.Thread(target=_worker, daemon=True).start()

    def _handle_stats(self, stats: dict):
        run_state = stats.get("run_state")
        run_pids = stats.get("run_pids", [])
        run_elapsed = stats.get("run_elapsed")
        elapsed_text = self._format_elapsed(run_elapsed)
        if run_state == "running" and run_pids:
            if elapsed_text:
                status = f"   运行中（{elapsed_text}，PID {', '.join(run_pids)}）"
            else:
                status = f"   运行中 (PID {', '.join(run_pids)})"
        elif run_state == "idle":
            status = "⚪ 未检测到 VASP 进程"
        else:
            status = "⚠️ 状态未知"
        suggestions = stats.get("suggestions") or []
        self.apply_run_status(status, suggestions)
        self.update_overview_with_file_stats(stats.get("files", []))

    def update_overview_with_file_stats(self, file_stats: list[dict]):
        tree = getattr(self, "workflow_tree", None)
        if not tree or not file_stats:
            return
        # 使用现有 iid 判断是否存在
        existing = set(tree.get_children()) | {"__project__", "INCAR", "POSCAR", "KPOINTS", "POTCAR", "CONTCAR",
                                               "vasp.out", "OSZICAR", "OUTCAR"}
        for item in file_stats:
            name = item.get("name")
            if not name:
                continue
            short = Path(name).name
            key = self.overview_key_map.get(short.lower())
            if not key or key not in existing:
                continue
            label = self.overview_label_map.get(key, short)
            if item.get("exists"):
                detail = f"大小 {format_bytes(item.get('size'))}"
                delta = item.get("delta")
                if isinstance(delta, (int, float)):
                    detail += f" | Δ {format_bytes(delta)}"
                status = "📈 输出增长" if isinstance(delta, (int, float)) and delta > 0 else "✅ 已存在"
            else:
                status = "⚠️ 未找到"
                detail = "尚未生成或路径不匹配"
            tree.item(key, values=(label, status, detail))

    def refresh_project_overview(self):
        tree = getattr(self, "workflow_tree", None)
        if not tree:
            return
        for row in tree.get_children():
            tree.delete(row)
        proj = self.current_project_path()
        exists = proj.exists()
        proj_status = "✅ 已存在" if exists else "⚠️ 未找到"
        tree.insert(
            "",
            tk.END,
            iid="__project__",
            values=(self.overview_label_map.get("__project__", "项目目录"), proj_status, str(proj)),
        )
        for key, label in self.overview_items:
            if key == "__project__":
                continue
            path = proj / key
            if path.exists():
                try:
                    stat = path.stat()
                    mtime = time.strftime("%Y-%m-%d %H:%M", time.localtime(stat.st_mtime))
                    status = "✅ 已存在"
                    detail = f"更新于 {mtime} | {format_bytes(stat.st_size)}"
                except Exception:
                    status = "✅ 已存在"
                    detail = "已检测到文件"
            else:
                status = "⚠️ 未找到"
                detail = "项目目录中未检测到该文件"
            tree.insert("", tk.END, iid=key, values=(label, status, detail))

    def load_project_inputs(self):
        proj = self.current_project_path()
        mapping = [
            (proj / "INCAR", getattr(self, "incar_text", None)),
            (proj / "POSCAR", getattr(self, "poscar_text", None)),
            (proj / "KPOINTS", getattr(self, "kpoints_text", None)),
        ]
        for path, widget in mapping:
            if not widget or not path.exists():
                continue
            try:
                widget.delete("1.0", tk.END)
                widget.insert("1.0", read_text(path))
            except Exception:
                pass
        self._update_tw_entry_banner()
        self._tw_update_tw_post_hint()

    def set_project(self, path: Path):
        try:
            path = Path(path).expanduser()
        except Exception:
            path = Path(path)
        self.project_dir = path
        self.project_var.set(str(path))
        self.load_project_inputs()
        self.refresh_project_overview()
        self.refresh_run_status()
        self._update_tw_entry_banner()
        self._tw_update_tw_post_hint()

    # ------------------------- 项目与体检 ----------------------------------
    def choose_project(self):
        d = filedialog.askdirectory(initialdir=self.project_var.get(), title="选择项目目录")
        if d:
            self.set_project(Path(d))

    def create_project(self):
        d = filedialog.askdirectory(initialdir=str(Path.home()), title="选择或创建项目父目录")
        if not d:
            return
        # 创建以时间命名的项目
        base = Path(d)
        name = time.strftime("vasp_proj_%Y%m%d_%H%M%S")
        p = base / name
        p.mkdir(parents=True, exist_ok=True)
        self.set_project(p)
        messagebox.showinfo(APP_NAME, f"已创建项目目录：{p}")

    def quick_check(self):
        self.quick_preflight()

    def quick_preflight(self):
        report = self._collect_preflight_checks()
        if not report:
            return
        log_lines = report.get("log_lines", [])
        if log_lines:
            self.append_run_log("\n".join(log_lines) + "\n")
        self.refresh_project_overview()
        self.refresh_run_status()
        self._show_preflight_dialog(report)

    def _parse_incar_map(self, text: str) -> tuple[dict[str, str], list[tuple[str, str, str]]]:
        mapping: dict[str, str] = {}
        typos: list[tuple[str, str, str]] = []
        for line in text.splitlines():
            stripped = line.strip()
            if not stripped or stripped.startswith("#") or stripped.startswith("!"):
                continue
            if "=" not in stripped:
                continue
            key_part, value_part = stripped.split("=", 1)
            key_clean = key_part.strip().upper()
            if not key_clean:
                continue
            value = value_part.strip()
            for sep in ("!", "#"):
                idx = value.find(sep)
                if idx != -1:
                    value = value[:idx].strip()
                    break
            key_norm = KEY_CORRECTIONS.get(key_clean, key_clean)
            mapping[key_norm] = value
            if key_norm != key_clean:
                typos.append((key_clean, key_norm, value))
        return mapping, typos

    def _apply_incar_patch(self, patch: dict[str, Optional[str]], message: str | None = None) -> str:
        proj = self.current_project_path()
        proj.mkdir(parents=True, exist_ok=True)
        incar_path = proj / "INCAR"
        if incar_path.exists():
            base_text = read_text(incar_path)
        else:
            base_text = self.incar_text.get("1.0", tk.END)
        new_text = self._update_incar_text(base_text, patch)
        write_text(incar_path, new_text)
        try:
            self.incar_text.delete("1.0", tk.END)
            self.incar_text.insert("1.0", new_text)
        except Exception:
            pass
        try:
            self.refresh_incar_simple_panel()
        except Exception:
            pass
        self.refresh_project_overview()
        if message:
            self.append_run_log(message + "\n")
        return new_text

    def _collect_preflight_checks(self) -> dict[str, Any]:
        proj = self.current_project_path()
        items: list[PreflightItem] = []
        log_lines: list[str] = []
        icon_map = {"error": "❌", "warn": "⚠️", "ok": "✅", "info": "ℹ️"}

        def _add(level: str, title: str, detail: str, fix: Callable[[], None] | None = None,
                 fix_label: str | None = None, auto: bool = True) -> None:
            item = PreflightItem(level=level, title=title, detail=detail, fix=fix, fix_label=fix_label, auto=auto)
            items.append(item)
            icon = icon_map.get(level, "•")
            log_lines.append(f"[Preflight]{icon} {title} - {detail}")

        proj_exists = proj.exists()
        if proj_exists:
            _add("ok", "项目目录", f"{proj}")
        else:
            _add("error", "项目目录", f"{proj} 不存在，部分检查可能无法完成。", auto=False)

        incar_path = proj / "INCAR"
        poscar_path = proj / "POSCAR"
        kpoints_path = proj / "KPOINTS"
        potcar_path = proj / "POTCAR"

        incar_text = read_text(incar_path) if incar_path.exists() else self.incar_text.get("1.0", tk.END)
        poscar_text = read_text(poscar_path) if poscar_path.exists() else self.poscar_text.get("1.0", tk.END)
        kpoints_text = read_text(kpoints_path) if kpoints_path.exists() else self.kpoints_text.get("1.0", tk.END)

        incar_map, incar_typos = self._parse_incar_map(incar_text)

        def _check_file(name: str, path: Path, editor: tk.Text | None, *, critical: bool) -> None:
            if path.exists():
                _add("ok", f"{name} 文件", f"{path.name} 已存在")
                return
            editor_content = ""
            if editor is not None:
                try:
                    editor_content = editor.get("1.0", tk.END).strip()
                except Exception:
                    editor_content = ""
            if editor_content:
                _add(
                    "warn",
                    f"{name} 文件",
                    f"{path.name} 尚未保存到 {proj}",
                    fix=partial(self.save_from_editor, name, editor),
                    fix_label=f"保存 {name}",
                    auto=False,
                )
            else:
                level = "error" if critical else "warn"
                _add(level, f"{name} 文件", f"未在项目目录中检测到 {path.name}", auto=False)

        _check_file("INCAR", incar_path, getattr(self, "incar_text", None), critical=True)
        _check_file("POSCAR", poscar_path, getattr(self, "poscar_text", None), critical=True)
        _check_file("KPOINTS", kpoints_path, getattr(self, "kpoints_text", None), critical=False)

        if potcar_path.exists():
            pot_text = read_text(potcar_path)
            titel_lines = [ln for ln in pot_text.splitlines() if ln.strip().startswith("TITEL")]
            _add("ok", "POTCAR 赝势", f"检测到 {len(titel_lines)} 条 TITEL 记录")
        else:
            _add("error", "POTCAR 赝势", "项目目录缺少 POTCAR，请先拼接赝势。", auto=False)

        potroot = Path(self.pot_dir_var.get())
        if potroot.exists():
            _add("info", "赝势库路径", f"{potroot}")
        else:
            _add("warn", "赝势库路径", f"{potroot} 不存在，请确认设置。", auto=False)

        if poscar_text.strip():
            poscar_elements, poscar_counts = parse_poscar(poscar_text)
            if poscar_elements:
                _add("info", "POSCAR 元素", ", ".join(poscar_elements))
            else:
                _add("warn", "POSCAR 解析", "未能解析元素，请检查第6/7行。", auto=False)
        else:
            poscar_elements, poscar_counts = [], []
            _add("error", "POSCAR 内容", "POSCAR 内容为空。", auto=False)

        if potcar_path.exists() and poscar_elements:
            pot_text = read_text(potcar_path)
            titel_lines = [ln for ln in pot_text.splitlines() if ln.strip().startswith("TITEL")]
            if len(titel_lines) < len(poscar_elements):
                _add("warn", "POTCAR 匹配", "POTCAR 中的赝势数量少于 POSCAR 元素数量。", auto=False)

        for key in ("ENCUT", "EDIFF"):
            if key not in incar_map:
                _add("warn", "INCAR 关键参数", f"未设置 {key}，请确认是否符合计算需求。", auto=False)

        if incar_typos:
            typo_desc = ", ".join(f"{orig} → {norm}" for orig, norm, _ in incar_typos)

            def _fix_typos() -> None:
                patch: dict[str, Optional[str]] = {}
                for orig, norm, value in incar_typos:
                    if norm not in incar_map:
                        patch[norm] = value
                    patch[orig] = None
                self._apply_incar_patch(patch, message=f"已自动更正 INCAR 键名：{typo_desc}")

            _add("warn", "INCAR 键名", f"检测到可能的拼写：{typo_desc}", fix=_fix_typos, fix_label="自动更正键名")

        structure = None
        vacuum_ang = None
        is_slab = False
        if HAS_PYMATGEN:
            try:
                from pymatgen.core import Structure  # type: ignore

                if poscar_path.exists():
                    structure = Structure.from_file(str(poscar_path))
                elif poscar_text.strip():
                    structure = Structure.from_str(poscar_text, fmt="poscar")
            except Exception:
                structure = None

        if structure is not None:
            try:
                cart_z = [structure.lattice.get_cartesian_coords(site.frac_coords)[2] for site in structure]
                if cart_z:
                    z_min = min(cart_z)
                    z_max = max(cart_z)
                    z_span = z_max - z_min
                    c_len = structure.lattice.c
                    vacuum_ang = max(c_len - z_span, 0.0)
                    try:
                        if hasattr(structure, "is_low_dimensional") and structure.is_low_dimensional(2):
                            is_slab = True
                    except Exception:
                        pass
                    if not is_slab and vacuum_ang is not None:
                        is_slab = vacuum_ang > 6.0 and c_len > 15.0
            except Exception:
                structure = None

        has_kpoints = kpoints_path.exists()
        kspacing_value: float | None = None
        if "KSPACING" in incar_map:
            try:
                kspacing_value = float(str(incar_map["KSPACING"]).split()[0])
            except Exception:
                kspacing_value = None

        if not has_kpoints and kspacing_value is None:

            def _fix_kspacing() -> None:
                self._apply_incar_patch({"KSPACING": "0.22"}, message="已补充 KSPACING = 0.22")

            _add(
                "error",
                "K 网格",
                "未检测到 KPOINTS 或 KSPACING，VASP 将退回粗糙默认网格。",
                fix=_fix_kspacing,
                fix_label="设置 KSPACING=0.22",
            )
        elif has_kpoints and kspacing_value is not None:
            _add("info", "K 网格", "检测到 KPOINTS 与 KSPACING 同时存在，VASP 将优先使用 KPOINTS 文件。", auto=False)
        elif kspacing_value is not None and structure is not None:
            try:
                lengths = structure.lattice.reciprocal_lattice.lengths
                approx = [max(1, int(round(l / kspacing_value))) for l in lengths]
                _add(
                    "info",
                    "KSPACING 估算",
                    f"KSPACING ≈ {kspacing_value:.3f} Å⁻¹ → 约 {approx[0]}×{approx[1]}×{approx[2]} 网格",
                    auto=False,
                )
            except Exception:
                pass

        if is_slab:
            ldipol_raw = incar_map.get("LDIPOL")
            ldipol_true = str(ldipol_raw).strip().upper() in {".TRUE.", "TRUE", "T"}
            idipol_val = str(incar_map.get("IDIPOL", "")).strip()

            def _apply_dipole() -> None:
                self._apply_incar_patch({"LDIPOL": ".TRUE.", "IDIPOL": "3"}, message="已启用 LDIPOL/IDIPOL=3")

            vac_text = f"，真空约 {vacuum_ang:.1f} Å" if vacuum_ang is not None else ""
            if not ldipol_true:
                _add(
                    "warn",
                    "薄膜偶极修正",
                    f"检测到 2D/薄膜结构{vac_text}，建议启用 LDIPOL=.TRUE., IDIPOL=3。",
                    fix=_apply_dipole,
                    fix_label="写入 LDIPOL/IDIPOL",
                )
            elif idipol_val not in {"3", "2", "1"} or idipol_val != "3":
                _add(
                    "warn",
                    "薄膜偶极修正",
                    "已启用 LDIPOL，但 IDIPOL≠3，建议沿 c 方向取 3。",
                    fix=lambda: self._apply_incar_patch({"IDIPOL": "3"}, message="已设置 IDIPOL=3"),
                    fix_label="设置 IDIPOL=3",
                )
            else:
                _add("info", "薄膜偶极修正", "已启用 LDIPOL/IDIPOL=3，可在必要时补充 DIPOL 中点。", auto=False)

        gap_value: float | None = None
        band_character = "unknown"

        def _bandgap_from_vasprun(vpath: Path) -> float | None:
            try:
                import xml.etree.ElementTree as ET

                for _, elem in ET.iterparse(str(vpath), events=("end",)):
                    if elem.tag == "i" and elem.attrib.get("name", "").lower() == "bandgap":
                        text = (elem.text or "").strip()
                        elem.clear()
                        if text:
                            return float(text)
                return None
            except Exception:
                return None

        vasprun_path = proj / "vasprun.xml"
        if vasprun_path.exists():
            gap_value = _bandgap_from_vasprun(vasprun_path)

        if gap_value is None:
            dos_data = _parse_dos_doscar(proj)
            if dos_data:
                energies = dos_data.get("energies", [])
                dos_vals = dos_data.get("dos", [])
                fermi = dos_data.get("fermi") or 0.0
                rel = [e - fermi for e in energies]
                gap_est, band_type = _estimate_gap_from_dos(rel, dos_vals, 0.02)
                if band_type == "metal":
                    gap_value = 0.0
                    band_character = "metal"
                elif gap_est > 0:
                    gap_value = gap_est
                    band_character = "semiconductor"

        if gap_value is not None and band_character == "unknown":
            if gap_value <= 0.05:
                band_character = "metal"
                gap_value = 0.0
            else:
                band_character = "semiconductor"

        smear_reco = ("0", "0.05")
        smear_desc = "默认建议 ISMEAR=0, SIGMA=0.05"
        if band_character == "metal":
            smear_reco = ("1", "0.2")
            smear_desc = "检测到金属性（带隙≈0），建议 ISMEAR=1, SIGMA≈0.2"
        elif band_character in {"semiconductor", "insulator"}:
            if gap_value is not None:
                smear_desc = f"检测到带隙 ~ {gap_value:.2f} eV，建议 ISMEAR=0, SIGMA=0.05"
            else:
                smear_desc = "检测到带隙型体系，建议 ISMEAR=0, SIGMA=0.05"

        isme_current = incar_map.get("ISMEAR")
        sigma_current = incar_map.get("SIGMA")
        smear_fix_needed = False

        def _int_or_none(val: str | None) -> int | None:
            if val is None:
                return None
            try:
                return int(float(val))
            except Exception:
                return None

        if isme_current is None:
            smear_fix_needed = True
        else:
            isme_int = _int_or_none(isme_current)
            if band_character == "metal" and isme_int not in {1, 2}:
                smear_fix_needed = True
            elif band_character in {"semiconductor", "insulator"} and isme_int not in {0, -5}:
                smear_fix_needed = True

        if sigma_current is None:
            smear_fix_needed = True
        else:
            try:
                if abs(float(sigma_current) - float(smear_reco[1])) > 0.05:
                    smear_fix_needed = True
            except Exception:
                smear_fix_needed = True

        if smear_fix_needed:
            _add(
                "warn",
                "展宽参数",
                smear_desc,
                fix=lambda: self._apply_incar_patch({"ISMEAR": smear_reco[0], "SIGMA": smear_reco[1]}, message="已更新 ISMEAR/SIGMA"),
                fix_label=f"设置 ISMEAR={smear_reco[0]}",
            )
        else:
            _add("info", "展宽参数", smear_desc, auto=False)

        spin = incar_map.get("ISPIN")
        spin_int = _int_or_none(spin)
        if spin_int == 2 and "MAGMOM" not in incar_map:
            if poscar_counts:
                template = " ".join(f"{cnt}*1.0" for cnt in poscar_counts)
            else:
                template = "1*1.0"

            def _fix_magmom() -> None:
                self._apply_incar_patch({"MAGMOM": template}, message="已写入示例 MAGMOM")

            _add(
                "warn",
                "磁性初始化",
                f"ISPIN=2 但未设置 MAGMOM，已准备模板：{template}",
                fix=_fix_magmom,
                fix_label="写入 MAGMOM 模板",
            )

        if str(incar_map.get("LHFCALC", "")).strip().upper() not in {".TRUE.", "TRUE", "T"}:

            def _apply_hse() -> None:
                patch = {
                    "LHFCALC": ".TRUE.",
                    "HFSCREEN": "0.2",
                    "AEXX": "0.25",
                    "ALGO": "Damped",
                    "TIME": "0.4",
                    "PRECFOCK": "Fast",
                    "ISMEAR": "0",
                    "SIGMA": "0.05",
                }
                self._apply_incar_patch(patch, message="已切换至 HSE06 核心标签")

            detail = "PBE 带隙通常偏低，关键构型可追加 HSE06 复算以获得对照。"
            _add("info", "混成泛函提醒", detail, fix=_apply_hse, fix_label="切换到 HSE06", auto=False)

        cmds = ["mpirun", self.vasp_cmd.get().strip(), "sbatch"]
        if os.name == "nt":
            cmds.append("wsl")
        seen_cmds = set()
        for cmd in cmds:
            if not cmd or cmd in seen_cmds:
                continue
            seen_cmds.add(cmd)
            resolved = which(cmd)
            if resolved:
                _add("info", f"命令 {cmd}", resolved, auto=False)
            elif cmd not in {"sbatch", "wsl"}:
                _add("warn", f"命令 {cmd}", f"未在 PATH 中找到 {cmd}，可能无法直接调用。", auto=False)

        has_errors = any(item.level == "error" for item in items)
        return {"items": items, "log_lines": log_lines, "has_errors": has_errors}

    def _show_preflight_dialog(self, report: dict[str, Any]) -> None:
        existing = getattr(self, "_preflight_window", None)
        if existing and existing.winfo_exists():
            try:
                existing.destroy()
            except Exception:
                pass

        top = tk.Toplevel(self)
        top.title("快速体检 (Preflight)")
        top.geometry("720x520")
        top.transient(self)
        self._preflight_window = top

        frame = ttk.Frame(top, padding=12)
        frame.pack(fill=tk.BOTH, expand=True)

        summary_var = tk.StringVar()
        ttk.Label(frame, textvariable=summary_var, font=("Arial", 11, "bold")).pack(anchor=tk.W)

        tree_frame = ttk.Frame(frame)
        tree_frame.pack(fill=tk.BOTH, expand=True, pady=8)
        columns = ("status", "title", "detail")
        tree = ttk.Treeview(tree_frame, columns=columns, show="headings", height=12)
        tree.heading("status", text="状态")
        tree.heading("title", text="检查项")
        tree.heading("detail", text="详情")
        tree.column("status", width=70, anchor=tk.CENTER)
        tree.column("title", width=160, anchor=tk.W)
        tree.column("detail", anchor=tk.W, stretch=True)
        tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scroll = ttk.Scrollbar(tree_frame, orient=tk.VERTICAL, command=tree.yview)
        scroll.pack(side=tk.RIGHT, fill=tk.Y)
        tree.configure(yscrollcommand=scroll.set)

        fix_frame = ttk.LabelFrame(frame, text="一键修复")
        fix_frame.pack(fill=tk.X, pady=4)

        btn_bar = ttk.Frame(frame)
        btn_bar.pack(fill=tk.X, pady=(6, 0))

        status_icon = {"error": "❌", "warn": "⚠️", "ok": "✅", "info": "ℹ️"}

        def _apply_fix(item: PreflightItem) -> None:
            if not item.fix:
                return
            try:
                item.fix()
            except Exception as exc:  # noqa: BLE001
                messagebox.showerror(APP_NAME, f"修复失败：{exc}")
            finally:
                _refresh()

        def _apply_all() -> None:
            current_items = report_state.get("items", [])
            for item in current_items:
                if item.fix and item.auto:
                    try:
                        item.fix()
                    except Exception as exc:  # noqa: BLE001
                        messagebox.showerror(APP_NAME, f"修复失败：{exc}")
                        break
            _refresh()

        report_state = {"items": report.get("items", [])}

        def _render(rep: dict[str, Any]) -> None:
            items_now: list[PreflightItem] = rep.get("items", [])
            report_state["items"] = items_now
            for row in tree.get_children():
                tree.delete(row)
            counts = {"error": 0, "warn": 0, "ok": 0, "info": 0}
            for item in items_now:
                counts[item.level] = counts.get(item.level, 0) + 1
                tree.insert("", tk.END, values=(status_icon.get(item.level, "•"), item.title, item.detail))
            summary_var.set(
                f"共 {len(items_now)} 项检查：❌ {counts.get('error',0)} | ⚠️ {counts.get('warn',0)} | ✅ {counts.get('ok',0)} | ℹ️ {counts.get('info',0)}"
            )
            for child in fix_frame.winfo_children():
                child.destroy()
            actions = [item for item in items_now if item.fix]
            auto_items = [item for item in actions if item.auto]
            if actions:
                if auto_items:
                    ttk.Button(fix_frame, text="一键修复常见项", command=_apply_all).pack(side=tk.LEFT, padx=4, pady=4)
                for item in actions:
                    label = item.fix_label or f"修复：{item.title}"
                    ttk.Button(
                        fix_frame,
                        text=label,
                        command=lambda it=item: _apply_fix(it),
                    ).pack(side=tk.LEFT, padx=4, pady=4)
            else:
                ttk.Label(fix_frame, text="当前无需自动修复，所有检查项均已通过。", foreground="#228833").pack(anchor=tk.W, padx=4, pady=4)

        def _refresh() -> None:
            new_report = self._collect_preflight_checks()
            if new_report:
                _render(new_report)

        ttk.Button(btn_bar, text="重新检查", command=_refresh).pack(side=tk.LEFT)
        ttk.Button(btn_bar, text="关闭", command=top.destroy).pack(side=tk.RIGHT)

        _render(report)
        try:
            top.grab_set()
        except Exception:
            pass

    # === 并行推断辅助 ===
    def _read_file_text(self, p: Path) -> str:
        try:
            return p.read_text(encoding="utf-8", errors="ignore")
        except Exception:
            return ""

    def _incar_get(self, key: str) -> int | None:
        txt = self._read_file_text(self.current_project_path() / "INCAR")
        m = re.search(rf"(?mi)^\s*{re.escape(key)}\s*=\s*([-+]?\d+)", txt)
        return int(m.group(1)) if m else None

    def _incar_upsert(self, key: str, val: int):
        """在 INCAR 中插入/更新形如 'KEY = val' 的行：
        - 匹配不区分大小写，仅替换第一处，以保留后续注释或模板段落
        - 保留原有行前缩进
        - 追加时确保文件末尾带换行
        """
        proj = self.current_project_path()
        incar = proj / "INCAR"
        txt = self._read_file_text(incar)

        # 目标行（不带末尾换行，写入时再统一补 '\n'）
        new_line = f"{key:6s} = {val}"

        # 匹配：行首可有空白，然后是 key，再等号到行尾；忽略大小写、多行模式
        # 使用命名分组 'lead' 保留原有缩进
        pattern = re.compile(rf"(?mi)^(?P<lead>\s*){re.escape(key)}\s*=.*$")

        m = pattern.search(txt)
        if m:
            # 仅替换第一处匹配，保持该行原有缩进
            def _repl(mm: re.Match) -> str:
                lead = mm.group('lead') or ''
                return f"{lead}{new_line}"

            txt = pattern.sub(_repl, txt, count=1)
            # 确保文件以换行结尾
            if not txt.endswith("\n"):
                txt += "\n"
        else:
            # 末尾补换行后再追加新行
            if txt and not txt.endswith("\n"):
                txt += "\n"
            txt += new_line + "\n"

        write_text(incar, txt)

    def _infer_nbands(self) -> int | None:
        outcar = self.current_project_path() / "OUTCAR"
        m = re.search(r"(?mi)\bNBANDS\s*=\s*(\d+)", self._read_file_text(outcar))
        return int(m.group(1)) if m else None

    def _infer_kpoints_total(self) -> int | None:
        """粗略从 KPOINTS 取 Monkhorst-Pack 网格乘积；line-mode 留空。"""
        kp = self.current_project_path() / "KPOINTS"
        s = self._read_file_text(kp).splitlines()
        if len(s) >= 4 and re.search(r"(?i)gamma|monkhorst", s[2]):
            try:
                nx, ny, nz = map(int, s[3].split()[:3])
                return max(1, nx * ny * nz)
            except Exception:
                return None
        return None

    def _best_divisor(self, n: int, choices=(8, 6, 4, 3, 2, 1)) -> int:
        for c in choices:
            if n % c == 0: return c
        return 1

    def _autotune_parallel_and_write(self, np_total: int):
        """核心：根据 -np / NBANDS / KPOINTS 推断 KPAR 与 NCORE，并写回 INCAR。"""
        # 1) 读现有设置（用户若已手动设定，尊重并只做校验）
        ncore_user = self._incar_get("NCORE")
        kpar_user = self._incar_get("KPAR")

        # 2) 粗略信息
        nbands = self._infer_nbands() or 12  # 缺省 12（小体系常见）
        ktot = self._infer_kpoints_total() or np_total  # 没法判断就放宽

        # 3) 选一个合理的 NCORE（要能整除 -np）
        ncore = ncore_user if ncore_user and np_total % ncore_user == 0 else self._best_divisor(np_total)

        # 4) 估 groups（band 并行组数），不能超过 NBANDS
        groups_max = max(1, nbands)
        # KPAR 先给个上限（不能超过总 k 点的粗略值）
        kpar_max = max(1, min(ktot, np_total // ncore))

        # 若用户指定了 KPAR 就尽量用，否则我们分配尽量多的 k 点并行
        if kpar_user:
            kpar = max(1, min(kpar_user, kpar_max))
        else:
            # 让剩余核数 /ncore 尽量落到“<= NBANDS”的组数
            # np_total = KPAR * NCORE * groups  →  groups = np_total/(KPAR*NCORE)
            kpar = kpar_max
            while kpar > 1 and np_total // (kpar * ncore) > groups_max:
                kpar -= 1
            # 还要让整除成立
            while kpar > 1 and (np_total % (kpar * ncore) != 0):
                kpar -= 1
            kpar = max(1, kpar)

        groups = max(1, np_total // (kpar * ncore))

        # 5) 写回（只有当自动模式勾选或用户未设置时才写）
        if self.auto_parallel.get() or (ncore_user is None):
            self._incar_upsert("NCORE", ncore)
        if self.auto_parallel.get() or (kpar_user is None):
            self._incar_upsert("KPAR", kpar)

        self.append_run_log(
            f"[auto-parallel] np={np_total}, 推断: NCORE={ncore}, KPAR={kpar}, groups≈{groups}, NBANDS≈{nbands}, K总≈{ktot}")

    def _plots_dir(self) -> Path:
        d = self.current_project_path() / "plots"
        d.mkdir(parents=True, exist_ok=True)
        return d

    def export_convergence(self):
        proj = self.current_project_path()
        osz = proj / "OSZICAR"
        if not osz.exists():
            messagebox.showwarning(APP_NAME, f"{osz} 不存在。");
            return
        steps, energies = [], []
        with osz.open("r", encoding="utf-8", errors="ignore") as f:
            i = 0
            for line in f:
                m = ENERGY_RX.search(line)
                if m:
                    val = m.group(1) or m.group(2)
                    try:
                        e = float(val.replace("D", "E").replace("d", "E"))
                        i += 1;
                        steps.append(i);
                        energies.append(e)
                    except:
                        pass
        if not energies:
            messagebox.showwarning(APP_NAME, "OSZICAR 未解析到能量。");
            return

        # 图
        fig = Figure(figsize=(6, 4), dpi=140);
        ax = fig.add_subplot(111)
        ax.plot(steps, energies, marker="o", linestyle="-")
        ax.set_xlabel("Ionic step");
        ax.set_ylabel("Total energy [eV]")
        ax.grid(True, linestyle=":", linewidth=0.8)
        canvas = FigureCanvasTkAgg(fig, master=self.page_post); canvas.draw()
        canvas.draw()

        out = self._plots_dir()
        png = out / "convergence.png";
        svg = out / "convergence.svg";
        csv = out / "convergence.csv"
        fig.savefig(png, bbox_inches="tight");
        fig.savefig(svg, bbox_inches="tight")
        with (csv).open("w", encoding="utf-8") as g:
            g.write("step,energy_eV\n");
            g.writelines(f"{s},{e}\n" for s, e in zip(steps, energies))
        self.post_log.insert(tk.END, f"已导出收敛图：{png}\nSVG：{svg}\nCSV：{csv}\n")

    def _fermi_from_outcar(self) -> float | None:
        m = re.search(r"(?mi)E-fermi\s*:\s*([-\d.Ee+]+)", self._read_file_text(self.current_project_path() / "OUTCAR"))
        return float(m.group(1)) if m else None

    def export_dos_total(self):
        proj = self.current_project_path()
        doscar = proj / "DOSCAR"
        if not doscar.exists():
            messagebox.showwarning(APP_NAME, "未找到 DOSCAR。请先做 DOS 计算。");
            return
        ef = self._fermi_from_outcar() or 0.0

        with doscar.open("r", encoding="utf-8", errors="ignore") as f:
            lines = f.read().splitlines()
        if len(lines) < 6:
            messagebox.showwarning(APP_NAME, "DOSCAR 文件太短。");
            return
        # 第6行起为 DOS 数据，直到 NEDOS 行数结束；简单做法：跳过前5行，直到遇到空行/非数字
        data = []
        for ln in lines[5:]:
            parts = ln.split()
            if len(parts) < 3: break
            try:
                nums = list(map(float, parts))
                data.append(nums)
            except:
                break
        if not data:
            messagebox.showwarning(APP_NAME, "未解析到 DOS 数据。");
            return

        arr = list(zip(*data))  # 转置
        E = [x - ef for x in arr[0]]
        if len(arr) >= 5:  # 自旋极化：E, DOS_up, DOS_dn, Int_up, Int_dn
            DOS = [u + d for u, d in zip(arr[1], arr[2])]
        else:  # 非极化：E, DOS, Int
            DOS = list(arr[1])

        # 图
        fig = Figure(figsize=(6, 4), dpi=140);
        ax = fig.add_subplot(111)
        ax.plot(E, DOS, linewidth=1.2)
        ax.axvline(0.0, linestyle="--", linewidth=0.8)  # EF
        ax.set_xlabel("Energy - $E_F$ (eV)");
        ax.set_ylabel("DOS (states/eV)")
        ax.grid(True, linestyle=":", linewidth=0.8)
        out = self._plots_dir()
        png = out / "dos_total.png";
        svg = out / "dos_total.svg";
        csv = out / "dos_total.csv"
        fig.savefig(png, bbox_inches="tight");
        fig.savefig(svg, bbox_inches="tight")
        with (csv).open("w", encoding="utf-8") as g:
            g.write("E-EF,DOS\n");
            g.writelines(f"{x},{y}\n" for x, y in zip(E, DOS))
        self.post_log.insert(tk.END, f"已导出 DOS：{png}\nSVG：{svg}\nCSV：{csv}\n")

    def export_bands(self):
        proj = self.current_project_path()
        eig = proj / "EIGENVAL"
        if not eig.exists():
            messagebox.showwarning(APP_NAME, "未找到 EIGENVAL。请使用 KPOINTS 路径做 band 计算。");
            return
        ef = self._fermi_from_outcar() or 0.0
        txt = self._read_file_text(eig).splitlines()

        # 头部：第6行通常包含 NKPTS, NBANDS, NIONS
        try:
            parts = txt[5].split()
            nk, nb = int(parts[0]), int(parts[1])
        except Exception:
            messagebox.showwarning(APP_NAME, "EIGENVAL 头部解析失败。");
            return

        i = 6
        kpts = []
        bands = [[] for _ in range(nb)]

        for _ in range(nk):
            # 跳过空行（有些版本每个 k-block 前有空行）
            while i < len(txt) and not txt[i].strip():
                i += 1
            if i >= len(txt):
                break

            # kx ky kz w
            try:
                kx, ky, kz, w = map(float, txt[i].split()[:4])
            except Exception:
                messagebox.showwarning(APP_NAME, "EIGENVAL k 点块格式异常。")
                return
            i += 1
            kpts.append((kx, ky, kz))

            # nb 行： bandIndex, energy, occ
            for b in range(nb):
                parts = txt[i].split()
                e = float(parts[1]) - ef
                bands[b].append(e)
                i += 1

        import math
        xs = [0.0]
        for a, b in zip(kpts[:-1], kpts[1:]):
            xs.append(xs[-1] + math.dist(a, b))

        fig = Figure(figsize=(6, 4), dpi=140)
        ax = fig.add_subplot(111)
        for b in range(nb):
            ax.plot(xs, bands[b], linewidth=0.8)
        ax.axhline(0, linestyle="--", linewidth=0.8)  # EF
        ax.set_xlabel("k-path (arb.)")
        ax.set_ylabel("Energy - $E_F$ (eV)")
        ax.grid(True, linestyle=":", linewidth=0.8)
        out = self._plots_dir()
        png, svg, csv = out / "bands.png", out / "bands.svg", out / "bands.csv"
        fig.savefig(png, bbox_inches="tight")
        fig.savefig(svg, bbox_inches="tight")
        with csv.open("w", encoding="utf-8") as g:
            g.write("k," + ",".join(f"band{b + 1}" for b in range(nb)) + "\n")
            for j in range(nk):
                row = [f"{xs[j]}"] + [f"{bands[b][j]}" for b in range(nb)]
                g.write(",".join(row) + "\n")
        self.post_log.insert(tk.END, f"已导出能带：{png}\nSVG：{svg}\nCSV：{csv}\n")

    def import_project_files(self):
        """把项目目录下的 INCAR/POSCAR/KPOINTS 一键读入三个编辑器，并刷新概览与状态。"""
        self.load_project_inputs()
        self.refresh_project_overview()
        self.refresh_run_status()
        messagebox.showinfo(APP_NAME, "已读取项目文件并刷新状态。")

    # ------------------------- 退出清理 ------------------------------------
    def on_close(self):
        try:
            # 保存配置
            self.save_config()
            # 停止监视与 tail 进程
            self.stop_monitor()
            if self.proc and self.proc.poll() is None:
                self.proc.terminate()
            self._cleanup_demo_project()
        except Exception:
            pass
        self.destroy()
        self._stop_following_log()


class FirstTimeWizard(tk.Toplevel):
    def __init__(self, master: VaspGUI):
        super().__init__(master)
        self.result: WizardProfile | None = None
        self.title("首次使用向导")
        self.transient(master)
        self.grab_set()
        self.resizable(False, False)
        # 适当扩大初始尺寸，避免表单内容被截断（尤其是第三步的精度设置）
        self.geometry("720x540")
        self.protocol("WM_DELETE_WINDOW", self.on_cancel)

        self.system_type = tk.StringVar(value="semiconductor")
        self.workflow = tk.StringVar(value="relax_scf_dos")
        self.encut_mode = tk.StringVar(value="auto")
        self.encut_value = tk.StringVar(value="520")
        self.k_mode = tk.StringVar(value="kspacing")
        self.kspacing = tk.StringVar(value="0.22")
        self.kgrid = [tk.IntVar(value=6), tk.IntVar(value=6), tk.IntVar(value=6)]
        self.use_slurm = tk.BooleanVar(value=False)
        self.np_var = tk.StringVar(value=str(max(1, master._int_from_var(master.mpi_np, 8))))
        self.slurm_part = tk.StringVar(value=master.slurm_part.get())
        self.slurm_time = tk.StringVar(value=master.slurm_time.get())
        self.slurm_nodes = tk.StringVar(value=str(master.slurm_nodes.get()))
        self.slurm_ntasks = tk.StringVar(value=str(master.slurm_ntasks.get()))
        self.slurm_account = tk.StringVar(value=master.slurm_account.get())
        self.emit_report = tk.BooleanVar(value=bool(master.emit_report_var.get()))

        container = ttk.Frame(self, padding=12)
        container.pack(fill=tk.BOTH, expand=True)
        self.step_var = tk.StringVar(value="步骤 1/5")
        ttk.Label(container, textvariable=self.step_var, font=("", 12, "bold")).pack(anchor=tk.W, pady=(0, 8))

        self.stack = ttk.Frame(container)
        self.stack.pack(fill=tk.BOTH, expand=True)
        self.pages: list[ttk.Frame] = []
        self.slurm_widgets: list[ttk.Widget] = []
        self.pages.append(self._build_system_page())
        self.pages.append(self._build_workflow_page())
        self.pages.append(self._build_precision_page())
        self.pages.append(self._build_resource_page())
        self.pages.append(self._build_output_page())

        nav = ttk.Frame(container)
        nav.pack(fill=tk.X, pady=(12, 0))
        self.btn_prev = ttk.Button(nav, text="上一步", command=self.on_prev)
        self.btn_prev.pack(side=tk.LEFT)
        self.btn_cancel = ttk.Button(nav, text="取消", command=self.on_cancel)
        self.btn_cancel.pack(side=tk.RIGHT)
        self.btn_finish = ttk.Button(nav, text="完成", command=self.on_finish)
        self.btn_finish.pack(side=tk.RIGHT, padx=6)
        self.btn_next = ttk.Button(nav, text="下一步", command=self.on_next)
        self.btn_next.pack(side=tk.RIGHT)

        self.current_index = 0
        self._update_page()
        self._center_on_parent(master)

    def _center_on_parent(self, master):
        try:
            self.update_idletasks()
            w = self.winfo_width()
            h = self.winfo_height()
            x = master.winfo_rootx() + (master.winfo_width() - w) // 2
            y = master.winfo_rooty() + (master.winfo_height() - h) // 2
            self.geometry(f"{w}x{h}+{x}+{y}")
        except Exception:
            pass

    def _build_system_page(self) -> ttk.Frame:
        frame = ttk.Frame(self.stack)
        ttk.Label(frame, text="选择体系类型：").pack(anchor=tk.W)
        options = [
            ("metal", "金属（ISMEAR=1, SIGMA≈0.2）"),
            ("semiconductor", "半导体（ISMEAR=0, SIGMA≈0.05）"),
            ("insulator", "绝缘体（ISMEAR=0, SIGMA≈0.05）"),
        ]
        for value, text in options:
            ttk.Radiobutton(frame, text=text, value=value, variable=self.system_type).pack(anchor=tk.W, pady=2)
        ttk.Label(frame, text="该设置用于推荐展宽参数。", foreground="#555555").pack(anchor=tk.W, pady=(6, 0))
        return frame

    def _build_workflow_page(self) -> ttk.Frame:
        frame = ttk.Frame(self.stack)
        ttk.Label(frame, text="选择计算流程：").pack(anchor=tk.W)
        for value, text in [
            ("relax_scf_dos", "Relax → SCF → DOS"),
            ("relax_scf_bands", "Relax → SCF → Bands"),
            ("scf_dos", "SCF → DOS"),
        ]:
            ttk.Radiobutton(frame, text=text, value=value, variable=self.workflow).pack(anchor=tk.W, pady=2)
        ttk.Label(frame, text="流程将决定生成的脚本与建议。", foreground="#555555").pack(anchor=tk.W, pady=(6, 0))
        ttk.Label(
            frame,
            text=(
                "Relax → SCF → DOS（默认）\n"
                "用于“有应力/对齐方式不确定”的结构：先几何优化，再精细自洽，最后基于该电荷做 DOS。\n"
                "可靠稳健，适合多数 2D 扭转/滑移扫描。\n\n"
                "Relax → SCF → Bands\n"
                "目标是能带路径：先 Relax，再 SCF 得到准确电荷，最后用 ICHARG=11 的 band run 走高对称线。\n"
                "适合在 DOS/带隙初筛后，对少量代表构型出图。\n\n"
                "SCF → DOS（无 Relax）\n"
                "当几何已可信或做快速预筛时可直接 SCF，随后投 DOS。速度快，但若未 Relax 可能影响能量和带隙。"
            ),
            wraplength=660,
            justify=tk.LEFT,
            foreground="#444444",
        ).pack(anchor=tk.W, pady=(8, 0))
        return frame

    def _build_precision_page(self) -> ttk.Frame:
        frame = ttk.Frame(self.stack)
        ttk.Label(frame, text="设置精度与 K 网格：").pack(anchor=tk.W)
        encut_box = ttk.LabelFrame(frame, text="ENCUT")
        encut_box.pack(fill=tk.X, pady=4)
        ttk.Radiobutton(encut_box, text="自动（1.3×ENMAX_max）", value="auto", variable=self.encut_mode, command=self._update_state).pack(anchor=tk.W)
        ttk.Radiobutton(encut_box, text="手动指定", value="manual", variable=self.encut_mode, command=self._update_state).pack(anchor=tk.W)
        row = ttk.Frame(encut_box)
        row.pack(anchor=tk.W, pady=4)
        ttk.Label(row, text="ENCUT (eV):").pack(side=tk.LEFT)
        self.encut_entry = ttk.Entry(row, textvariable=self.encut_value, width=8)
        self.encut_entry.pack(side=tk.LEFT, padx=4)
        ttk.Label(
            encut_box,
            text=(
                "自动（推荐）：ENCUT ≈ 1.3 × 元素最大 ENMAX，适合混合元素或批量扫描。\n"
                "手动：仅在做收敛测试或沿用既有基准时使用；常见半导体 450–550 eV，含 O/N/F 时 520–600 eV。"
            ),
            wraplength=640,
            justify=tk.LEFT,
            foreground="#444444",
        ).pack(anchor=tk.W, pady=(4, 0))

        k_box = ttk.LabelFrame(frame, text="K 网格")
        k_box.pack(fill=tk.X, pady=4)
        ttk.Radiobutton(k_box, text="使用 KSPACING", value="kspacing", variable=self.k_mode, command=self._update_state).pack(anchor=tk.W)
        ks_row = ttk.Frame(k_box)
        ks_row.pack(anchor=tk.W, pady=4)
        ttk.Label(ks_row, text="KSPACING:").pack(side=tk.LEFT)
        self.kspacing_entry = ttk.Entry(ks_row, textvariable=self.kspacing, width=8)
        self.kspacing_entry.pack(side=tk.LEFT, padx=4)
        ttk.Radiobutton(k_box, text="使用 Monkhorst-Pack 网格", value="kpoints", variable=self.k_mode, command=self._update_state).pack(anchor=tk.W, pady=(6, 0))
        grid_row = ttk.Frame(k_box)
        grid_row.pack(anchor=tk.W, pady=4)
        for label, var in zip(["Nx", "Ny", "Nz"], self.kgrid):
            ttk.Label(grid_row, text=label).pack(side=tk.LEFT, padx=(0, 2))
            ttk.Spinbox(grid_row, from_=1, to=24, textvariable=var, width=4).pack(side=tk.LEFT, padx=(0, 6))
        ttk.Label(
            k_box,
            text=(
                "KSPACING（推荐）：以倒空间点间距控制密度，随超胞自动缩放。\n"
                "金属/小原胞 0.18–0.22，半导体 0.22–0.30，大莫尔超胞可改为 Γ-only 并放宽到 ~0.35。\n"
                "Monkhorst-Pack：当你明确需要 Nx×Ny×Nz 网格时使用；2D 薄膜通常 Nz=1，金属可考虑取消 Γ 中心。"
            ),
            wraplength=640,
            justify=tk.LEFT,
            foreground="#444444",
        ).pack(anchor=tk.W, pady=(4, 0))
        if not HAS_SEEKPATH:
            ttk.Label(k_box, text="未检测到 seekpath，建议优先使用 KSPACING。", foreground="#aa5500").pack(anchor=tk.W, pady=(4, 0))
        return frame

    def _build_resource_page(self) -> ttk.Frame:
        frame = ttk.Frame(self.stack)
        ttk.Label(frame, text="配置资源：").pack(anchor=tk.W)
        row = ttk.Frame(frame)
        row.pack(anchor=tk.W, pady=4)
        ttk.Label(row, text="本地核数 (-np):").pack(side=tk.LEFT)
        self.np_entry = ttk.Entry(row, textvariable=self.np_var, width=6)
        self.np_entry.pack(side=tk.LEFT, padx=4)
        ttk.Checkbutton(frame, text="使用 SLURM 集群", variable=self.use_slurm, command=self._update_state).pack(anchor=tk.W, pady=(6, 4))
        slurm_box = ttk.LabelFrame(frame, text="SLURM")
        slurm_box.pack(fill=tk.X, pady=4)
        for label, var in [
            ("分区", self.slurm_part),
            ("时长", self.slurm_time),
            ("节点", self.slurm_nodes),
            ("ntasks", self.slurm_ntasks),
            ("账号", self.slurm_account),
        ]:
            r = ttk.Frame(slurm_box)
            r.pack(anchor=tk.W, pady=2)
            ttk.Label(r, text=label + "：").pack(side=tk.LEFT)
            entry = ttk.Entry(r, textvariable=var, width=12)
            entry.pack(side=tk.LEFT, padx=4)
            self.slurm_widgets.append(entry)
        if not shutil.which("squeue"):
            ttk.Label(slurm_box, text="未检测到 SLURM 命令，提交功能可能不可用。", foreground="#aa5500").pack(anchor=tk.W, pady=(4, 0))
        return frame

    def _build_output_page(self) -> ttk.Frame:
        frame = ttk.Frame(self.stack)
        ttk.Label(frame, text="输出选项：").pack(anchor=tk.W)
        ttk.Label(frame, text="图像风格固定为 AFM 期刊预设。", foreground="#555555").pack(anchor=tk.W, pady=(0, 2))
        ttk.Checkbutton(frame, text="生成复现报告", variable=self.emit_report).pack(anchor=tk.W, pady=(6, 2))
        if not HAS_PYMATGEN:
            ttk.Label(frame, text="未检测到 pymatgen，高级结构功能将关闭。", foreground="#aa5500").pack(anchor=tk.W, pady=(6, 0))
        return frame

    def _update_state(self):
        self.encut_entry.configure(state=tk.NORMAL if self.encut_mode.get() == "manual" else tk.DISABLED)
        self.kspacing_entry.configure(state=tk.NORMAL if self.k_mode.get() == "kspacing" else tk.DISABLED)
        for widget in self.slurm_widgets:
            try:
                widget.configure(state=tk.NORMAL if self.use_slurm.get() else tk.DISABLED)
            except Exception:
                pass

    def _update_page(self):
        for page in self.pages:
            page.pack_forget()
        page = self.pages[self.current_index]
        page.pack(fill=tk.BOTH, expand=True)
        self.step_var.set(f"步骤 {self.current_index + 1}/5")
        self.btn_prev.configure(state=tk.NORMAL if self.current_index > 0 else tk.DISABLED)
        if self.current_index >= len(self.pages) - 1:
            self.btn_next.configure(state=tk.DISABLED)
            self.btn_finish.configure(state=tk.NORMAL)
        else:
            self.btn_next.configure(state=tk.NORMAL)
            self.btn_finish.configure(state=tk.DISABLED)
        self._update_state()

    def _validate_page(self) -> bool:
        if self.current_index == 2 and self.k_mode.get() == "kspacing":
            try:
                float(self.kspacing.get())
            except Exception:
                messagebox.showerror(APP_NAME, "KSPACING 需为数字")
                return False
        if self.current_index == 3:
            try:
                int(self.np_var.get())
            except Exception:
                messagebox.showerror(APP_NAME, "-np 需为正整数")
                return False
        return True

    def on_next(self):
        if not self._validate_page():
            return
        if self.current_index < len(self.pages) - 1:
            self.current_index += 1
            self._update_page()

    def on_prev(self):
        if self.current_index > 0:
            self.current_index -= 1
            self._update_page()

    def on_cancel(self):
        self.result = None
        self.destroy()

    def on_finish(self):
        if not self._validate_page():
            return
        try:
            np_total = int(self.np_var.get())
            if np_total <= 0:
                raise ValueError
        except Exception:
            messagebox.showerror(APP_NAME, "-np 需为正整数")
            return
        encut_val = None
        if self.encut_mode.get() == "manual":
            try:
                encut_val = int(self.encut_value.get())
            except Exception:
                messagebox.showerror(APP_NAME, "请输入合法的 ENCUT 数值")
                return
        kspacing_val = None
        kgrid_val = None
        if self.k_mode.get() == "kspacing":
            try:
                kspacing_val = float(self.kspacing.get())
            except Exception:
                messagebox.showerror(APP_NAME, "KSPACING 需为数字")
                return
        else:
            kgrid_val = tuple(int(var.get()) for var in self.kgrid)
        slurm_cfg: Dict[str, Any] = {
            "partition": self.slurm_part.get(),
            "time": self.slurm_time.get(),
            "nodes": self._safe_int(self.slurm_nodes.get(), 1),
            "ntasks": self._safe_int(self.slurm_ntasks.get(), np_total),
            "account": self.slurm_account.get(),
        }
        profile = WizardProfile(
            system_type=self.system_type.get(),
            workflow=self.workflow.get(),
            encut_strategy=self.encut_mode.get(),
            encut_value=encut_val,
            k_mode=self.k_mode.get(),
            kspacing=kspacing_val,
            kgrid=kgrid_val,
            use_slurm=bool(self.use_slurm.get()),
            np=np_total,
            slurm=slurm_cfg,
            figure_style="AFM",
            emit_report=bool(self.emit_report.get()),
        )
        self.result = profile
        self.destroy()

    def _safe_int(self, value: str, default: int) -> int:
        try:
            num = int(value)
            return num if num > 0 else default
        except Exception:
            return default


if __name__ == "__main__":
    app = VaspGUI()
    app.mainloop()
