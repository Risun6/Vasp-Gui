#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
VASP Linux 一体化GUI（Tkinter 版 | 单文件可运行）
=================================================
目标：把 Linux 下常用 VASP 操作整合到简洁 GUI：项目管理、INCAR/POSCAR/KPOINTS 编辑、
POTCAR 拼接（本地已有赝势）、K 点生成、作业脚本生成与提交（本地 / SLURM）、
以及 OSZICAR 能量-步数监视与简单可视化。

依赖（尽量轻）：
- Python 3.8+
- tkinter（随 Python 自带）
- matplotlib（绘图）

可选依赖（提升体验，但不是必须）：
- ttkbootstrap（更美观的主题）
- pymatgen / ase（将来可扩展结构与后处理）

使用：
- python vasp_gui.py

说明：
- 本工具不包含、也不会分发任何 VASP 程序或赝势文件。请确保你拥有 VASP 许可，
  并在"POTCAR 面板"正确设置本地赝势库路径。
- 监视功能主要解析 OSZICAR（F= 或 E0= 行），用于快速查看收敛趋势。
- SLURM 模板可在 GUI 中一键生成，你可以直接提交或先手动修改。

作者：ChatGPT（GPT-5 Thinking）
许可：MIT
"""
from __future__ import annotations
import os
import sys
import re
import time
import json
import shutil
import threading
import subprocess
from pathlib import Path

try:
    import tkinter as tk
    from tkinter import ttk, filedialog, messagebox
except Exception as e:
    print("[FATAL] Tkinter 未安装或不可用：", e)
    sys.exit(1)

# matplotlib 放在 TkAgg 嵌入
import matplotlib
matplotlib.use("TkAgg")
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib.figure import Figure

APP_NAME = "VASP Linux 一体化GUI"
APP_VER = "0.1.0-MVP"

# 配置文件路径（保存用户设置）
CONFIG_DIR = Path.home() / ".config" / "vasp_gui"
CONFIG_PATH = CONFIG_DIR / "config.json"

# ----------------------------- 工具函数区 ----------------------------------

def which(cmd: str) -> str | None:
    """返回可执行文件绝对路径，找不到则 None。"""
    return shutil.which(cmd)

def read_text(p: Path) -> str:
    try:
        return p.read_text(encoding="utf-8")
    except Exception:
        try:
            return p.read_text(encoding="latin-1")
        except Exception:
            return ""

def write_text(p: Path, s: str) -> None:
    p.write_text(s, encoding="utf-8")

def format_bytes(num: int | float | None) -> str:
    """将字节数转为易读字符串。"""
    if num is None:
        return "-"
    try:
        n = float(num)
    except Exception:
        return str(num)
    if n < 0:
        n = 0.0
    units = ["B", "KB", "MB", "GB", "TB", "PB"]
    for unit in units:
        if n < 1024.0 or unit == units[-1]:
            if unit == "B":
                return f"{int(n)} {unit}"
            return f"{n:.1f} {unit}"
        n /= 1024.0
    return f"{n:.1f} PB"

POSCAR_ELEM_LINE_RX = re.compile(r"^\s*([A-Za-z][a-z]?(?:\s+[A-Za-z][a-z]?)*?)\s*$")
COUNTS_RX = re.compile(r"^\s*(\d+(?:\s+\d+)*)\s*$")
ENERGY_RX = re.compile(r"F=\s*([-+]?\d+\.\d+)|E0=\s*([-+]?\d+\.\d+)")


def parse_poscar(poscar_text: str):
    """粗略解析 POSCAR 的元素与计数。尽量兼容两种第6/7行写法。
    返回 (elements: list[str], counts: list[int])，可能为空。"""
    lines = [ln.rstrip("\n") for ln in poscar_text.splitlines() if ln.strip() != ""]
    if len(lines) < 8:
        return [], []
    # 寻找元素与计数两行：兼容存在 Selective dynamics 行
    # 常见：
    # 1: comment
    # 2: scale
    # 3-5: lattice
    # 6: elements OR counts
    # 7: counts (if 6 is elements)
    # 8: Selective dynamics? OR Direct/Cartesian
    elem_line = None
    cnt_line = None

    # 尝试 line6 作为元素，line7 作为计数
    l6 = lines[5]
    l7 = lines[6]
    if POSCAR_ELEM_LINE_RX.match(l6) and COUNTS_RX.match(l7):
        elem_line = l6
        cnt_line = l7
    else:
        # 也可能 line6 就是计数（没有元素符号行）
        if COUNTS_RX.match(l6):
            cnt_line = l6
            elem_line = None

    elements = []
    if elem_line:
        elements = elem_line.split()
    # 计数
    counts = []
    if cnt_line:
        counts = [int(x) for x in cnt_line.split()]

    return elements, counts


def unique_elements_from_poscar(poscar_text: str):
    elems, _ = parse_poscar(poscar_text)
    return elems


def find_potcar_candidates(elem: str, pot_dir: Path) -> list[Path]:
    """在 pot_dir 下递归查找包含给定元素名称的 POTCAR 文件，返回候选列表。
    常见目录层级（示例）：
      PAW_PBE/Si/POTCAR  或  potcars/PBE/Si/POTCAR  或  potpaw_PBE.54/Si/POTCAR
    策略：深度<=3 的广度优先查找，目录名包含元素精确匹配。"""
    elem = elem.strip()
    max_depth = 3
    queue = [(pot_dir, 0)]
    candidates = []
    while queue:
        d, depth = queue.pop(0)
        if depth > max_depth:
            continue
        try:
            for entry in d.iterdir():
                if entry.is_dir():
                    name = entry.name
                    if name == elem:
                        pot = entry / "POTCAR"
                        if pot.exists():
                            candidates.append(pot)
                    queue.append((entry, depth + 1))
        except PermissionError:
            pass
        except FileNotFoundError:
            pass
    seen = []
    unique: list[Path] = []
    for cand in candidates:
        key = str(cand)
        if key not in seen:
            seen.append(key)
            unique.append(cand)
    return unique


def build_potcar(pot_files: list[Path], out_path: Path) -> tuple[bool, str]:
    """将 pot_files 中的 POTCAR 依序拼接到 out_path。返回 (ok, msg)。"""
    if not pot_files:
        return False, "未提供任何 POTCAR 文件。"
    try:
        with open(out_path, "wb") as fout:
            for p in pot_files:
                pp = Path(p)
                if not pp.exists():
                    return False, f"未找到 POTCAR：{pp}"
                fout.write(pp.read_bytes())
        return True, f"POTCAR 已生成：{out_path}"
    except Exception as ex:
        return False, f"生成 POTCAR 失败：{ex}"


def gen_kpoints_monkhorst(nx: int, ny: int, nz: int, gamma_center: bool) -> str:
    lines = [
        "Auto KPOINTS",
        "0",
        "Gamma" if gamma_center else "Monkhorst-Pack",
        f"{nx} {ny} {nz}",
        "0 0 0",
    ]
    return "\n".join(lines) + "\n"

# ----------------------------- GUI 组件 ------------------------------------

class SystemStatsMonitor(threading.Thread):
    """后台线程：监视 CPU/进程以及关键文件增长情况。"""

    def __init__(self, workdir: Path, watch_files: list[str] | None, on_update=None):
        super().__init__(daemon=True)
        self.workdir = Path(workdir).expanduser()
        try:
            self.workdir_resolved = self.workdir.resolve()
        except Exception:
            self.workdir_resolved = self.workdir
        self.watch_files = watch_files or []
        self.on_update = on_update  # callback(dict)
        self._stop = threading.Event()
        self._prev_cpu = None  # tuple(total, idle)
        self._prev_sizes: dict[Path, int] = {}

    def stop(self):
        self._stop.set()

        if self.is_alive():
            try:
                self.join(timeout=2.0)
            except RuntimeError:
                pass

    def run(self):
        while not self._stop.is_set():
            stats = self._collect_stats()
            if self.on_update:
                try:
                    self.on_update(stats)
                except Exception:
                    pass
            for _ in range(6):
                if self._stop.is_set():
                    break
                time.sleep(0.5)

    def _collect_stats(self) -> dict:
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
        cpu_usage = self._cpu_usage_percent()
        loadavg = self._loadavg()
        files = self._file_stats()
        procs = self._process_stats()
        run_state, run_pids, suggestions = self._run_status(procs, files)
        return {
            "timestamp": timestamp,
            "cpu_usage": cpu_usage,
            "loadavg": loadavg,
            "files": files,
            "processes": procs,
            "run_state": run_state,
            "run_pids": run_pids,
            "suggestions": suggestions,
        }

    def _cpu_usage_percent(self) -> float | None:
        proc_stat = Path("/proc/stat")
        if not proc_stat.exists():
            return None
        try:
            line = proc_stat.read_text().splitlines()[0]
        except Exception:
            return None
        parts = line.split()
        if len(parts) < 5 or parts[0] != "cpu":
            return None
        try:
            values = [float(x) for x in parts[1:]]
        except Exception:
            return None
        idle = values[3]
        total = sum(values)
        if self._prev_cpu is None:
            self._prev_cpu = (total, idle)
            return None
        prev_total, prev_idle = self._prev_cpu
        total_delta = total - prev_total
        idle_delta = idle - prev_idle
        self._prev_cpu = (total, idle)
        if total_delta <= 0:
            return None
        usage = max(0.0, min(100.0, (1.0 - idle_delta / total_delta) * 100.0))
        return usage

    def _loadavg(self) -> tuple[float, float, float] | None:
        if hasattr(os, "getloadavg"):
            try:
                return os.getloadavg()
            except OSError:
                return None
        return None

    def _file_stats(self) -> list[dict]:
        stats = []
        for name in self.watch_files:
            if not name:
                continue
            p = Path(name)
            if not p.is_absolute():
                p = self.workdir / name
            p = p.resolve()
            info = {
                "name": str(p),
                "exists": False,
                "size": 0,
                "delta": 0,
            }
            try:
                if p.exists():
                    size = p.stat().st_size
                    prev = self._prev_sizes.get(p, size)
                    info.update({
                        "exists": True,
                        "size": size,
                        "delta": size - prev,
                    })
                    self._prev_sizes[p] = size
            except Exception:
                pass
            stats.append(info)
        return stats

    def _process_stats(self) -> list[dict]:

        cmd = ["ps", "-eo", "pid,%cpu,%mem,cmd", "--sort=-%cpu"]
        try:
            out = subprocess.check_output(cmd, text=True, stderr=subprocess.DEVNULL)
        except Exception:
            return []
        lines = out.strip().splitlines()
        procs = []
        for line in lines[1:6]:  # 跳过表头，仅取前5项
            parts = line.split(None, 3)

            if len(parts) < 3:
                continue
            pid = parts[0]
            cpu = parts[1]
            mem = parts[2]
            cmd_full = parts[3] if len(parts) >= 4 else ""
            cwd = self._proc_cwd(pid)
            in_project = False
            try:
                if cwd:

                    resolved = Path(cwd).resolve()
                    in_project = resolved == self.workdir_resolved
                    if not in_project:
                        try:
                            resolved.relative_to(self.workdir_resolved)
                            in_project = True
                        except Exception:
                            in_project = False
            except Exception:
                in_project = False
            cmd_lower = cmd_full.lower()
            is_vasp = "vasp" in cmd_lower or ("mpi" in cmd_lower and "vasp" in cmd_lower)
            procs.append({
                "pid": pid,
                "cmd": cmd_full.strip(),
                "cpu": cpu,
                "mem": mem,
                "is_vasp": is_vasp,
                "cwd": cwd,
                "in_project": in_project,
            })
        return procs

    def _proc_cwd(self, pid: str) -> str | None:
        proc_path = Path("/proc") / str(pid) / "cwd"
        try:
            return os.readlink(proc_path)
        except Exception:
            return None

    def _run_status(self, procs: list[dict], files: list[dict]) -> tuple[str, list[str], list[str]]:
        run_pids: list[str] = []
        suggestions: list[str] = []
        for proc in procs:
            if proc.get("is_vasp") and proc.get("in_project"):
                run_pids.append(proc.get("pid", ""))
        run_state = "running" if run_pids else "idle"
        if run_pids:
            suggestions.append(
                f"检测到 {len(run_pids)} 个 VASP 相关进程在 {self.workdir} 运行。"
            )
        else:
            suggestions.append("未检测到项目内的 VASP 进程，可检查作业或尝试重新启动。")

        for item in files:
            short = Path(item.get("name", "")).name
            if not item.get("exists"):
                suggestions.append(f"未发现 {short}，请确认计算是否已开始输出。")
            else:
                delta = item.get("delta")
                if isinstance(delta, (int, float)) and delta <= 0 and run_pids:
                    suggestions.append(f"{short} 暂未增长，可稍后再次检查。")
        if len(suggestions) > 5:
            suggestions = suggestions[:5]
        return run_state, run_pids, suggestions

    @classmethod
    def snapshot(cls, workdir: Path, watch_files: list[str] | None) -> dict:
        monitor = cls(workdir, watch_files, on_update=None)
        return monitor._collect_stats()


class EnergyMonitor(threading.Thread):
    """后台线程：周期性解析 OSZICAR，提取 F/E0 能量，供主线程绘图。"""
    def __init__(self, workdir: Path, on_update):
        super().__init__(daemon=True)
        self.workdir = workdir
        self.on_update = on_update  # callback(steps:list[int], energies:list[float])
        self._stop = threading.Event()
        self.steps = []
        self.energies = []
        self._last_size = 0
        self._last_pos = 0

    def stop(self):
        self._stop.set()
        if self.is_alive():
            try:
                self.join(timeout=2.0)
            except RuntimeError:
                pass

    def run(self):
        osz = self.workdir / "OSZICAR"
        while not self._stop.is_set():
            try:
                if osz.exists():
                    size = osz.stat().st_size
                    reset = False
                    if size < self._last_size:
                        reset = True
                        self._last_pos = 0
                        self._last_size = 0
                        self.steps = []
                        self.energies = []
                    if reset or size > self._last_size:
                        self._parse(osz, reset)
                        self._last_size = size
                        if self.on_update:
                            self.on_update(self.steps, self.energies)
            except Exception:
                pass
            time.sleep(1.0)

    def _parse(self, path: Path, reset: bool):
        try:
            with path.open("r", encoding="utf-8", errors="ignore") as f:
                if not reset and self._last_pos:
                    f.seek(self._last_pos)
                else:
                    self.steps = []
                    self.energies = []
                for line in f:
                    m = ENERGY_RX.search(line)
                    if m:
                        val = m.group(1) or m.group(2)
                        try:
                            e = float(val)
                            self.steps.append(len(self.steps) + 1)
                            self.energies.append(e)
                        except Exception:
                            pass
                self._last_pos = f.tell()
        except Exception:
            return


class VaspGUI(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title(f"{APP_NAME} v{APP_VER}")
        self.geometry("1200x800")
        try:
            import ttkbootstrap as tb  # 可选美化
            tb.Style("cosmo")
        except Exception:
            pass

        self.project_dir = Path.cwd()
        self.proc = None  # subprocess.Popen or None
        self.monitor = None  # EnergyMonitor
        self.sys_monitor = None  # SystemStatsMonitor
        self.run_status_var = tk.StringVar(value="⚪ 未检测")
        self.run_suggestion_widgets: list[tk.Text] = []
        self.overview_items = [
            ("__project__", "项目目录"),
            ("INCAR", "INCAR"),
            ("POSCAR", "POSCAR"),
            ("KPOINTS", "KPOINTS"),
            ("POTCAR", "POTCAR"),
            ("CONTCAR", "CONTCAR"),
            ("vasp.out", "vasp.out"),
            ("OSZICAR", "OSZICAR"),
            ("OUTCAR", "OUTCAR"),
        ]
        self.overview_label_map = {k: label for k, label in self.overview_items}
        self.overview_key_map = {k.lower(): k for k, _ in self.overview_items}

        self._build_ui()
        self.set_project(self.project_dir)

        # 加载历史配置（若存在）
        try:
            self.load_config()
        except Exception:
            pass

    # ------------------------- UI 构建 ----------------------------------
    def _build_ui(self):
        # 顶部工具栏
        toolbar = ttk.Frame(self)
        toolbar.pack(side=tk.TOP, fill=tk.X)

        ttk.Label(toolbar, text="项目目录:").pack(side=tk.LEFT, padx=6)
        self.project_var = tk.StringVar(value=str(self.project_dir))
        self.project_entry = ttk.Entry(toolbar, textvariable=self.project_var, width=80)
        self.project_entry.pack(side=tk.LEFT, padx=4)
        ttk.Button(toolbar, text="选择…", command=self.choose_project).pack(side=tk.LEFT)
        ttk.Button(toolbar, text="新建项目", command=self.create_project).pack(side=tk.LEFT, padx=4)
        ttk.Button(toolbar, text="快速体检", command=self.quick_check).pack(side=tk.LEFT, padx=4)

        # Notebook
        self.nb = ttk.Notebook(self)
        self.nb.pack(fill=tk.BOTH, expand=True)

        self.page_inputs = self._build_inputs_page(self.nb)
        self.page_potcar = self._build_potcar_page(self.nb)
        self.page_kpoints = self._build_kpoints_page(self.nb)
        self.page_workflow = self._build_workflow_page(self.nb)
        self.page_run = self._build_run_page(self.nb)
        self.page_monitor = self._build_monitor_page(self.nb)
        self.page_post = self._build_post_page(self.nb)

        self.nb.add(self.page_inputs, text="输入文件")
        self.nb.add(self.page_potcar, text="POTCAR 赝势")
        self.nb.add(self.page_kpoints, text="K 点生成")
        self.nb.add(self.page_workflow, text="流程助手")
        self.nb.add(self.page_run, text="运行 / 提交")
        self.nb.add(self.page_monitor, text="监视")
        self.nb.add(self.page_post, text="后处理 (简)")

        self.protocol("WM_DELETE_WINDOW", self.on_close)

    # ------------------------- 页面：输入文件 -----------------------------
    def _build_inputs_page(self, parent):
        frame = ttk.Frame(parent)

        # 左边：INCAR 模板
        left = ttk.Frame(frame)
        left.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=8, pady=8)

        ttk.Label(left, text="INCAR 模板与编辑").pack(anchor=tk.W)
        temp_bar = ttk.Frame(left)
        temp_bar.pack(fill=tk.X, pady=4)
        self.incar_template = tk.StringVar(value="relax")
        for key, txt in [
            ("relax", "几何优化"),
            ("static", "静态自洽"),
            ("dos", "态密度"),
            ("bands", "能带预设"),
        ]:
            ttk.Radiobutton(temp_bar, text=txt, value=key, variable=self.incar_template, command=self.load_incar_template).pack(side=tk.LEFT)
        ttk.Button(temp_bar, text="加载模板到编辑器", command=self.load_incar_template).pack(side=tk.RIGHT)

        self.incar_text = tk.Text(left, height=20)
        self.incar_text.pack(fill=tk.BOTH, expand=True)
        btns = ttk.Frame(left)
        btns.pack(fill=tk.X, pady=4)
        ttk.Button(btns, text="打开现有 INCAR", command=lambda: self.open_into_editor("INCAR", self.incar_text)).pack(side=tk.LEFT)
        ttk.Button(btns, text="保存到项目", command=lambda: self.save_from_editor("INCAR", self.incar_text)).pack(side=tk.LEFT, padx=6)

        # 右边：POSCAR & KPOINTS 编辑
        right = ttk.Frame(frame)
        right.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=8, pady=8)

        ttk.Label(right, text="POSCAR 编辑").pack(anchor=tk.W)
        self.poscar_text = tk.Text(right, height=10)
        self.poscar_text.pack(fill=tk.BOTH, expand=True)
        row = ttk.Frame(right)
        row.pack(fill=tk.X, pady=4)
        ttk.Button(row, text="打开 POSCAR", command=lambda: self.open_into_editor("POSCAR", self.poscar_text)).pack(side=tk.LEFT)
        ttk.Button(row, text="保存 POSCAR", command=lambda: self.save_from_editor("POSCAR", self.poscar_text)).pack(side=tk.LEFT, padx=6)
        ttk.Button(row, text="从 POSCAR 解析元素", command=self.show_poscar_elements).pack(side=tk.LEFT, padx=6)

        ttk.Separator(right, orient=tk.HORIZONTAL).pack(fill=tk.X, pady=6)

        ttk.Label(right, text="KPOINTS 编辑（可在"K 点生成"页自动生成）").pack(anchor=tk.W)
        self.kpoints_text = tk.Text(right, height=10)
        self.kpoints_text.pack(fill=tk.BOTH, expand=True)
        row2 = ttk.Frame(right)
        row2.pack(fill=tk.X, pady=4)
        ttk.Button(row2, text="打开 KPOINTS", command=lambda: self.open_into_editor("KPOINTS", self.kpoints_text)).pack(side=tk.LEFT)
        ttk.Button(row2, text="保存 KPOINTS", command=lambda: self.save_from_editor("KPOINTS", self.kpoints_text)).pack(side=tk.LEFT, padx=6)

        # 默认加载模板
        self.load_incar_template()
        return frame

    def load_incar_template(self):
        tpl = self.incar_template.get()
        presets = {
            "relax": (
                """# ==== 几何优化（PBE）====\nSYSTEM = relax\nENCUT = 520\nPREC  = Accurate\nEDIFF = 1e-6\nEDIFFG = -0.02\nISMEAR = 0\nSIGMA  = 0.05\nIBRION = 2\nISIF   = 3\nNSW    = 100\nISPIN  = 1\nLREAL  = Auto\n# 可选：KSPACING = 0.22\n"""
            ),
            "static": (
                """# ==== 静态自洽（SCF）====\nSYSTEM = scf\nENCUT = 520\nPREC  = Accurate\nEDIFF = 1e-6\nISMEAR = 0\nSIGMA  = 0.05\nIBRION = -1\nNSW    = 0\nLREAL  = Auto\nLWAVE  = .FALSE.\nLCHARG = .TRUE.\n# 可选：KSPACING = 0.22\n"""
            ),
            "dos": (
                """# ==== DOS 计算（在已收敛电荷上）====\nSYSTEM = dos\nENCUT = 520\nPREC  = Accurate\nEDIFF = 1e-6\nISMEAR = 0\nSIGMA  = 0.05\nIBRION = -1\nNSW    = 0\nLORBIT = 11\nNEDOS  = 2000\nLCHARG = .TRUE.\nLWAVE  = .FALSE.\n# 可选：KSPACING = 0.18\n"""
            ),
            "bands": (
                """# ==== 能带预设（非自洽）====\nSYSTEM = bands\nENCUT = 520\nPREC  = Accurate\nEDIFF = 1e-6\nISMEAR = 0\nSIGMA  = 0.05\nIBRION = -1\nNSW    = 0\nICHARG = 11\nLORBIT = 11\nLCHARG = .FALSE.\nLWAVE  = .TRUE.\n# KPOINTS 请使用路径方式或外部生成器\n"""
            ),
        }
        self.incar_text.delete("1.0", tk.END)
        self.incar_text.insert("1.0", presets.get(tpl, presets["relax"]))

    def open_into_editor(self, name: str, editor: tk.Text):
        p = filedialog.askopenfilename(initialdir=self.project_dir, title=f"打开 {name}", filetypes=[(name, name), ("全部", "*")])
        if not p:
            return
        try:
            s = read_text(Path(p))
            editor.delete("1.0", tk.END)
            editor.insert("1.0", s)
        except Exception as e:
            messagebox.showerror(APP_NAME, f"读取失败：{e}")

    def save_from_editor(self, name: str, editor: tk.Text):
        proj = self.current_project_path()
        proj.mkdir(parents=True, exist_ok=True)
        p = proj / name
        try:
            write_text(p, editor.get("1.0", tk.END))
            messagebox.showinfo(APP_NAME, f"已保存 {name} -> {p}")
            self.refresh_project_overview()
        except Exception as e:
            messagebox.showerror(APP_NAME, f"保存失败：{e}")

    def show_poscar_elements(self):
        s = self.poscar_text.get("1.0", tk.END)
        elems = unique_elements_from_poscar(s)
        if elems:
            messagebox.showinfo(APP_NAME, f"POSCAR 元素：{', '.join(elems)}")
        else:
            messagebox.showwarning(APP_NAME, "未解析到元素，请检查第6/7行。")

    # ------------------------- 页面：POTCAR --------------------------------
    def _build_potcar_page(self, parent):
        frame = ttk.Frame(parent)

        row1 = ttk.Frame(frame)
        row1.pack(fill=tk.X, padx=8, pady=8)
        ttk.Label(row1, text="赝势库根目录：").pack(side=tk.LEFT)
        self.pot_dir_var = tk.StringVar(value=str(Path.home() / "potcars"))
        ttk.Entry(row1, textvariable=self.pot_dir_var, width=80).pack(side=tk.LEFT, padx=6)
        ttk.Button(row1, text="选择…", command=self.choose_pot_dir).pack(side=tk.LEFT)
        ttk.Button(row1, text="探测赝势库", command=self.detect_pot_roots).pack(side=tk.LEFT, padx=6)

        row2 = ttk.Frame(frame)
        row2.pack(fill=tk.X, padx=8, pady=4)
        ttk.Label(row2, text="从 POSCAR 自动解析元素并生成 POTCAR：").pack(side=tk.LEFT)
        ttk.Button(row2, text="生成 POTCAR", command=self.do_build_potcar).pack(side=tk.LEFT, padx=8)

        self.pot_msg = tk.Text(frame, height=18)
        self.pot_msg.pack(fill=tk.BOTH, expand=True, padx=8, pady=8)

        return frame

    def choose_pot_dir(self):
        d = filedialog.askdirectory(initialdir=self.pot_dir_var.get(), title="选择赝势库根目录")
        if d:
            self.pot_dir_var.set(d)

    def do_build_potcar(self):
        proj = self.current_project_path()
        pos = proj / "POSCAR"
        if not pos.exists():
            # 尝试从编辑器
            s = self.poscar_text.get("1.0", tk.END).strip()
            if s:
                write_text(pos, s)
            else:
                messagebox.showwarning(APP_NAME, "项目目录中不存在 POSCAR，且编辑器为空。")
                return
        elems, _ = parse_poscar(read_text(pos))
        if not elems:
            messagebox.showwarning(APP_NAME, "未从 POSCAR 解析到元素。")
            return
        pot_base = Path(self.pot_dir_var.get())
        selections: list[Path] = []
        for e in elems:
            cands = find_potcar_candidates(e, pot_base)
            if not cands:
                msg = f"未找到元素 {e} 的 POTCAR（在 {pot_base} 下）。"
                self.pot_msg.insert(tk.END, msg + "\n")
                messagebox.showerror(APP_NAME, msg)
                return
            if len(cands) == 1:
                selected = cands[0]
            else:
                options = [str(p) for p in cands]
                sel = self.select_from_list(f"选择 {e} 的 POTCAR", options)
                if not sel:
                    cancel_msg = f"已取消 {e} 的 POTCAR 选择，终止生成。"
                    self.pot_msg.insert(tk.END, cancel_msg + "\n")
                    messagebox.showinfo(APP_NAME, cancel_msg)
                    return
                selected = Path(sel)
            selections.append(selected)
            self.pot_msg.insert(tk.END, f"{e}: 使用 {selected}\n")
            self.pot_msg.see(tk.END)
        ok, msg = build_potcar(selections, proj / "POTCAR")
        self.pot_msg.insert(tk.END, (msg + "\n"))
        self.pot_msg.see(tk.END)
        if not ok:
            messagebox.showerror(APP_NAME, msg)
        else:
            messagebox.showinfo(APP_NAME, msg)
            self.refresh_project_overview()

    # --------- 赝势库探测与选择 ---------
    def detect_pot_roots(self):
        cands = self.scan_pot_roots(limit=30)
        if not cands:
            messagebox.showwarning(APP_NAME, "未在常见位置发现赝势库候选。你也可以手动选择根目录。")
            return
        if len(cands) == 1:
            self.pot_dir_var.set(cands[0])
            messagebox.showinfo(APP_NAME, f"已设置赝势库根目录：\n{cands[0]}")
            return
        sel = self.select_from_list("选择赝势库根目录", cands)
        if sel:
            self.pot_dir_var.set(sel)

    def select_from_list(self, title, items):
        top = tk.Toplevel(self)
        top.title(title)
        top.geometry("720x380")
        lb = tk.Listbox(top, selectmode=tk.SINGLE)
        for it in items:
            lb.insert(tk.END, it)
        lb.pack(fill=tk.BOTH, expand=True, padx=8, pady=8)
        sel = {"val": None}
        def ok():
            try:
                i = lb.curselection()
                sel["val"] = items[i[0]] if i else None
            except Exception:
                sel["val"] = None
            top.destroy()
        ttk.Button(top, text="使用选中", command=ok).pack(pady=6)
        top.transient(self); top.grab_set(); self.wait_window(top)
        return sel["val"]

    def scan_pot_roots(self, limit=20):
        bases = []
        # 当前设置与常见路径为起点
        try:
            bases.append(Path(self.pot_dir_var.get()).expanduser())
        except Exception:
            pass
        for p in [Path.home()/"potcars", Path.home()/"vasp", Path.home()/"apps", Path.home()/"Downloads", Path.home()/"下载", Path("/opt/vasp"), Path("/usr/local/share/vasp"), Path("/mnt/c/Users")]:
            if p.exists():
                bases.append(p)
        seen = set(); cands = []
        def looks_like_root(d: Path):
            try:
                cnt = 0
                for child in d.iterdir():
                    if child.is_dir() and (child/"POTCAR").exists():
                        cnt += 1
                        if cnt >= 3:
                            return True
                return False
            except Exception:
                return False
        # BFS 限深 3
        from collections import deque
        for base in list(dict.fromkeys(bases)):
            if not base.exists():
                continue
            q = deque([(base, 0)])
            while q and len(cands) < limit:
                cur, dep = q.popleft()
                try:
                    key = str(cur.resolve())
                except Exception:
                    key = str(cur)
                if key in seen:
                    continue
                seen.add(key)
                if looks_like_root(cur):
                    cands.append(key)
                if dep < 3:
                    try:
                        for ch in cur.iterdir():
                            if ch.is_dir():
                                q.append((ch, dep+1))
                    except Exception:
                        pass
        # 去重与排序（包含关键词的优先）
        def score(path):
            name = path.lower(); s = 0
            for kw in ("potpaw","paw","pbe","lda","potential","psp"):
                if kw in name:
                    s += 1
            return (-s, len(path))
        cands = sorted(list(dict.fromkeys(cands)), key=score)
        return cands[:limit]

    # ------------------------- 页面：KPOINTS -------------------------------
    def _build_kpoints_page(self, parent):
        frame = ttk.Frame(parent)
        box = ttk.LabelFrame(frame, text="Monkhorst-Pack 网格")
        box.pack(fill=tk.X, padx=8, pady=8)

        self.k_nx = tk.IntVar(value=5)
        self.k_ny = tk.IntVar(value=5)
        self.k_nz = tk.IntVar(value=5)
        self.k_gamma = tk.BooleanVar(value=True)

        row = ttk.Frame(box)
        row.pack(fill=tk.X, pady=4)
        ttk.Label(row, text="Nx").pack(side=tk.LEFT)
        ttk.Spinbox(row, from_=1, to=50, textvariable=self.k_nx, width=5).pack(side=tk.LEFT, padx=6)
        ttk.Label(row, text="Ny").pack(side=tk.LEFT)
        ttk.Spinbox(row, from_=1, to=50, textvariable=self.k_ny, width=5).pack(side=tk.LEFT, padx=6)
        ttk.Label(row, text="Nz").pack(side=tk.LEFT)
        ttk.Spinbox(row, from_=1, to=50, textvariable=self.k_nz, width=5).pack(side=tk.LEFT, padx=6)
        ttk.Checkbutton(box, text="Gamma 中心", variable=self.k_gamma).pack(anchor=tk.W, padx=8)

        btns = ttk.Frame(frame)
        btns.pack(fill=tk.X, padx=8, pady=4)
        ttk.Button(btns, text="生成到编辑器", command=self.kpoints_to_editor).pack(side=tk.LEFT)
        ttk.Button(btns, text="保存到项目(KPOINTS)", command=self.kpoints_save).pack(side=tk.LEFT, padx=8)

        tip = ttk.Label(frame, text="提示：也可在 INCAR 使用 KSPACING，省去 KPOINTS（VASP 5.4.4+）")
        tip.pack(anchor=tk.W, padx=12, pady=4)

        return frame

    # ------------------------- 页面：流程助手 ------------------------------
    def _build_workflow_page(self, parent):
        frame = ttk.Frame(parent)

        intro = ttk.Label(
            frame,
            text="按照从上到下的步骤完成一次 VASP 计算，可点击按钮快速跳转到对应面板。",
            wraplength=900,
            justify=tk.LEFT,
        )
        intro.pack(fill=tk.X, padx=12, pady=8)

        status_box = ttk.LabelFrame(frame, text="当前项目状态")
        status_box.pack(fill=tk.BOTH, expand=False, padx=12, pady=6)

        status_row = ttk.Frame(status_box)
        status_row.pack(fill=tk.X, padx=8, pady=6)
        ttk.Label(status_row, text="运行状态：").pack(side=tk.LEFT)
        ttk.Label(status_row, textvariable=self.run_status_var).pack(side=tk.LEFT, padx=4)
        ttk.Button(status_row, text="刷新状态", command=self.refresh_run_status).pack(side=tk.RIGHT)

        tree_frame = ttk.Frame(status_box)
        tree_frame.pack(fill=tk.BOTH, expand=True, padx=8, pady=(0, 6))
        columns = ("name", "status", "detail")
        self.workflow_tree = ttk.Treeview(tree_frame, columns=columns, show="headings", height=6)
        self.workflow_tree.heading("name", text="项目项")
        self.workflow_tree.heading("status", text="状态")
        self.workflow_tree.heading("detail", text="详情")
        self.workflow_tree.column("name", width=120, anchor=tk.W)
        self.workflow_tree.column("status", width=120, anchor=tk.W)
        self.workflow_tree.column("detail", anchor=tk.W, stretch=True)
        tree_scroll = ttk.Scrollbar(tree_frame, orient=tk.VERTICAL, command=self.workflow_tree.yview)
        self.workflow_tree.configure(yscrollcommand=tree_scroll.set)
        self.workflow_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        tree_scroll.pack(side=tk.RIGHT, fill=tk.Y)

        sugg = ttk.Frame(status_box)
        sugg.pack(fill=tk.BOTH, expand=False, padx=8, pady=(0, 6))
        ttk.Label(sugg, text="运行建议：").pack(anchor=tk.W)
        wf_suggest = tk.Text(sugg, height=4, wrap="word", state="disabled")
        wf_suggest.pack(fill=tk.X, expand=True)
        self._register_suggestion_widget(wf_suggest)

        steps = [
            (
                "① 准备项目目录",
                "选择/新建项目文件夹，所有输入输出文件都保存在此处。",
                [
                    ("选择项目", self.choose_project),
                    ("新建项目", self.create_project),
                    ("快速体检", self.quick_check),
                ],
                self.page_inputs,
            ),
            (
                "② 编辑输入文件",
                "填写 INCAR、POSCAR、KPOINTS 等输入，确保必要信息完整。",
                [
                    ("跳转到输入页", lambda: self.goto_tab(self.page_inputs)),
                    ("跳转到 K 点生成", lambda: self.goto_tab(self.page_kpoints)),
                ],
                self.page_inputs,
            ),
            (
                "③ 准备 POTCAR",
                "解析 POSCAR 元素并在 POTCAR 面板一键拼接所需赝势。",
                [
                    ("跳转到 POTCAR", lambda: self.goto_tab(self.page_potcar)),
                    ("解析元素", self.show_poscar_elements),
                ],
                self.page_potcar,
            ),
            (
                "④ 配置运行方式",
                "根据实际环境选择本地/WSL/SLURM 运行，并生成脚本。",
                [
                    ("跳转到运行页", lambda: self.goto_tab(self.page_run)),
                    ("生成运行脚本", self.write_job_script),
                ],
                self.page_run,
            ),
            (
                "⑤ 启动并监视",
                "启动计算后，利用监视页关注能量收敛、CPU 使用率及文件增长。",
                [
                    ("启动/提交", self.start_run),
                    ("跳转到监视", lambda: self.goto_tab(self.page_monitor)),
                    ("开始监视", self.start_monitor),
                ],
                self.page_monitor,
            ),
            (
                "⑥ 后处理与结果",
                "提取最终能量或绘制一次性曲线，整理输出文件。",
                [
                    ("跳转到后处理", lambda: self.goto_tab(self.page_post)),
                    ("提取最终能量", self.extract_final_energy),
                ],
                self.page_post,
            ),
        ]

        steps_frame = ttk.Frame(frame)
        steps_frame.pack(fill=tk.BOTH, expand=True, padx=12, pady=6)
        steps_frame.grid_columnconfigure(0, weight=1)
        steps_frame.grid_columnconfigure(1, weight=1)
        for idx, (title, desc, buttons, page) in enumerate(steps):
            row, col = divmod(idx, 2)
            box = ttk.LabelFrame(steps_frame, text=title)
            box.grid(row=row, column=col, sticky="nsew", padx=6, pady=6)
            ttk.Label(box, text=desc, justify=tk.LEFT, wraplength=360).pack(anchor=tk.W, padx=8, pady=4)
            row_frame = ttk.Frame(box)
            row_frame.pack(anchor=tk.W, padx=8, pady=4)
            for txt, cmd in buttons:
                ttk.Button(row_frame, text=txt, command=cmd).pack(side=tk.LEFT, padx=4)
            ttk.Button(row_frame, text="打开此面板", command=lambda p=page: self.goto_tab(p)).pack(side=tk.LEFT, padx=8)

        notes = ttk.LabelFrame(frame, text="流程备注 / 待办")
        notes.pack(fill=tk.BOTH, expand=True, padx=12, pady=8)
        self.workflow_notes = tk.Text(notes, height=8)
        self.workflow_notes.pack(fill=tk.BOTH, expand=True, padx=6, pady=6)
        self.workflow_notes.insert(
            tk.END,
            "可在此记录当前任务的特殊参数、检查列表或备注。内容不会自动保存。",
        )
        return frame

    def kpoints_to_editor(self):
        s = gen_kpoints_monkhorst(self.k_nx.get(), self.k_ny.get(), self.k_nz.get(), self.k_gamma.get())
        self.kpoints_text.delete("1.0", tk.END)
        self.kpoints_text.insert("1.0", s)

    def kpoints_save(self):
        proj = self.current_project_path()
        proj.mkdir(parents=True, exist_ok=True)
        s = self.kpoints_text.get("1.0", tk.END)
        write_text(proj / "KPOINTS", s)
        messagebox.showinfo(APP_NAME, f"KPOINTS 已保存到 {proj/'KPOINTS'}")
        self.refresh_project_overview()

    def goto_tab(self, page):
        try:
            self.nb.select(page)
        except Exception:
            pass


    def append_run_log(self, msg: str):
        text = (msg or "")
        lines = text.splitlines() or [""]
        for line in lines:
            self.run_log.insert(tk.END, line.rstrip("\n") + "\n")
        self.run_log.see(tk.END)

    def _int_from_var(self, var, default=0) -> int:
        try:
            value = var.get()
        except Exception:
            value = default
        try:
            return int(value)
        except Exception:
            try:
                return int(default)
            except Exception:
                return 0

    # ------------------------- 页面：运行 / 提交 ----------------------------
    def _build_run_page(self, parent):
        frame = ttk.Frame(parent)

        status = ttk.LabelFrame(frame, text="运行状态")
        status.pack(fill=tk.X, padx=8, pady=6)
        row = ttk.Frame(status)
        row.pack(fill=tk.X, padx=6, pady=4)
        ttk.Label(row, text="当前状态：").pack(side=tk.LEFT)
        ttk.Label(row, textvariable=self.run_status_var).pack(side=tk.LEFT, padx=4)
        ttk.Button(row, text="刷新状态", command=self.refresh_run_status).pack(side=tk.RIGHT)
        run_suggest = tk.Text(status, height=3, wrap="word", state="disabled")
        run_suggest.pack(fill=tk.X, padx=6, pady=(0, 6))
        self._register_suggestion_widget(run_suggest)

        # 运行方式
        row0 = ttk.LabelFrame(frame, text="运行方式")
        row0.pack(fill=tk.X, padx=8, pady=8)
        self.run_mode = tk.StringVar(value="local")
        ttk.Radiobutton(row0, text="本地 mpirun", value="local", variable=self.run_mode).pack(side=tk.LEFT, padx=8)
        ttk.Radiobutton(row0, text="WSL2 (Windows)", value="wsl", variable=self.run_mode).pack(side=tk.LEFT, padx=8)
        ttk.Radiobutton(row0, text="SLURM 集群", value="slurm", variable=self.run_mode).pack(side=tk.LEFT)

        # VASP 执行文件 & 核心数
        row1 = ttk.LabelFrame(frame, text="VASP 执行配置")
        row1.pack(fill=tk.X, padx=8, pady=4)
        ttk.Label(row1, text="VASP 命令").grid(row=0, column=0, sticky=tk.W, padx=6, pady=4)
        self.vasp_cmd = tk.StringVar(value="vasp_std")
        ttk.Entry(row1, textvariable=self.vasp_cmd, width=30).grid(row=0, column=1, sticky=tk.W)
        ttk.Button(row1, text="which?", command=self.which_vasp).grid(row=0, column=2, padx=6)

        ttk.Label(row1, text="MPI 进程数 -np").grid(row=1, column=0, sticky=tk.W, padx=6, pady=4)
        self.mpi_np = tk.IntVar(value=8)
        ttk.Spinbox(row1, from_=1, to=2048, textvariable=self.mpi_np, width=8).grid(row=1, column=1, sticky=tk.W)

        # SLURM 区域
        row2 = ttk.LabelFrame(frame, text="SLURM 提交（仅在选择 SLURM 运行时使用）")
        row2.pack(fill=tk.X, padx=8, pady=4)
        self.slurm_part = tk.StringVar(value="normal")
        self.slurm_time = tk.StringVar(value="02:00:00")
        self.slurm_nodes = tk.IntVar(value=1)
        self.slurm_ntasks = tk.IntVar(value=32)
        self.slurm_account = tk.StringVar(value="")
        ttk.Label(row2, text="分区").grid(row=0, column=0, sticky=tk.W, padx=6, pady=4)
        ttk.Entry(row2, textvariable=self.slurm_part, width=12).grid(row=0, column=1)
        ttk.Label(row2, text="时长").grid(row=0, column=2, sticky=tk.W, padx=6)
        ttk.Entry(row2, textvariable=self.slurm_time, width=12).grid(row=0, column=3)
        ttk.Label(row2, text="节点").grid(row=0, column=4, sticky=tk.W, padx=6)
        ttk.Spinbox(row2, from_=1, to=128, textvariable=self.slurm_nodes, width=6).grid(row=0, column=5)
        ttk.Label(row2, text="ntasks").grid(row=0, column=6, sticky=tk.W, padx=6)
        ttk.Spinbox(row2, from_=1, to=8192, textvariable=self.slurm_ntasks, width=8).grid(row=0, column=7)
        ttk.Label(row2, text="账号").grid(row=0, column=8, sticky=tk.W, padx=6)
        ttk.Entry(row2, textvariable=self.slurm_account, width=12).grid(row=0, column=9)

        btns = ttk.Frame(frame)
        btns.pack(fill=tk.X, padx=8, pady=8)
        ttk.Button(btns, text="生成运行脚本", command=self.write_job_script).pack(side=tk.LEFT)
        ttk.Button(btns, text="启动/提交", command=self.start_run).pack(side=tk.LEFT, padx=8)
        ttk.Button(btns, text="停止本地进程", command=self.stop_local).pack(side=tk.LEFT)

        self.run_log = tk.Text(frame, height=14)
        self.run_log.pack(fill=tk.BOTH, expand=True, padx=8, pady=8)

        return frame

    def is_windows() -> bool:
        return os.name == "nt"

    def win_to_wsl_path(self, p: Path) -> str:
        # 将 Windows 路径 C:\foo\bar 转为 /mnt/c/foo/bar
        s = str(p)
        if len(s) >= 2 and s[1] == ":":
            drive = s[0].lower()
            rest = s[2:].replace("\\", "/")
            return f"/mnt/{drive}{rest if rest.startswith('/') else '/' + rest}"
        return s.replace("\\", "/")

    def which_vasp(self):
        cmd = self.vasp_cmd.get().strip()
        path = which(cmd)
        if path:
            messagebox.showinfo(APP_NAME, f"{cmd} -> {path}")
        else:
            messagebox.showwarning(APP_NAME, f"未在 PATH 中找到 {cmd}")

    def write_job_script(self):
        proj = self.current_project_path()
        proj.mkdir(parents=True, exist_ok=True)
        mode = self.run_mode.get()
        vcmd = self.vasp_cmd.get().strip()
        if mode == "local":
            script = f"""#!/bin/bash
# 本地运行 VASP（mpirun）
set -e
cd "{proj}"
echo "[INFO] Workdir: $(pwd)"
mpirun -np {self.mpi_np.get()} {vcmd} > vasp.out 2>&1
"""
            write_text(proj / "run_local.sh", script)
            os.chmod(proj / "run_local.sh", 0o755)
            self.append_run_log(f"已生成 {proj/'run_local.sh'}")
        else:
            acc = f"#SBATCH --account={self.slurm_account.get()}\n" if self.slurm_account.get().strip() else ""
            script = f"""#!/bin/bash
#SBATCH --job-name=vasp
#SBATCH --partition={self.slurm_part.get()}
#SBATCH --time={self.slurm_time.get()}
#SBATCH --nodes={self.slurm_nodes.get()}
#SBATCH --ntasks={self.slurm_ntasks.get()}
{acc}

cd "{proj}"
echo "SLURM_JOB_ID=$SLURM_JOB_ID"

# 视集群环境加载模块或设置变量
# module load vasp

srun {vcmd}
"""
            write_text(proj / "run_slurm.sh", script)
            os.chmod(proj / "run_slurm.sh", 0o755)
            self.append_run_log(f"已生成 {proj/'run_slurm.sh'}")

    def start_run(self):
        proj = self.current_project_path()
        mode = self.run_mode.get()
        vcmd = self.vasp_cmd.get().strip()
        if not proj.exists():
            messagebox.showerror(APP_NAME, f"项目目录不存在：{proj}")
            return
        missing = [f for f in ["INCAR", "POSCAR", "POTCAR"] if not (proj / f).exists()]
        if missing:
            if not messagebox.askyesno(
                APP_NAME,
                "检测到以下关键输入文件缺失：\n"
                + "\n".join(missing)
                + "\n仍要继续启动吗？",
            ):
                return
        if mode == "local":
            if self.proc and self.proc.poll() is None:
                messagebox.showwarning(APP_NAME, "已有本地 VASP 进程在运行。先停止或等待结束。")
                return
            if not which("mpirun"):
                messagebox.showerror(APP_NAME, "未找到 mpirun。请安装 OpenMPI 或 Intel MPI。")
                return
            if not which(vcmd):
                messagebox.showerror(APP_NAME, f"未找到 VASP 命令：{vcmd}")
                return
            cmd = ["bash", "-lc", f"cd '{proj}' && mpirun -np {self.mpi_np.get()} {vcmd} > vasp.out 2>&1 & echo $!"]
            try:
                out = subprocess.check_output(cmd, text=True)
                pid = int(out.strip())
                self.append_run_log(f"已启动本地 VASP，PID={pid}")
                self.proc = subprocess.Popen(["bash", "-lc", f"tail -f -n +1 '{proj / 'vasp.out'}'"], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                self.append_run_log("日志跟随 vasp.out（tail -f）已启动。")
                self.start_monitor()
            except Exception as e:
                messagebox.showerror(APP_NAME, f"启动失败：{e}")
        elif mode == "wsl":
            # Windows GUI -> 在 WSL 内调用 mpirun 运行 VASP
            if not is_windows() or not which("wsl"):
                messagebox.showerror(APP_NAME, "未检测到 Windows/WSL 环境或 wsl.exe 不可用。")
                return
            # 建议把项目放在 Windows 盘，如 C:\... ，WSL 中对应 /mnt/c/...
            proj_wsl = self.win_to_wsl_path(proj)
            cmd = ["wsl", "-e", "bash", "-lc", f"cd '{proj_wsl}' && mpirun -np {self.mpi_np.get()} {vcmd} > vasp.out 2>&1 & echo $!"]
            try:
                out = subprocess.check_output(cmd, text=True)
                pid = out.strip()
                self.append_run_log(f"已在 WSL 启动 VASP，PID={pid}")
                # 在 Windows 侧跟随同一路径（使用 Windows 路径监视 vasp.out）
                if which("powershell"):
                    self.proc = subprocess.Popen(["powershell", "-NoProfile", "-Command", f"Get-Content -Path '{(proj / 'vasp.out')}' -Wait"], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                else:
                    # 退化为 Python 轮询
                    self.proc = None
                self.append_run_log("日志跟随 vasp.out（Windows 侧）已启动。")
                self.start_monitor()
            except Exception as e:
                messagebox.showerror(APP_NAME, f"WSL 启动失败：{e}")
        else:
            # 提交 SLURM
            if not which("sbatch"):
                messagebox.showerror(APP_NAME, "未找到 sbatch。请在 SLURM 节点上运行或配置环境。")
                return
            script = proj / "run_slurm.sh"
            if not script.exists():
                self.write_job_script()
            try:
                out = subprocess.check_output(["bash", "-lc", f"cd '{proj}' && sbatch '{script.name}'"], text=True)
                if out:
                    self.append_run_log(out)
                self.start_monitor()
            except subprocess.CalledProcessError as e:
                messagebox.showerror(APP_NAME, f"sbatch 失败：{e}{e.output}")

    def stop_local(self):
        # 尝试优雅停止本地 vasp：找出进程名包含 vasp 的并杀掉当前目录下的
        proj = self.current_project_path()
        try:
            # 粗暴但简单：pkill -f "vasp.*{proj}"
            subprocess.call(["bash", "-lc", f"pkill -f 'vasp' || true"])  # 保守处理

            self.append_run_log("已尝试停止本地 VASP 进程（pkill -f 'vasp'）。")
            self.refresh_run_status()
        except Exception as e:
            messagebox.showerror(APP_NAME, f"停止失败：{e}")

    # ------------------------- 页面：监视 ----------------------------------
    def _build_monitor_page(self, parent):
        frame = ttk.Frame(parent)

        status_box = ttk.LabelFrame(frame, text="运行状态概览")
        status_box.pack(fill=tk.X, padx=8, pady=6)
        row = ttk.Frame(status_box)
        row.pack(fill=tk.X, padx=6, pady=4)
        ttk.Label(row, text="当前状态：").pack(side=tk.LEFT)
        ttk.Label(row, textvariable=self.run_status_var).pack(side=tk.LEFT, padx=4)
        ttk.Button(row, text="刷新状态", command=self.refresh_run_status).pack(side=tk.RIGHT)
        monitor_suggest = tk.Text(status_box, height=3, wrap="word", state="disabled")
        monitor_suggest.pack(fill=tk.X, padx=6, pady=(0, 6))
        self._register_suggestion_widget(monitor_suggest)

        top = ttk.Frame(frame)
        top.pack(fill=tk.X, padx=8, pady=6)
        ttk.Button(top, text="开始监视", command=self.start_monitor).pack(side=tk.LEFT)
        ttk.Button(top, text="停止监视", command=self.stop_monitor).pack(side=tk.LEFT, padx=6)
        ttk.Label(top, text="文件列表(逗号分隔)").pack(side=tk.LEFT, padx=6)
        self.file_watch_var = tk.StringVar(value="vasp.out,OSZICAR,OUTCAR")
        ttk.Entry(top, textvariable=self.file_watch_var, width=36).pack(side=tk.LEFT)

        fig = Figure(figsize=(6, 4), dpi=100)
        self.ax = fig.add_subplot(111)
        self.ax.set_xlabel("Step")
        self.ax.set_ylabel("Total energy (F or E0) [eV]")
        self.ax.grid(True, linestyle=":", linewidth=0.8)
        self.line, = self.ax.plot([], [], marker="o", linestyle="-")

        self.canvas = FigureCanvasTkAgg(fig, master=frame)
        self.canvas.draw()
        self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True, padx=8, pady=8)

        self.mon_info = tk.Text(frame, height=6)
        self.mon_info.pack(fill=tk.BOTH, expand=False, padx=8, pady=4)

        sys_frame = ttk.LabelFrame(frame, text="系统状态：CPU / 进程 / 文件增长")
        sys_frame.pack(fill=tk.BOTH, expand=False, padx=8, pady=6)
        self.sys_info = tk.Text(sys_frame, height=10)
        self.sys_info.pack(fill=tk.BOTH, expand=True, padx=6, pady=6)

        self.sys_info.insert(tk.END, "点击“开始监视”以获取实时系统信息。\n")

        return frame

    def start_monitor(self):
        self.stop_monitor()
        proj = self.current_project_path()
        self.monitor = EnergyMonitor(proj, self.on_energy_update)
        self.monitor.start()
        self.mon_info.insert(tk.END, f"开始监视 {proj/'OSZICAR'}\n")
        self.mon_info.see(tk.END)
        watch_files = [s.strip() for s in self.file_watch_var.get().split(",") if s.strip()]
        self.sys_monitor = SystemStatsMonitor(proj, watch_files, self.on_system_update)
        self.sys_monitor.start()
        self.sys_info.delete("1.0", tk.END)
        self.sys_info.insert(tk.END, "系统监视线程已启动……\n")
        self.apply_run_status("🟡 正在监视…", ["系统监视线程已启动，等待数据更新。"])

    def stop_monitor(self):
        if self.monitor:
            self.monitor.stop()
            self.monitor = None
        if self.sys_monitor:

            monitor = self.sys_monitor
            self.sys_monitor = None
            monitor.stop()
        self.mon_info.insert(tk.END, "已停止监视。\n")
        self.mon_info.see(tk.END)
        self.sys_info.insert(tk.END, "系统监视已停止。\n")
        self.refresh_run_status()

    def on_energy_update(self, steps, energies):
        # Tk 线程安全：使用 after 回到主线程更新
        def _upd():
            self.ax.cla()
            self.ax.set_xlabel("Step")
            self.ax.set_ylabel("Total energy (F or E0) [eV]")
            self.ax.grid(True, linestyle=":", linewidth=0.8)
            if steps and energies:
                self.ax.plot(steps, energies, marker="o", linestyle="-")
            self.canvas.draw_idle()
            if energies:
                self.mon_info.insert(tk.END, f"最新步：{steps[-1]}, 能量：{energies[-1]:.6f} eV\n")
                self.mon_info.see(tk.END)
        self.after(0, _upd)

    def on_system_update(self, stats):
        def _upd():
            self._handle_stats(stats)
            lines = []
            run_state = stats.get("run_state")
            run_pids = stats.get("run_pids", [])
            if run_state == "running" and run_pids:
                lines.append(f"运行状态：运行中 (PID {', '.join(run_pids)})")
            elif run_state == "idle":
                lines.append("运行状态：未检测到 VASP 进程")
            else:
                lines.append("运行状态：未知")
            lines.append(f"时间：{stats.get('timestamp', '-')}")
            cpu = stats.get("cpu_usage")
            if cpu is not None:
                lines.append(f"CPU 使用率：{cpu:.1f}%")
            load = stats.get("loadavg")
            if load:
                lines.append(f"平均负载：{load[0]:.2f}, {load[1]:.2f}, {load[2]:.2f}")
            lines.append("监视文件：")
            for item in stats.get("files", []):
                name = item.get("name", "-")
                if item.get("exists"):
                    size = format_bytes(item.get("size"))
                    delta = format_bytes(item.get("delta"))
                    lines.append(f"  {name}: {size} (Δ {delta})")
                else:
                    lines.append(f"  {name}: 未找到")
            procs = stats.get("processes", [])
            if procs:
                lines.append("相关进程 (前5按CPU)：")
                for p in procs:
                    mark = "★" if p.get("is_vasp") else " "
                    lines.append(
                        f" {mark} PID {p.get('pid')} {p.get('cmd')} | CPU {p.get('cpu')} | MEM {p.get('mem')}"
                    )
            else:
                lines.append("未获取到进程信息 (可能无 ps 命令或权限不足)。")
            self.sys_info.delete("1.0", tk.END)
            self.sys_info.insert(tk.END, "\n".join(lines) + "\n")
        self.after(0, _upd)

    # ------------------------- 页面：后处理（简） ---------------------------
    def _build_post_page(self, parent):
        frame = ttk.Frame(parent)
        row = ttk.Frame(frame)
        row.pack(fill=tk.X, padx=8, pady=8)
        ttk.Button(row, text="读取 OSZICAR 绘制（一次性）", command=self.plot_once_from_oszicar).pack(side=tk.LEFT)
        ttk.Button(row, text="提取最终能量", command=self.extract_final_energy).pack(side=tk.LEFT, padx=8)

        self.post_log = tk.Text(frame, height=18)
        self.post_log.pack(fill=tk.BOTH, expand=True, padx=8, pady=8)
        return frame

    def plot_once_from_oszicar(self):
        proj = self.current_project_path()
        osz = proj / "OSZICAR"
        if not osz.exists():
            messagebox.showwarning(APP_NAME, f"{osz} 不存在。")
            return
        steps, energies = [], []
        try:
            with osz.open("r", encoding="utf-8", errors="ignore") as f:
                i = 0
                for line in f:
                    m = ENERGY_RX.search(line)
                    if m:
                        val = m.group(1) or m.group(2)
                        try:
                            e = float(val)
                            i += 1
                            steps.append(i)
                            energies.append(e)
                        except Exception:
                            pass
        except Exception as e:
            messagebox.showerror(APP_NAME, f"解析失败：{e}")
            return
        # 复用监视页画布
        self.on_energy_update(steps, energies)
        self.post_log.insert(tk.END, f"一次性绘制完成，点数：{len(steps)}\n")
        self.post_log.see(tk.END)

    def extract_final_energy(self):
        proj = self.current_project_path()
        osz = proj / "OSZICAR"
        if not osz.exists():
            messagebox.showwarning(APP_NAME, f"{osz} 不存在。")
            return
        last_e = None
        try:
            for line in osz.read_text(encoding="utf-8", errors="ignore").splitlines():
                m = ENERGY_RX.search(line)
                if m:
                    val = m.group(1) or m.group(2)
                    try:
                        last_e = float(val)
                    except Exception:
                        pass
        except Exception as e:
            messagebox.showerror(APP_NAME, f"解析失败：{e}")
            return
        if last_e is None:
            messagebox.showwarning(APP_NAME, "未解析到能量。")
        else:
            self.post_log.insert(tk.END, f"最终能量（最后一步）：{last_e:.6f} eV\n")
            self.post_log.see(tk.END)

    # ------------------------- 配置读写（保存用户设置） ---------------------
    def load_config(self):
        if not CONFIG_PATH.exists():
            return
        try:
            data = json.loads(CONFIG_PATH.read_text(encoding="utf-8"))
        except Exception:
            return
        # 窗口几何
        geom = data.get("geometry")
        if geom:
            try:
                self.geometry(geom)
            except Exception:
                pass
        # 基本变量
        project_path = data.get("project", self.project_var.get())
        self.pot_dir_var.set(data.get("pot_dir", self.pot_dir_var.get()))
        self.run_mode.set(data.get("run_mode", self.run_mode.get()))
        self.vasp_cmd.set(data.get("vasp_cmd", self.vasp_cmd.get()))
        try:
            self.mpi_np.set(int(data.get("mpi_np", self.mpi_np.get())))
        except Exception:
            pass
        self.file_watch_var.set(data.get("file_watch", self.file_watch_var.get()))
        # SLURM
        self.slurm_part.set(data.get("slurm_part", self.slurm_part.get()))
        self.slurm_time.set(data.get("slurm_time", self.slurm_time.get()))
        try:
            self.slurm_nodes.set(int(data.get("slurm_nodes", self.slurm_nodes.get())))
            self.slurm_ntasks.set(int(data.get("slurm_ntasks", self.slurm_ntasks.get())))
        except Exception:
            pass
        self.slurm_account.set(data.get("slurm_account", self.slurm_account.get()))
        # K 网格
        k = data.get("kgrid", {})
        for var, key in [(self.k_nx, "nx"),(self.k_ny, "ny"),(self.k_nz, "nz")]:
            try:
                var.set(int(k.get(key, var.get())))
            except Exception:
                pass
        try:
            self.k_gamma.set(bool(k.get("gamma", self.k_gamma.get())))
        except Exception:
            pass
        # 选中的页签
        try:
            idx = int(data.get("tab_index", 0))
            self.nb.select(idx)
        except Exception:
            pass
        self.set_project(project_path)

    def save_config(self):
        data = {
            "geometry": self.geometry(),
            "project": self.project_var.get(),
            "pot_dir": self.pot_dir_var.get(),
            "run_mode": self.run_mode.get(),
            "vasp_cmd": self.vasp_cmd.get(),
            "mpi_np": self._int_from_var(self.mpi_np, 8),
            "slurm_part": self.slurm_part.get(),
            "slurm_time": self.slurm_time.get(),
            "slurm_nodes": self._int_from_var(self.slurm_nodes, 1),
            "slurm_ntasks": self._int_from_var(self.slurm_ntasks, 32),
            "slurm_account": self.slurm_account.get(),
            "kgrid": {
                "nx": self._int_from_var(self.k_nx, 5),
                "ny": self._int_from_var(self.k_ny, 5),
                "nz": self._int_from_var(self.k_nz, 5),
                "gamma": bool(self.k_gamma.get()),
            },
            "tab_index": self.nb.index("current"),
            "file_watch": self.file_watch_var.get(),
        }
        try:
            CONFIG_DIR.mkdir(parents=True, exist_ok=True)
            CONFIG_PATH.write_text(json.dumps(data, ensure_ascii=False, indent=2), encoding="utf-8")
        except Exception:
            pass

    def _register_suggestion_widget(self, widget: tk.Text):
        self.run_suggestion_widgets.append(widget)

    def current_project_path(self) -> Path:
        val = self.project_var.get()
        try:
            proj = Path(val).expanduser()
        except Exception:
            proj = Path(val)
        self.project_dir = proj
        return proj

    def apply_run_status(self, status_text: str, suggestions: list[str] | None = None):
        self.run_status_var.set(status_text)
        text = "暂无建议。"
        if suggestions:
            text = "\n".join(f"• {s}" for s in suggestions)
        for widget in self.run_suggestion_widgets:
            try:
                widget.configure(state="normal")
                widget.delete("1.0", tk.END)
                widget.insert("1.0", text)
                widget.configure(state="disabled")
            except Exception:
                pass

    def refresh_run_status(self):
        proj = self.current_project_path()
        if not proj.exists():
            self.apply_run_status("⚠️ 项目目录不存在", ["请选择有效的项目路径。"])
            return
        watch_files = [s.strip() for s in self.file_watch_var.get().split(",") if s.strip()]
        stats = SystemStatsMonitor.snapshot(proj, watch_files)
        self._handle_stats(stats)

    def _handle_stats(self, stats: dict):
        run_state = stats.get("run_state")
        run_pids = stats.get("run_pids", [])
        if run_state == "running" and run_pids:
            status = f"🟢 运行中 (PID {', '.join(run_pids)})"
        elif run_state == "idle":
            status = "⚪ 未检测到 VASP 进程"
        else:
            status = "⚠️ 状态未知"
        suggestions = stats.get("suggestions") or []
        self.apply_run_status(status, suggestions)
        self.update_overview_with_file_stats(stats.get("files", []))

    def update_overview_with_file_stats(self, file_stats: list[dict]):
        tree = getattr(self, "workflow_tree", None)
        if not tree or not file_stats:
            return
        for item in file_stats:
            name = item.get("name")
            if not name:
                continue
            short = Path(name).name
            key = self.overview_key_map.get(short.lower())
            if not key or not tree.exists(key):
                continue
            label = self.overview_label_map.get(key, short)
            if item.get("exists"):
                detail = f"大小 {format_bytes(item.get('size'))}"
                delta = item.get("delta")
                if isinstance(delta, (int, float)):
                    detail += f" | Δ {format_bytes(delta)}"
                status = "🟡 输出中" if isinstance(delta, (int, float)) and delta > 0 else "✅ 已存在"
            else:
                status = "⚠️ 未找到"
                detail = "尚未生成或路径不匹配"
            tree.item(key, values=(label, status, detail))

    def refresh_project_overview(self):
        tree = getattr(self, "workflow_tree", None)
        if not tree:
            return
        for row in tree.get_children():
            tree.delete(row)
        proj = self.current_project_path()
        exists = proj.exists()
        proj_status = "✅ 已存在" if exists else "⚠️ 未找到"
        tree.insert(
            "",
            tk.END,
            iid="__project__",
            values=(self.overview_label_map.get("__project__", "项目目录"), proj_status, str(proj)),
        )
        for key, label in self.overview_items:
            if key == "__project__":
                continue
            path = proj / key
            if path.exists():
                try:
                    stat = path.stat()
                    mtime = time.strftime("%Y-%m-%d %H:%M", time.localtime(stat.st_mtime))
                    status = "✅ 已存在"
                    detail = f"更新于 {mtime} | {format_bytes(stat.st_size)}"
                except Exception:
                    status = "✅ 已存在"
                    detail = "已检测到文件"
            else:
                status = "⚠️ 未找到"
                detail = "项目目录中未检测到该文件"
            tree.insert("", tk.END, iid=key, values=(label, status, detail))

    def load_project_inputs(self):
        proj = self.current_project_path()
        mapping = [
            (proj / "INCAR", getattr(self, "incar_text", None)),
            (proj / "POSCAR", getattr(self, "poscar_text", None)),
            (proj / "KPOINTS", getattr(self, "kpoints_text", None)),
        ]
        for path, widget in mapping:
            if not widget or not path.exists():
                continue
            try:
                widget.delete("1.0", tk.END)
                widget.insert("1.0", read_text(path))
            except Exception:
                pass

    def set_project(self, path: Path):
        try:
            path = Path(path).expanduser()
        except Exception:
            path = Path(path)
        self.project_dir = path
        self.project_var.set(str(path))
        self.load_project_inputs()
        self.refresh_project_overview()
        self.refresh_run_status()

    # ------------------------- 项目与体检 ----------------------------------
    def choose_project(self):
        d = filedialog.askdirectory(initialdir=self.project_var.get(), title="选择项目目录")
        if d:
            self.set_project(Path(d))

    def create_project(self):
        d = filedialog.askdirectory(initialdir=str(Path.home()), title="选择或创建项目父目录")
        if not d:
            return
        # 创建以时间命名的项目
        base = Path(d)
        name = time.strftime("vasp_proj_%Y%m%d_%H%M%S")
        p = base / name
        p.mkdir(parents=True, exist_ok=True)
        self.set_project(p)
        messagebox.showinfo(APP_NAME, f"已创建项目目录：{p}")

    def quick_check(self):
        proj = self.current_project_path()
        msgs = []
        for f in ["INCAR", "POSCAR", "POTCAR", "KPOINTS"]:
            exists = (proj / f).exists()
            msgs.append(f"{f:7s} : {'✔' if exists else '✗'}")
        for cmd in ["mpirun", self.vasp_cmd.get().strip(), "sbatch", "wsl" if os.name == "nt" else None]:
            if cmd:
                msgs.append(f"which {cmd:8s} -> {which(cmd) or '未找到'}")
        potroot = Path(self.pot_dir_var.get())
        msgs.append(f"POT 库: {potroot} {'(存在)' if potroot.exists() else '(不存在)'}")
        for msg in msgs:
            self.append_run_log(msg)
        self.refresh_project_overview()
        self.refresh_run_status()

    # ------------------------- 退出清理 ------------------------------------
    def on_close(self):
        try:
            # 保存配置
            self.save_config()
            # 停止监视与 tail 进程
            self.stop_monitor()
            if self.proc and self.proc.poll() is None:
                self.proc.terminate()
        except Exception:
            pass
        self.destroy()


if __name__ == "__main__":
    app = VaspGUI()
    app.mainloop()