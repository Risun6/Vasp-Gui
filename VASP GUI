#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
VASP Linux 一体化GUI（Tkinter 版 | 单文件可运行）
=================================================
目标：把 Linux 下常用 VASP 操作整合到简洁 GUI：项目管理、INCAR/POSCAR/KPOINTS 编辑、
POTCAR 拼接（本地已有赝势）、K 点生成、作业脚本生成与提交（本地 / SLURM）、
以及 OSZICAR 能量-步数监视与简单可视化。

依赖（尽量轻）：
- Python 3.8+
- tkinter（随 Python 自带）
- matplotlib（绘图）

可选依赖（提升体验，但不是必须）：
- ttkbootstrap（更美观的主题）
- pymatgen / ase（将来可扩展结构与后处理）

使用：
- python vasp_gui.py

说明：
- 本工具不包含、也不会分发任何 VASP 程序或赝势文件。请确保你拥有 VASP 许可，
  并在"POTCAR 面板"正确设置本地赝势库路径。
- 监视功能主要解析 OSZICAR（F= 或 E0= 行），用于快速查看收敛趋势。
- SLURM 模板可在 GUI 中一键生成，你可以直接提交或先手动修改。

作者：ChatGPT（GPT-5 Thinking）
许可：MIT
"""
from __future__ import annotations
import os
import sys
import re
import time
import json
import shutil
import threading
import subprocess
from pathlib import Path

try:
    import tkinter as tk
    from tkinter import ttk, filedialog, messagebox
except Exception as e:
    print("[FATAL] Tkinter 未安装或不可用：", e)
    sys.exit(1)

# matplotlib 放在 TkAgg 嵌入
import matplotlib
matplotlib.use("TkAgg")
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib.figure import Figure

APP_NAME = "VASP Linux 一体化GUI"
APP_VER = "0.1.0-MVP"

# 配置文件路径（保存用户设置）
CONFIG_DIR = Path.home() / ".config" / "vasp_gui"
CONFIG_PATH = CONFIG_DIR / "config.json"

# === ETA helpers ===
ETA_LOOP_RX = re.compile(r"LOOP:\s+cpu time\s+([0-9.eE+\-]+)\s*:\s*real time\s+([0-9.eE+\-]+)", re.IGNORECASE)
ETA_LOOP_CPU_ONLY_RX = re.compile(r"LOOP:\s+cpu time\s+([0-9.eE+\-]+)", re.IGNORECASE)
ETA_ITER_LINE_RX = re.compile(r"^\s*\d+\s+[-+]?[\d.eE]+\s")  # OSZICAR: "  N   E   dE ..."
ETA_F_LINE_RX = re.compile(r"\bF=\s*([-+]?\d+\.\d+)")

def _fmt_eta_seconds(sec: float | None) -> str:
    if not sec or sec <= 0:
        return "—"
    sec = int(sec)
    h = sec // 3600
    m = (sec % 3600) // 60
    s = sec % 60
    return (f"{h:d}:{m:02d}:{s:02d}" if h else f"{m:d}:{s:02d}")

def _parse_incar_int(path: Path, key: str, default: int | None = None) -> int | None:
    try:
        txt = path.read_text(encoding="utf-8", errors="ignore")
    except Exception:
        return default
    rx = re.compile(rf"^\s*{re.escape(key)}\s*=\s*([-+]?\d+)", re.IGNORECASE | re.MULTILINE)
    m = rx.search(txt)
    return int(m.group(1)) if m else default

def _oszicar_stats(osz: Path) -> tuple[int, float | None]:
    """返回 (已完成离子步数, 每离子步平均SCF迭代数)。"""
    if not osz.exists():
        return 0, None
    steps_done = 0
    iter_counts: list[int] = []
    cur = 0
    try:
        for line in osz.read_text(encoding="utf-8", errors="ignore").splitlines():
            if ETA_ITER_LINE_RX.match(line):
                cur += 1
            elif ETA_F_LINE_RX.search(line):
                steps_done += 1
                if cur > 0:
                    iter_counts.append(cur)
                cur = 0
    except Exception:
        pass
    avg_iter = (sum(iter_counts) / len(iter_counts)) if iter_counts else None
    return steps_done, avg_iter

def _vaspout_loop_times(vout: Path, take_last: int = 40) -> tuple[float | None, int]:
    """解析 vasp.out 最近的 LOOP 行，返回(平均单次SCF耗时(秒), 已解析迭代数)。"""
    if not vout.exists():
        return None, 0
    try:
        lines = vout.read_text(encoding="utf-8", errors="ignore").splitlines()
    except Exception:
        return None, 0
    times: list[float] = []
    for ln in reversed(lines):
        m = ETA_LOOP_RX.search(ln)
        if m:
            # 优先 real time
            try:
                times.append(float(m.group(2)))
            except Exception:
                try:
                    times.append(float(m.group(1)))
                except Exception:
                    pass
        else:
            m2 = ETA_LOOP_CPU_ONLY_RX.search(ln)
            if m2:
                try:
                    times.append(float(m2.group(1)))
                except Exception:
                    pass
        if len(times) >= take_last:
            break
    if not times:
        return None, 0
    # 使用中位数更稳，也可用均值
    times_sorted = sorted(times)
    mid = times_sorted[len(times_sorted)//2]
    return (mid, len(times))


# ----------------------------- 工具函数区 ----------------------------------

def which(cmd: str) -> str | None:
    """返回可执行文件绝对路径，找不到则 None。"""
    return shutil.which(cmd)

def read_text(p: Path) -> str:
    try:
        return p.read_text(encoding="utf-8")
    except Exception:
        try:
            return p.read_text(encoding="latin-1")
        except Exception:
            return ""

def write_text(p: Path, s: str) -> None:
    p.write_text(s, encoding="utf-8")

def format_bytes(num: int | float | None) -> str:
    """将字节数转为易读字符串。"""
    if num is None:
        return "-"
    try:
        n = float(num)
    except Exception:
        return str(num)
    if n < 0:
        n = 0.0
    units = ["B", "KB", "MB", "GB", "TB", "PB"]
    for unit in units:
        if n < 1024.0 or unit == units[-1]:
            if unit == "B":
                return f"{int(n)} {unit}"
            return f"{n:.1f} {unit}"
        n /= 1024.0
    return f"{n:.1f} PB"

POSCAR_ELEM_LINE_RX = re.compile(r"^\s*([A-Za-z][a-z]?(?:\s+[A-Za-z][a-z]?)*?)\s*$")
COUNTS_RX = re.compile(r"^\s*(\d+(?:\s+\d+)*)\s*$")
# 兼容:  -12.34   12.   .1234   -1.23E+02   3.4D-01
ENERGY_RX = re.compile(
    r"F=\s*([+-]?(?:\d+(?:\.\d*)?|\.\d+)(?:[EeDd][+-]?\d+)?)"
    r"|E0=\s*([+-]?(?:\d+(?:\.\d*)?|\.\d+)(?:[EeDd][+-]?\d+)?)"
)
# 备用：从 OUTCAR 也能抓（有时 OSZICAR 很慢才写）
TOTEN_RX = re.compile(
    r"free\s+energy\s+TOTEN\s*=\s*([+-]?(?:\d+(?:\.\d*)?|\.\d+)(?:[EeDd][+-]?\d+)?)",
    re.IGNORECASE
)



def parse_poscar(poscar_text: str):
    """粗略解析 POSCAR 的元素与计数。尽量兼容两种第6/7行写法。
    返回 (elements: list[str], counts: list[int])，可能为空。"""
    lines = [ln.rstrip("\n") for ln in poscar_text.splitlines() if ln.strip() != ""]
    if len(lines) < 8:
        return [], []
    # 寻找元素与计数两行：兼容存在 Selective dynamics 行
    # 常见：
    # 1: comment
    # 2: scale
    # 3-5: lattice
    # 6: elements OR counts
    # 7: counts (if 6 is elements)
    # 8: Selective dynamics? OR Direct/Cartesian
    elem_line = None
    cnt_line = None

    # 尝试 line6 作为元素，line7 作为计数
    l6 = lines[5]
    l7 = lines[6]
    if POSCAR_ELEM_LINE_RX.match(l6) and COUNTS_RX.match(l7):
        elem_line = l6
        cnt_line = l7
    else:
        # 也可能 line6 就是计数（没有元素符号行）
        if COUNTS_RX.match(l6):
            cnt_line = l6
            elem_line = None

    elements = []
    if elem_line:
        elements = elem_line.split()
    # 计数
    counts = []
    if cnt_line:
        counts = [int(x) for x in cnt_line.split()]

    return elements, counts


def unique_elements_from_poscar(poscar_text: str):
    elems, _ = parse_poscar(poscar_text)
    return elems


def find_potcar_candidates(elem: str, pot_dir: Path) -> list[Path]:
    """在 pot_dir 下递归查找包含给定元素名称的 POTCAR 文件，返回候选列表。
    常见目录层级（示例）：
      PAW_PBE/Si/POTCAR  或  potcars/PBE/Si/POTCAR  或  potpaw_PBE.54/Si/POTCAR
    策略：深度<=3 的广度优先查找，目录名包含元素精确匹配。"""
    elem = elem.strip()
    max_depth = 3
    queue = [(pot_dir, 0)]
    candidates = []
    while queue:
        d, depth = queue.pop(0)
        if depth > max_depth:
            continue
        try:
            for entry in d.iterdir():
                if entry.is_dir():
                    name = entry.name
                    if name == elem:
                        pot = entry / "POTCAR"
                        if pot.exists():
                            candidates.append(pot)
                    queue.append((entry, depth + 1))
        except PermissionError:
            pass
        except FileNotFoundError:
            pass
    seen = []
    unique: list[Path] = []
    for cand in candidates:
        key = str(cand)
        if key not in seen:
            seen.append(key)
            unique.append(cand)
    return unique


def build_potcar(pot_files: list[Path], out_path: Path) -> tuple[bool, str]:
    """将 pot_files 中的 POTCAR 依序拼接到 out_path。返回 (ok, msg)。"""
    if not pot_files:
        return False, "未提供任何 POTCAR 文件。"
    try:
        with open(out_path, "wb") as fout:
            for p in pot_files:
                pp = Path(p)
                if not pp.exists():
                    return False, f"未找到 POTCAR：{pp}"
                fout.write(pp.read_bytes())
        return True, f"POTCAR 已生成：{out_path}"
    except Exception as ex:
        return False, f"生成 POTCAR 失败：{ex}"


def gen_kpoints_monkhorst(nx: int, ny: int, nz: int, gamma_center: bool) -> str:
    lines = [
        "Auto KPOINTS",
        "0",
        "Gamma" if gamma_center else "Monkhorst-Pack",
        f"{nx} {ny} {nz}",
        "0 0 0",
    ]
    return "\n".join(lines) + "\n"

# ----------------------------- GUI 组件 ------------------------------------

class SystemStatsMonitor(threading.Thread):
    """后台线程：监视 CPU/进程以及关键文件增长情况。"""

    def __init__(self, workdir: Path, watch_files: list[str] | None, on_update=None):
        super().__init__(daemon=True)
        self.workdir = Path(workdir).expanduser()
        try:
            self.workdir_resolved = self.workdir.resolve()
        except Exception:
            self.workdir_resolved = self.workdir
        self.watch_files = watch_files or []
        self.on_update = on_update  # callback(dict)
        self._stop_event = threading.Event()
        self._prev_cpu = None  # tuple(total, idle)
        self._prev_sizes: dict[Path, int] = {}

    def stop(self):
        self._stop_event.set()

        if self.is_alive():
            try:
                self.join(timeout=2.0)
            except RuntimeError:
                pass

    def run(self):
        while not self._stop_event.is_set():
            stats = self._collect_stats()
            if self.on_update:
                try:
                    self.on_update(stats)
                except Exception:
                    pass
            for _ in range(6):
                if self._stop_event.is_set():
                    break
                time.sleep(0.5)

    def _collect_stats(self) -> dict:
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
        cpu_usage = self._cpu_usage_percent()
        loadavg = self._loadavg()
        files = self._file_stats()
        procs = self._process_stats()
        run_state, run_pids, suggestions = self._run_status(procs, files)
        return {
            "timestamp": timestamp,
            "cpu_usage": cpu_usage,
            "loadavg": loadavg,
            "files": files,
            "processes": procs,
            "run_state": run_state,
            "run_pids": run_pids,
            "suggestions": suggestions,
        }

    def _cpu_usage_percent(self) -> float | None:
        proc_stat = Path("/proc/stat")
        if not proc_stat.exists():
            return None
        try:
            line = proc_stat.read_text().splitlines()[0]
        except Exception:
            return None
        parts = line.split()
        if len(parts) < 5 or parts[0] != "cpu":
            return None
        try:
            values = [float(x) for x in parts[1:]]
        except Exception:
            return None
        idle = values[3]
        total = sum(values)
        if self._prev_cpu is None:
            self._prev_cpu = (total, idle)
            return None
        prev_total, prev_idle = self._prev_cpu
        total_delta = total - prev_total
        idle_delta = idle - prev_idle
        self._prev_cpu = (total, idle)
        if total_delta <= 0:
            return None
        usage = max(0.0, min(100.0, (1.0 - idle_delta / total_delta) * 100.0))
        return usage

    def _loadavg(self) -> tuple[float, float, float] | None:
        if hasattr(os, "getloadavg"):
            try:
                return os.getloadavg()
            except OSError:
                return None
        return None

    def _file_stats(self) -> list[dict]:
        stats = []
        for name in self.watch_files:
            if not name:
                continue
            p = Path(name)
            if not p.is_absolute():
                p = self.workdir / name
            p = p.resolve()
            info = {
                "name": str(p),
                "exists": False,
                "size": 0,
                "delta": 0,
            }
            try:
                if p.exists():
                    size = p.stat().st_size
                    prev = self._prev_sizes.get(p, size)
                    info.update({
                        "exists": True,
                        "size": size,
                        "delta": size - prev,
                    })
                    self._prev_sizes[p] = size
            except Exception:
                pass
            stats.append(info)
        return stats

    def _process_stats(self) -> list[dict]:
        # 限制输出 + 超时，避免在某些系统里 ps 卡住
        try:
            out = subprocess.check_output(
                ["bash", "-lc", "ps -eo pid,%cpu,%mem,cmd --sort=-%cpu | head -n 6"],
                text=True, stderr=subprocess.DEVNULL, timeout=2.0
            )
        except Exception:
            try:
                out = subprocess.check_output(
                    ["ps", "-eo", "pid,%cpu,%mem,cmd"],
                    text=True, stderr=subprocess.DEVNULL, timeout=2.0
                )
                out = "\n".join(out.splitlines()[:6])
            except Exception:
                return []

        lines = out.strip().splitlines()
        procs = []
        for line in lines[1:6]:
            parts = line.split(None, 3)
            if len(parts) < 3:
                continue
            pid, cpu, mem = parts[0], parts[1], parts[2]
            cmd_full = parts[3] if len(parts) >= 4 else ""
            cwd = self._proc_cwd(pid)

            in_project = False
            try:
                if cwd:
                    resolved = Path(cwd).resolve()
                    in_project = (resolved == self.workdir_resolved)
                    if not in_project:
                        try:
                            resolved.relative_to(self.workdir_resolved)
                            in_project = True
                        except Exception:
                            in_project = False
            except Exception:
                in_project = False

            cmd_lower = cmd_full.lower()
            is_vasp = ("vasp" in cmd_lower) or ("mpi" in cmd_lower and "vasp" in cmd_lower)
            procs.append({
                "pid": pid, "cmd": cmd_full.strip(),
                "cpu": cpu, "mem": mem,
                "is_vasp": is_vasp, "cwd": cwd, "in_project": in_project,
            })
        return procs

    def _proc_cwd(self, pid: str) -> str | None:
        proc_path = Path("/proc") / str(pid) / "cwd"
        try:
            return os.readlink(proc_path)
        except Exception:
            return None

    def _run_status(self, procs: list[dict], files: list[dict]) -> tuple[str, list[str], list[str]]:
        run_pids: list[str] = []
        suggestions: list[str] = []
        for proc in procs:
            if proc.get("is_vasp") and proc.get("in_project"):
                run_pids.append(proc.get("pid", ""))
        run_state = "running" if run_pids else "idle"
        if run_pids:
            suggestions.append(
                f"检测到 {len(run_pids)} 个 VASP 相关进程在 {self.workdir} 运行。"
            )
        else:
            suggestions.append("未检测到项目内的 VASP 进程，可检查作业或尝试重新启动。")

        for item in files:
            short = Path(item.get("name", "")).name
            if not item.get("exists"):
                suggestions.append(f"未发现 {short}，请确认计算是否已开始输出。")
            else:
                delta = item.get("delta")
                if isinstance(delta, (int, float)) and delta <= 0 and run_pids:
                    suggestions.append(f"{short} 暂未增长，可稍后再次检查。")
        if len(suggestions) > 5:
            suggestions = suggestions[:5]
        return run_state, run_pids, suggestions

    @classmethod
    def snapshot(cls, workdir: Path, watch_files: list[str] | None) -> dict:
        monitor = cls(workdir, watch_files, on_update=None)
        return monitor._collect_stats()


class EnergyMonitor(threading.Thread):
    """后台线程：周期性解析 OSZICAR，提取 F/E0 能量，供主线程绘图。"""
    def __init__(self, workdir: Path, on_update):
        super().__init__(daemon=True)
        self.workdir = workdir
        self.on_update = on_update  # callback(steps:list[int], energies:list[float])
        self._stop_event = threading.Event()
        self.steps = []
        self.energies = []
        self._last_size = 0
        self._last_pos = 0

    def stop(self):
        self._stop_event.set()
        if self.is_alive():
            try:
                self.join(timeout=2.0)
            except RuntimeError:
                pass

    def run(self):
        osz = self.workdir / "OSZICAR"
        outcar = self.workdir / "OUTCAR"
        while not self._stop_event.is_set():
            try:
                target = None
                if osz.exists() and osz.stat().st_size > 0:
                    target = osz
                elif outcar.exists() and outcar.stat().st_size > 0:
                    target = outcar
                if target:
                    size = target.stat().st_size
                    reset = False
                    if size < self._last_size:
                        reset = True
                        self._last_pos = 0
                        self._last_size = 0
                        self.steps = [];
                        self.energies = []
                    if reset or size > self._last_size:
                        self._parse(target, reset)
                        self._last_size = size
                        if self.on_update:
                            self.on_update(self.steps, self.energies)
            except Exception:
                pass
            time.sleep(1.0)

    def _parse(self, path: Path, reset: bool):
        try:
            with path.open("r", encoding="utf-8", errors="ignore") as f:
                if not reset and self._last_pos:
                    f.seek(self._last_pos)
                else:
                    self.steps = []
                    self.energies = []
                new_pts = 0
                for line in f:
                    val = None
                    m = ENERGY_RX.search(line)
                    if m:
                        val = m.group(1) or m.group(2)
                    else:
                        # 若传入的是 OUTCAR，尝试 TOTEN 兜底
                        m2 = TOTEN_RX.search(line)
                        if m2:
                            val = m2.group(1)
                    if val is not None:
                        try:
                            # Fortran 指数 D 替换为 E
                            e = float(val.replace("D", "E").replace("d", "E"))
                            self.steps.append(len(self.steps) + 1)
                            self.energies.append(e)
                            new_pts += 1
                        except Exception:
                            pass
                self._last_pos = f.tell()
        except Exception:
            return


class VaspGUI(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title(f"{APP_NAME} v{APP_VER}")
        self.geometry("1200x800")
        try:
            import ttkbootstrap as tb  # 可选美化
            tb.Style("cosmo")
        except Exception:
            pass

        self.project_dir = Path.cwd()
        self.proc = None  # subprocess.Popen or None
        self.monitor = None  # EnergyMonitor
        self.sys_monitor = None  # SystemStatsMonitor
        self.run_status_var = tk.StringVar(value="⚪ 未检测")
        self.run_suggestion_widgets: list[tk.Text] = []
        self.overview_items = [
            ("__project__", "项目目录"),
            ("INCAR", "INCAR"),
            ("POSCAR", "POSCAR"),
            ("KPOINTS", "KPOINTS"),
            ("POTCAR", "POTCAR"),
            ("CONTCAR", "CONTCAR"),
            ("vasp.out", "vasp.out"),
            ("OSZICAR", "OSZICAR"),
            ("OUTCAR", "OUTCAR"),
        ]
        self.overview_label_map = {k: label for k, label in self.overview_items}
        self.overview_key_map = {k.lower(): k for k, _ in self.overview_items}

        self._build_ui()
        self.set_project(self.project_dir)

        # 加载历史配置（若存在）
        try:
            self.load_config()
        except Exception:
            pass

    # ------------------------- UI 构建 ----------------------------------
    def _build_ui(self):
        # 顶部工具栏
        toolbar = ttk.Frame(self)
        toolbar.pack(side=tk.TOP, fill=tk.X)

        ttk.Label(toolbar, text="项目目录:").pack(side=tk.LEFT, padx=6)
        self.project_var = tk.StringVar(value=str(self.project_dir))
        self.project_entry = ttk.Entry(toolbar, textvariable=self.project_var, width=80)
        self.project_entry.pack(side=tk.LEFT, padx=4)
        ttk.Button(toolbar, text="选择…", command=self.choose_project).pack(side=tk.LEFT)
        ttk.Button(toolbar, text="新建项目", command=self.create_project).pack(side=tk.LEFT, padx=4)
        ttk.Button(toolbar, text="一键读取项目", command=self.import_project_files).pack(side=tk.LEFT, padx=4)

        # Notebook
        self.nb = ttk.Notebook(self)
        self.nb.pack(fill=tk.BOTH, expand=True)

        self.page_inputs = self._build_inputs_page(self.nb)
        self.page_potcar = self._build_potcar_page(self.nb)
        self.page_kpoints = self._build_kpoints_page(self.nb)

        # 先把 workflow 会引用到的页面都建好
        self.page_run = self._build_run_page(self.nb)
        self.page_monitor = self._build_monitor_page(self.nb)
        self.page_post = self._build_post_page(self.nb)

        # 最后再建 workflow（里面会引用上面三个）
        self.page_workflow = self._build_workflow_page(self.nb)

        self.nb.add(self.page_inputs, text="输入文件")
        self.nb.add(self.page_potcar, text="POTCAR 赝势")
        self.nb.add(self.page_kpoints, text="K 点生成")
        self.nb.add(self.page_workflow, text="流程助手")
        self.nb.add(self.page_run, text="运行 / 提交")
        self.nb.add(self.page_monitor, text="监视")
        self.nb.add(self.page_post, text="后处理")

        self.protocol("WM_DELETE_WINDOW", self.on_close)

    # ------------------------- 页面：输入文件 -----------------------------
    def _build_inputs_page(self, parent):
        frame = ttk.Frame(parent)

        # 左边：INCAR 模板
        left = ttk.Frame(frame)
        left.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=8, pady=8)

        ttk.Label(left, text="INCAR 模板与编辑").pack(anchor=tk.W)
        temp_bar = ttk.Frame(left)
        temp_bar.pack(fill=tk.X, pady=4)
        self.incar_template = tk.StringVar(value="relax")
        for key, txt in [
            ("relax", "几何优化"),
            ("static", "静态自洽"),
            ("dos", "态密度"),
            ("bands", "能带预设"),
        ]:
            ttk.Radiobutton(temp_bar, text=txt, value=key, variable=self.incar_template, command=self.load_incar_template).pack(side=tk.LEFT)
        ttk.Button(temp_bar, text="加载模板到编辑器", command=self.load_incar_template).pack(side=tk.RIGHT)

        self.incar_text = tk.Text(left, height=20)
        self.incar_text.pack(fill=tk.BOTH, expand=True)
        btns = ttk.Frame(left)
        btns.pack(fill=tk.X, pady=4)
        ttk.Button(btns, text="打开现有 INCAR", command=lambda: self.open_into_editor("INCAR", self.incar_text)).pack(side=tk.LEFT)
        ttk.Button(btns, text="保存到项目", command=lambda: self.save_from_editor("INCAR", self.incar_text)).pack(side=tk.LEFT, padx=6)

        # 右边：POSCAR & KPOINTS 编辑
        right = ttk.Frame(frame)
        right.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=8, pady=8)

        ttk.Label(right, text="POSCAR 编辑").pack(anchor=tk.W)
        self.poscar_text = tk.Text(right, height=10)
        self.poscar_text.pack(fill=tk.BOTH, expand=True)
        row = ttk.Frame(right)
        row.pack(fill=tk.X, pady=4)
        ttk.Button(row, text="打开 POSCAR", command=lambda: self.open_into_editor("POSCAR", self.poscar_text)).pack(side=tk.LEFT)
        ttk.Button(row, text="保存 POSCAR", command=lambda: self.save_from_editor("POSCAR", self.poscar_text)).pack(side=tk.LEFT, padx=6)
        ttk.Button(row, text="从 POSCAR 解析元素", command=self.show_poscar_elements).pack(side=tk.LEFT, padx=6)

        ttk.Separator(right, orient=tk.HORIZONTAL).pack(fill=tk.X, pady=6)

        ttk.Label(right, text="KPOINTS 编辑（可在K 点生成页自动生成）").pack(anchor=tk.W)
        self.kpoints_text = tk.Text(right, height=10)
        self.kpoints_text.pack(fill=tk.BOTH, expand=True)
        row2 = ttk.Frame(right)
        row2.pack(fill=tk.X, pady=4)
        ttk.Button(row2, text="打开 KPOINTS", command=lambda: self.open_into_editor("KPOINTS", self.kpoints_text)).pack(side=tk.LEFT)
        ttk.Button(row2, text="保存 KPOINTS", command=lambda: self.save_from_editor("KPOINTS", self.kpoints_text)).pack(side=tk.LEFT, padx=6)

        # 默认加载模板
        self.load_incar_template()
        return frame

    def load_incar_template(self):
        tpl = self.incar_template.get()
        presets = {
            "relax": (
                """# ==== 几何优化（PBE）====\nSYSTEM = relax\nENCUT = 520\nPREC  = Accurate\nEDIFF = 1e-6\nEDIFFG = -0.02\nISMEAR = 0\nSIGMA  = 0.05\nIBRION = 2\nISIF   = 3\nNSW    = 100\nISPIN  = 1\nLREAL  = Auto\n# 可选：KSPACING = 0.22\n"""
            ),
            "static": (
                """# ==== 静态自洽（SCF）====\nSYSTEM = scf\nENCUT = 520\nPREC  = Accurate\nEDIFF = 1e-6\nISMEAR = 0\nSIGMA  = 0.05\nIBRION = -1\nNSW    = 0\nLREAL  = Auto\nLWAVE  = .FALSE.\nLCHARG = .TRUE.\n# 可选：KSPACING = 0.22\n"""
            ),
            "dos": (
                """# ==== DOS 计算（在已收敛电荷上）====\nSYSTEM = dos\nENCUT = 520\nPREC  = Accurate\nEDIFF = 1e-6\nISMEAR = 0\nSIGMA  = 0.05\nIBRION = -1\nNSW    = 0\nLORBIT = 11\nNEDOS  = 2000\nLCHARG = .TRUE.\nLWAVE  = .FALSE.\n# 可选：KSPACING = 0.18\n"""
            ),
            "bands": (
                """# ==== 能带预设（非自洽）====\nSYSTEM = bands\nENCUT = 520\nPREC  = Accurate\nEDIFF = 1e-6\nISMEAR = 0\nSIGMA  = 0.05\nIBRION = -1\nNSW    = 0\nICHARG = 11\nLORBIT = 11\nLCHARG = .FALSE.\nLWAVE  = .TRUE.\n# KPOINTS 请使用路径方式或外部生成器\n"""
            ),
        }
        self.incar_text.delete("1.0", tk.END)
        self.incar_text.insert("1.0", presets.get(tpl, presets["relax"]))

    def open_into_editor(self, name: str, editor: tk.Text):
        p = filedialog.askopenfilename(initialdir=self.project_dir, title=f"打开 {name}", filetypes=[(name, name), ("全部", "*")])
        if not p:
            return
        try:
            s = read_text(Path(p))
            editor.delete("1.0", tk.END)
            editor.insert("1.0", s)
        except Exception as e:
            messagebox.showerror(APP_NAME, f"读取失败：{e}")

    def save_from_editor(self, name: str, editor: tk.Text):
        proj = self.current_project_path()
        proj.mkdir(parents=True, exist_ok=True)
        p = proj / name
        try:
            write_text(p, editor.get("1.0", tk.END))
            messagebox.showinfo(APP_NAME, f"已保存 {name} -> {p}")
            self.refresh_project_overview()
        except Exception as e:
            messagebox.showerror(APP_NAME, f"保存失败：{e}")

    def show_poscar_elements(self):
        s = self.poscar_text.get("1.0", tk.END)
        elems = unique_elements_from_poscar(s)
        if elems:
            messagebox.showinfo(APP_NAME, f"POSCAR 元素：{', '.join(elems)}")
        else:
            messagebox.showwarning(APP_NAME, "未解析到元素，请检查第6/7行。")

    # ------------------------- 页面：POTCAR --------------------------------
    def _build_potcar_page(self, parent):
        frame = ttk.Frame(parent)

        row1 = ttk.Frame(frame)
        row1.pack(fill=tk.X, padx=8, pady=8)
        ttk.Label(row1, text="赝势库根目录：").pack(side=tk.LEFT)
        self.pot_dir_var = tk.StringVar(value=str(Path.home() / "potcars"))
        ttk.Entry(row1, textvariable=self.pot_dir_var, width=80).pack(side=tk.LEFT, padx=6)
        ttk.Button(row1, text="选择…", command=self.choose_pot_dir).pack(side=tk.LEFT)
        ttk.Button(row1, text="探测赝势库", command=self.detect_pot_roots).pack(side=tk.LEFT, padx=6)

        row2 = ttk.Frame(frame)
        row2.pack(fill=tk.X, padx=8, pady=4)
        ttk.Label(row2, text="从 POSCAR 自动解析元素并生成 POTCAR：").pack(side=tk.LEFT)
        ttk.Button(row2, text="生成 POTCAR", command=self.do_build_potcar).pack(side=tk.LEFT, padx=8)

        self.pot_msg = tk.Text(frame, height=18)
        self.pot_msg.pack(fill=tk.BOTH, expand=True, padx=8, pady=8)

        return frame

    def choose_pot_dir(self):
        d = filedialog.askdirectory(initialdir=self.pot_dir_var.get(), title="选择赝势库根目录")
        if d:
            self.pot_dir_var.set(d)

    def do_build_potcar(self):
        proj = self.current_project_path()
        pos = proj / "POSCAR"
        if not pos.exists():
            # 尝试从编辑器
            s = self.poscar_text.get("1.0", tk.END).strip()
            if s:
                write_text(pos, s)
            else:
                messagebox.showwarning(APP_NAME, "项目目录中不存在 POSCAR，且编辑器为空。")
                return
        elems, _ = parse_poscar(read_text(pos))
        if not elems:
            messagebox.showwarning(APP_NAME, "未从 POSCAR 解析到元素。")
            return
        pot_base = Path(self.pot_dir_var.get())
        selections: list[Path] = []
        for e in elems:
            cands = find_potcar_candidates(e, pot_base)
            if not cands:
                msg = f"未找到元素 {e} 的 POTCAR（在 {pot_base} 下）。"
                self.pot_msg.insert(tk.END, msg + "\n")
                messagebox.showerror(APP_NAME, msg)
                return
            if len(cands) == 1:
                selected = cands[0]
            else:
                options = [str(p) for p in cands]
                sel = self.select_from_list(f"选择 {e} 的 POTCAR", options)
                if not sel:
                    cancel_msg = f"已取消 {e} 的 POTCAR 选择，终止生成。"
                    self.pot_msg.insert(tk.END, cancel_msg + "\n")
                    messagebox.showinfo(APP_NAME, cancel_msg)
                    return
                selected = Path(sel)
            selections.append(selected)
            self.pot_msg.insert(tk.END, f"{e}: 使用 {selected}\n")
            self.pot_msg.see(tk.END)
        ok, msg = build_potcar(selections, proj / "POTCAR")
        self.pot_msg.insert(tk.END, (msg + "\n"))
        self.pot_msg.see(tk.END)
        if not ok:
            messagebox.showerror(APP_NAME, msg)
        else:
            messagebox.showinfo(APP_NAME, msg)
            self.refresh_project_overview()

    # --------- 赝势库探测与选择 ---------
    def detect_pot_roots(self):
        cands = self.scan_pot_roots(limit=30)
        if not cands:
            messagebox.showwarning(APP_NAME, "未在常见位置发现赝势库候选。你也可以手动选择根目录。")
            return
        if len(cands) == 1:
            self.pot_dir_var.set(cands[0])
            messagebox.showinfo(APP_NAME, f"已设置赝势库根目录：\n{cands[0]}")
            return
        sel = self.select_from_list("选择赝势库根目录", cands)
        if sel:
            self.pot_dir_var.set(sel)

    def select_from_list(self, title, items):
        top = tk.Toplevel(self)
        top.title(title)
        top.geometry("720x380")
        lb = tk.Listbox(top, selectmode=tk.SINGLE)
        for it in items:
            lb.insert(tk.END, it)
        lb.pack(fill=tk.BOTH, expand=True, padx=8, pady=8)
        sel = {"val": None}
        def ok():
            try:
                i = lb.curselection()
                sel["val"] = items[i[0]] if i else None
            except Exception:
                sel["val"] = None
            top.destroy()
        ttk.Button(top, text="使用选中", command=ok).pack(pady=6)
        top.transient(self); top.grab_set(); self.wait_window(top)
        return sel["val"]

    def scan_pot_roots(self, limit=20):
        bases = []
        # 当前设置与常见路径为起点
        try:
            bases.append(Path(self.pot_dir_var.get()).expanduser())
        except Exception:
            pass
        for p in [Path.home()/"potcars", Path.home()/"vasp", Path.home()/"apps", Path.home()/"Downloads", Path.home()/"下载", Path("/opt/vasp"), Path("/usr/local/share/vasp"), Path("/mnt/c/Users")]:
            if p.exists():
                bases.append(p)
        seen = set(); cands = []
        def looks_like_root(d: Path):
            try:
                cnt = 0
                for child in d.iterdir():
                    if child.is_dir() and (child/"POTCAR").exists():
                        cnt += 1
                        if cnt >= 3:
                            return True
                return False
            except Exception:
                return False
        # BFS 限深 3
        from collections import deque
        for base in list(dict.fromkeys(bases)):
            if not base.exists():
                continue
            q = deque([(base, 0)])
            while q and len(cands) < limit:
                cur, dep = q.popleft()
                try:
                    key = str(cur.resolve())
                except Exception:
                    key = str(cur)
                if key in seen:
                    continue
                seen.add(key)
                if looks_like_root(cur):
                    cands.append(key)
                if dep < 3:
                    try:
                        for ch in cur.iterdir():
                            if ch.is_dir():
                                q.append((ch, dep+1))
                    except Exception:
                        pass
        # 去重与排序（包含关键词的优先）
        def score(path):
            name = path.lower(); s = 0
            for kw in ("potpaw","paw","pbe","lda","potential","psp"):
                if kw in name:
                    s += 1
            return (-s, len(path))
        cands = sorted(list(dict.fromkeys(cands)), key=score)
        return cands[:limit]

    # ------------------------- 页面：KPOINTS -------------------------------
    def _build_kpoints_page(self, parent):
        frame = ttk.Frame(parent)
        box = ttk.LabelFrame(frame, text="Monkhorst-Pack 网格")
        box.pack(fill=tk.X, padx=8, pady=8)

        self.k_nx = tk.IntVar(value=5)
        self.k_ny = tk.IntVar(value=5)
        self.k_nz = tk.IntVar(value=5)
        self.k_gamma = tk.BooleanVar(value=True)

        row = ttk.Frame(box)
        row.pack(fill=tk.X, pady=4)
        ttk.Label(row, text="Nx").pack(side=tk.LEFT)
        ttk.Spinbox(row, from_=1, to=50, textvariable=self.k_nx, width=5).pack(side=tk.LEFT, padx=6)
        ttk.Label(row, text="Ny").pack(side=tk.LEFT)
        ttk.Spinbox(row, from_=1, to=50, textvariable=self.k_ny, width=5).pack(side=tk.LEFT, padx=6)
        ttk.Label(row, text="Nz").pack(side=tk.LEFT)
        ttk.Spinbox(row, from_=1, to=50, textvariable=self.k_nz, width=5).pack(side=tk.LEFT, padx=6)
        ttk.Checkbutton(box, text="Gamma 中心", variable=self.k_gamma).pack(anchor=tk.W, padx=8)

        btns = ttk.Frame(frame)
        btns.pack(fill=tk.X, padx=8, pady=4)
        ttk.Button(btns, text="生成到编辑器", command=self.kpoints_to_editor).pack(side=tk.LEFT)
        ttk.Button(btns, text="保存到项目(KPOINTS)", command=self.kpoints_save).pack(side=tk.LEFT, padx=8)

        tip = ttk.Label(frame, text="提示：也可在 INCAR 使用 KSPACING，省去 KPOINTS（VASP 5.4.4+）")
        tip.pack(anchor=tk.W, padx=12, pady=4)

        return frame

    # ------------------------- 页面：流程助手 ------------------------------
    def _build_workflow_page(self, parent):
        frame = ttk.Frame(parent)

        intro = ttk.Label(
            frame,
            text="按照从上到下的步骤完成一次 VASP 计算，可点击按钮快速跳转到对应面板。",
            wraplength=900,
            justify=tk.LEFT,
        )
        intro.pack(fill=tk.X, padx=12, pady=8)

        status_box = ttk.LabelFrame(frame, text="当前项目状态")
        status_box.pack(fill=tk.BOTH, expand=False, padx=12, pady=6)

        status_row = ttk.Frame(status_box)
        status_row.pack(fill=tk.X, padx=8, pady=6)
        ttk.Label(status_row, text="运行状态：").pack(side=tk.LEFT)
        ttk.Label(status_row, textvariable=self.run_status_var).pack(side=tk.LEFT, padx=4)
        ttk.Button(status_row, text="刷新状态", command=self.refresh_run_status).pack(side=tk.RIGHT)

        tree_frame = ttk.Frame(status_box)
        tree_frame.pack(fill=tk.BOTH, expand=True, padx=8, pady=(0, 6))
        columns = ("name", "status", "detail")
        self.workflow_tree = ttk.Treeview(tree_frame, columns=columns, show="headings", height=6)
        self.workflow_tree.heading("name", text="项目项")
        self.workflow_tree.heading("status", text="状态")
        self.workflow_tree.heading("detail", text="详情")
        self.workflow_tree.column("name", width=120, anchor=tk.W)
        self.workflow_tree.column("status", width=120, anchor=tk.W)
        self.workflow_tree.column("detail", anchor=tk.W, stretch=True)
        tree_scroll = ttk.Scrollbar(tree_frame, orient=tk.VERTICAL, command=self.workflow_tree.yview)
        self.workflow_tree.configure(yscrollcommand=tree_scroll.set)
        self.workflow_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        tree_scroll.pack(side=tk.RIGHT, fill=tk.Y)

        sugg = ttk.Frame(status_box)
        sugg.pack(fill=tk.BOTH, expand=False, padx=8, pady=(0, 6))
        ttk.Label(sugg, text="运行建议：").pack(anchor=tk.W)
        wf_suggest = tk.Text(sugg, height=4, wrap="word", state="disabled")
        wf_suggest.pack(fill=tk.X, expand=True)
        self._register_suggestion_widget(wf_suggest)

        steps = [
            (
                "① 准备项目目录",
                "选择/新建项目文件夹，所有输入输出文件都保存在此处。",
                [
                    ("选择项目", self.choose_project),
                    ("新建项目", self.create_project),
                    ("快速体检", self.quick_check),
                ],
                self.page_inputs,
            ),
            (
                "② 编辑输入文件",
                "填写 INCAR、POSCAR、KPOINTS 等输入，确保必要信息完整。",
                [
                    ("跳转到输入页", lambda: self.goto_tab(self.page_inputs)),
                    ("跳转到 K 点生成", lambda: self.goto_tab(self.page_kpoints)),
                ],
                self.page_inputs,
            ),
            (
                "③ 准备 POTCAR",
                "解析 POSCAR 元素并在 POTCAR 面板一键拼接所需赝势。",
                [
                    ("跳转到 POTCAR", lambda: self.goto_tab(self.page_potcar)),
                    ("解析元素", self.show_poscar_elements),
                ],
                self.page_potcar,
            ),
            (
                "④ 配置运行方式",
                "根据实际环境选择本地/WSL/SLURM 运行，并生成脚本。",
                [
                    ("跳转到运行页", lambda: self.goto_tab(self.page_run)),
                    ("生成运行脚本", self.write_job_script),
                ],
                self.page_run,
            ),
            (
                "⑤ 启动并监视",
                "启动计算后，利用监视页关注能量收敛、CPU 使用率及文件增长。",
                [
                    ("启动/提交", self.start_run),
                    ("跳转到监视", lambda: self.goto_tab(self.page_monitor)),
                    ("开始监视", self.start_monitor),
                ],
                self.page_monitor,
            ),
            (
                "⑥ 后处理与结果",
                "提取最终能量或绘制一次性曲线，整理输出文件。",
                [
                    ("跳转到后处理", lambda: self.goto_tab(self.page_post)),
                    ("提取最终能量", self.extract_final_energy),
                ],
                self.page_post,
            ),
        ]

        steps_frame = ttk.Frame(frame)
        steps_frame.pack(fill=tk.BOTH, expand=True, padx=12, pady=6)
        steps_frame.grid_columnconfigure(0, weight=1)
        steps_frame.grid_columnconfigure(1, weight=1)
        for idx, (title, desc, buttons, page) in enumerate(steps):
            row, col = divmod(idx, 2)
            box = ttk.LabelFrame(steps_frame, text=title)
            box.grid(row=row, column=col, sticky="nsew", padx=6, pady=6)
            ttk.Label(box, text=desc, justify=tk.LEFT, wraplength=360).pack(anchor=tk.W, padx=8, pady=4)
            row_frame = ttk.Frame(box)
            row_frame.pack(anchor=tk.W, padx=8, pady=4)
            for txt, cmd in buttons:
                ttk.Button(row_frame, text=txt, command=cmd).pack(side=tk.LEFT, padx=4)
            ttk.Button(row_frame, text="打开此面板", command=lambda p=page: self.goto_tab(p)).pack(side=tk.LEFT, padx=8)

        notes = ttk.LabelFrame(frame, text="流程备注 / 待办")
        notes.pack(fill=tk.BOTH, expand=True, padx=12, pady=8)
        self.workflow_notes = tk.Text(notes, height=8)
        self.workflow_notes.pack(fill=tk.BOTH, expand=True, padx=6, pady=6)
        self.workflow_notes.insert(
            tk.END,
            "可在此记录当前任务的特殊参数、检查列表或备注。内容不会自动保存。",
        )
        return frame

    def kpoints_to_editor(self):
        s = gen_kpoints_monkhorst(self.k_nx.get(), self.k_ny.get(), self.k_nz.get(), self.k_gamma.get())
        self.kpoints_text.delete("1.0", tk.END)
        self.kpoints_text.insert("1.0", s)

    def kpoints_save(self):
        proj = self.current_project_path()
        proj.mkdir(parents=True, exist_ok=True)
        s = self.kpoints_text.get("1.0", tk.END)
        write_text(proj / "KPOINTS", s)
        messagebox.showinfo(APP_NAME, f"KPOINTS 已保存到 {proj/'KPOINTS'}")
        self.refresh_project_overview()

    def goto_tab(self, page):
        try:
            self.nb.select(page)
        except Exception:
            pass


    def append_run_log(self, msg: str):
        text = (msg or "")
        lines = text.splitlines() or [""]
        for line in lines:
            self.run_log.insert(tk.END, line.rstrip("\n") + "\n")
        self.run_log.see(tk.END)

    # ====== 非阻塞跟随 vasp.out 到 GUI ======
    def _start_following_log(self, log_path: Path, interval_ms: int = 500):
        """非阻塞跟随 log_path，将新增内容追加到 self.run_log。"""
        self._log_path = Path(log_path)
        self._tail_pos = 0
        self._tail_interval = int(interval_ms)
        # 若之前有定时任务，先取消
        if hasattr(self, "_tail_job") and self._tail_job:
            try:
                self.after_cancel(self._tail_job)
            except Exception:
                pass
        # 立即触发一次
        self._follow_log_tick()

    def _follow_log_tick(self):
        chunk = ""
        try:
            with open(self._log_path, "r", encoding="utf-8", errors="ignore") as f:
                f.seek(getattr(self, "_tail_pos", 0))
                chunk = f.read(64 * 1024)  # 每 tick 最多 64KB
                self._tail_pos = f.tell()
        except FileNotFoundError:
            pass
        except Exception as e:
            chunk = f"[log-follow] 读取失败：{e}\n"
        if chunk:
            self.append_run_log(chunk)
        self._tail_job = self.after(getattr(self, "_tail_interval", 500), self._follow_log_tick)

    def _stop_following_log(self):
        if hasattr(self, "_tail_job") and self._tail_job:
            try:
                self.after_cancel(self._tail_job)
            except Exception:
                pass
            self._tail_job = None

    def _int_from_var(self, var, default=0) -> int:
        try:
            value = var.get()
        except Exception:
            value = default
        try:
            return int(value)
        except Exception:
            try:
                return int(default)
            except Exception:
                return 0

    # ------------------------- 页面：运行 / 提交 ----------------------------
    def _build_run_page(self, parent):
        frame = ttk.Frame(parent)

        status = ttk.LabelFrame(frame, text="运行状态")
        status.pack(fill=tk.X, padx=8, pady=6)
        row = ttk.Frame(status)
        row.pack(fill=tk.X, padx=6, pady=4)
        ttk.Label(row, text="当前状态：").pack(side=tk.LEFT)
        ttk.Label(row, textvariable=self.run_status_var).pack(side=tk.LEFT, padx=4)
        ttk.Button(row, text="刷新状态", command=self.refresh_run_status).pack(side=tk.RIGHT)
        run_suggest = tk.Text(status, height=3, wrap="word", state="disabled")
        run_suggest.pack(fill=tk.X, padx=6, pady=(0, 6))
        self._register_suggestion_widget(run_suggest)

        # 运行方式
        row0 = ttk.LabelFrame(frame, text="运行方式")
        row0.pack(fill=tk.X, padx=8, pady=8)
        self.run_mode = tk.StringVar(value="local")
        ttk.Radiobutton(row0, text="本地 mpirun", value="local", variable=self.run_mode).pack(side=tk.LEFT, padx=8)
        ttk.Radiobutton(row0, text="WSL2 (Windows)", value="wsl", variable=self.run_mode).pack(side=tk.LEFT, padx=8)
        ttk.Radiobutton(row0, text="SLURM 集群", value="slurm", variable=self.run_mode).pack(side=tk.LEFT)

        # VASP 执行文件 & 核心数
        row1 = ttk.LabelFrame(frame, text="VASP 执行配置")
        row1.pack(fill=tk.X, padx=8, pady=4)
        ttk.Label(row1, text="VASP 命令").grid(row=0, column=0, sticky=tk.W, padx=6, pady=4)
        self.vasp_cmd = tk.StringVar(value="vasp_std")
        ttk.Entry(row1, textvariable=self.vasp_cmd, width=30).grid(row=0, column=1, sticky=tk.W)
        ttk.Button(row1, text="which?", command=self.which_vasp).grid(row=0, column=2, padx=6)

        ttk.Label(row1, text="MPI 进程数 -np").grid(row=1, column=0, sticky=tk.W, padx=6, pady=4)
        self.mpi_np = tk.IntVar(value=8)
        # 新增：自动并行
        self.auto_parallel = tk.BooleanVar(value=True)
        ttk.Checkbutton(row1, text="自动并行（智能设置 KPAR/NCORE）",
                        variable=self.auto_parallel).grid(row=2, column=0, columnspan=3, sticky=tk.W, padx=6)
        ttk.Spinbox(row1, from_=1, to=2048, textvariable=self.mpi_np, width=8).grid(row=1, column=1, sticky=tk.W)

        # SLURM 区域
        row2 = ttk.LabelFrame(frame, text="SLURM 提交（仅在选择 SLURM 运行时使用）")
        row2.pack(fill=tk.X, padx=8, pady=4)
        self.slurm_part = tk.StringVar(value="normal")
        self.slurm_time = tk.StringVar(value="02:00:00")
        self.slurm_nodes = tk.IntVar(value=1)
        self.slurm_ntasks = tk.IntVar(value=32)
        self.slurm_account = tk.StringVar(value="")
        ttk.Label(row2, text="分区").grid(row=0, column=0, sticky=tk.W, padx=6, pady=4)
        ttk.Entry(row2, textvariable=self.slurm_part, width=12).grid(row=0, column=1)
        ttk.Label(row2, text="时长").grid(row=0, column=2, sticky=tk.W, padx=6)
        ttk.Entry(row2, textvariable=self.slurm_time, width=12).grid(row=0, column=3)
        ttk.Label(row2, text="节点").grid(row=0, column=4, sticky=tk.W, padx=6)
        ttk.Spinbox(row2, from_=1, to=128, textvariable=self.slurm_nodes, width=6).grid(row=0, column=5)
        ttk.Label(row2, text="ntasks").grid(row=0, column=6, sticky=tk.W, padx=6)
        ttk.Spinbox(row2, from_=1, to=8192, textvariable=self.slurm_ntasks, width=8).grid(row=0, column=7)
        ttk.Label(row2, text="账号").grid(row=0, column=8, sticky=tk.W, padx=6)
        ttk.Entry(row2, textvariable=self.slurm_account, width=12).grid(row=0, column=9)

        btns = ttk.Frame(frame)
        btns.pack(fill=tk.X, padx=8, pady=8)
        ttk.Button(btns, text="生成运行脚本", command=self.write_job_script).pack(side=tk.LEFT)
        ttk.Button(btns, text="启动/提交", command=self.start_run).pack(side=tk.LEFT, padx=8)
        ttk.Button(btns, text="停止本地进程", command=self.stop_local).pack(side=tk.LEFT)

        self.run_log = tk.Text(frame, height=14)
        self.run_log.pack(fill=tk.BOTH, expand=True, padx=8, pady=8)

        return frame

    @staticmethod
    def is_windows() -> bool:
        return os.name == "nt" or sys.platform.startswith("win")

    def win_to_wsl_path(self, p: Path) -> str:
        # 将 Windows 路径 C:\foo\bar 转为 /mnt/c/foo/bar
        s = str(p)
        if len(s) >= 2 and s[1] == ":":
            drive = s[0].lower()
            rest = s[2:].replace("\\", "/")
            return f"/mnt/{drive}{rest if rest.startswith('/') else '/' + rest}"
        return s.replace("\\", "/")

    def which_vasp(self):
        cmd = self.vasp_cmd.get().strip()
        path = which(cmd)
        if path:
            messagebox.showinfo(APP_NAME, f"{cmd} -> {path}")
        else:
            messagebox.showwarning(APP_NAME, f"未在 PATH 中找到 {cmd}")

    def write_job_script(self):
        """生成 run_local.sh / run_slurm.sh（含自动并行设置与稳健环境）。"""
        proj = self.current_project_path()
        proj.mkdir(parents=True, exist_ok=True)

        # —— 可选额外库（只拼接存在的路径，不会写坏环境）——
        extra_libs = []
        for pth in ["/home/yu/apps/aocl/4.1.0/aocc/lib",
                    "/home/yu/apps/aocc-compiler-4.1.0/lib"]:
            try:
                if Path(pth).exists():
                    extra_libs.append(pth)
            except Exception:
                pass
        extra_ld = ":".join(extra_libs)

        ld_line = (f'export LD_LIBRARY_PATH="{extra_ld}:${{LD_LIBRARY_PATH}}"\n'
                   if extra_ld else 'export LD_LIBRARY_PATH="${LD_LIBRARY_PATH:-}"\n')

        env_lines = (
            "# --- Runtime environment (auto generated) ---\n"
            ': "${LD_LIBRARY_PATH:=}"\n'
            f"{ld_line}"
            'export OMP_NUM_THREADS="${OMP_NUM_THREADS:-1}"\n'
            'export OMP_PROC_BIND="${OMP_PROC_BIND:-true}"\n'
            'export OMP_PLACES="${OMP_PLACES:-cores}"\n'
        )

        vcmd = (self.vasp_cmd.get().strip() if hasattr(self, "vasp_cmd") else "") or "vasp_std"
        mpirun_path = which("mpirun") or "mpirun"
        try:
            np = int(self.mpi_np.get()) if hasattr(self, "mpi_np") else 8
        except Exception:
            np = 8

        # —— 自动并行：写回 KPAR/NCORE（若提供了开关或未提供也尝试）——
        try:
            if hasattr(self, "auto_parallel"):
                if self.auto_parallel.get():
                    self._autotune_parallel_and_write(np)
            else:
                # 没有勾选框也尽量自动一次，不报错即可
                if hasattr(self, "_autotune_parallel_and_write"):
                    self._autotune_parallel_and_write(np)
        except Exception as e:
            self.append_run_log(f"[auto-parallel] 失败：{e}")

        # ===== 本地 run_local.sh =====
        local_script = f"""#!/bin/bash
    set -euo pipefail

    {env_lines}
    cd "{proj}"

    echo "[INFO] Workdir: $(pwd)"
    echo "[INFO] Using mpirun: {mpirun_path}"
    echo "[INFO] VASP cmd    : {vcmd}"
    echo "[INFO] NP          : {np}"
    echo "[INFO] LD_LIBRARY_PATH=$LD_LIBRARY_PATH"
    echo "[INFO] OMP_NUM_THREADS=$OMP_NUM_THREADS"

    # 降低调度与 I/O 优先级；并把 MPI 绑定到 core，降低任务迁移开销
    # 动态选择绑定策略：超过物理核数就用硬件线程
PHYS_CORES=$(lscpu -p=CORE 2>/dev/null | egrep -v '^#' | cut -d, -f2 | sort -u | wc -l | tr -d ' ')
if [ -n "$PHYS_CORES" ] && [ "$PHYS_CORES" -gt 0 ] && [ "{np}" -gt "$PHYS_CORES" ]; then
  BIND="--use-hwthread-cpus --bind-to hwthread --map-by ppr:1:hwthread"
else
  BIND="--bind-to core --map-by ppr:1:core"
fi

nice -n 5 ionice -c2 -n4 \
{mpirun_path} $BIND -np {np} {vcmd} > vasp.out 2>&1

    """

        # ===== SLURM run_slurm.sh =====
        slurm_part = self.slurm_part.get().strip() if hasattr(self, "slurm_part") else "normal"
        slurm_time = self.slurm_time.get().strip() if hasattr(self, "slurm_time") else "02:00:00"
        try:
            slurm_nodes = int(self.slurm_nodes.get()) if hasattr(self, "slurm_nodes") else 1
        except Exception:
            slurm_nodes = 1
        try:
            slurm_ntasks = int(self.slurm_ntasks.get()) if hasattr(self, "slurm_ntasks") else max(np, 1)
        except Exception:
            slurm_ntasks = max(np, 1)
        slurm_account = (self.slurm_account.get().strip() if hasattr(self, "slurm_account") else "")
        acc_line = f"#SBATCH --account={slurm_account}\n" if slurm_account else ""

        slurm_script = f"""#!/bin/bash
    #SBATCH --job-name=vasp
    #SBATCH --partition={slurm_part}
    #SBATCH --time={slurm_time}
    #SBATCH --nodes={slurm_nodes}
    #SBATCH --ntasks={slurm_ntasks}
    {acc_line}set -euo pipefail

    {env_lines}
    cd "{proj}"

    echo "SLURM_JOB_ID=$SLURM_JOB_ID"
    echo "[INFO] Workdir: $(pwd)"
    echo "[INFO] VASP cmd: {vcmd}"
    echo "[INFO] ntasks  : $SLURM_NTASKS"
    echo "[INFO] LD_LIBRARY_PATH=$LD_LIBRARY_PATH"
    echo "[INFO] OMP_NUM_THREADS=$OMP_NUM_THREADS"

    # 绑定到物理核，避免过度超线程导致的抖动
    srun --cpu-bind=cores {vcmd} > vasp.out 2>&1
    """

        # —— 写文件并授权 ——
        try:
            write_text(proj / "run_local.sh", local_script)
            os.chmod(proj / "run_local.sh", 0o755)
            self.append_run_log(f"已生成 {proj / 'run_local.sh'}")
        except Exception as e:
            self.append_run_log(f"[EXC] 写 run_local.sh 失败：{e}")

        try:
            write_text(proj / "run_slurm.sh", slurm_script)
            os.chmod(proj / "run_slurm.sh", 0o755)
            self.append_run_log(f"已生成 {proj / 'run_slurm.sh'}")
        except Exception as e:
            self.append_run_log(f"[EXC] 写 run_slurm.sh 失败：{e}")

        # 刷新界面状态
        self.refresh_project_overview()

    def start_run(self):
        proj = self.current_project_path()
        mode = self.run_mode.get()
        vcmd = self.vasp_cmd.get().strip()

        if not proj.exists():
            messagebox.showerror(APP_NAME, f"项目目录不存在：{proj}")
            return

        # 关键输入文件缺失时提示，但允许继续
        missing = [f for f in ["INCAR", "POSCAR", "POTCAR"] if not (proj / f).exists()]
        if missing:
            if not messagebox.askyesno(
                    APP_NAME,
                    "检测到以下关键输入文件缺失：\n"
                    + "\n".join(missing)
                    + "\n仍要继续启动吗？",
            ):
                return

        if mode == "local":
            # 防止重复起
            if self.proc and self.proc.poll() is None:
                messagebox.showwarning(APP_NAME, "已有本地 VASP 进程在运行。先停止或等待结束。")
                return

            # 基础可用性检查
            if not which("mpirun"):
                messagebox.showerror(APP_NAME, "未找到 mpirun。请安装 OpenMPI/IntelMPI 并加入 PATH。")
                return
            if not which(vcmd):
                messagebox.showerror(APP_NAME, f"未找到 VASP 命令：{vcmd}\n可改填绝对路径，例如 /opt/vasp/vasp_std")
                return

            # 总是重写一次脚本，确保环境最新
            self.write_job_script()
            # 替换 start_run() 内 local 分支里 “后台运行脚本” 那一段
            runsh = proj / "run_local.sh"
            try:
                # 使用 Popen 非阻塞启动脚本本身，而不是在主线程里 check_output
                self.proc = subprocess.Popen(
                    ["bash", "-lc", f"cd '{proj}' && exec './{runsh.name}'"],
                    stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL,
                    start_new_session=True  # 关键：新会话，便于后续整组终止
                )
                self.append_run_log(f"[run_local.sh pid] {self.proc.pid}")

                # 启动非阻塞日志跟随
                self._start_following_log(proj / "vasp.out")
                self.append_run_log("日志跟随 vasp.out（非阻塞）已启动。\n")

                # 改为 after 定时健康检查（避免 time.sleep 阻塞 Tk）
                def _health_check():
                    vout = proj / "vasp.out"
                    if not vout.exists() or vout.stat().st_size == 0:
                        # 再等 2 秒复查一次
                        self.after(2000, _health_check)
                        return
                    # 有输出就启动监视器
                    self.start_monitor()

                self.after(1500, _health_check)

            except Exception as e:
                self.append_run_log(f"[EXC] 启动失败：{e}")
                messagebox.showerror(APP_NAME, f"启动失败：{e}")
                return

        elif mode == "wsl":
            messagebox.showerror(APP_NAME, "WSL 分支未内置 AOCL/AOCC 环境设置，请使用本地或 SLURM。")
            return

        else:
            # SLURM：写脚本并 sbatch
            if not which("sbatch"):
                messagebox.showerror(APP_NAME, "未找到 sbatch。请在 SLURM 节点上运行或配置环境。")
                return
            self.write_job_script()
            script = proj / "run_slurm.sh"
            try:
                out = subprocess.check_output(["bash", "-lc", f"cd '{proj}' && sbatch '{script.name}'"], text=True)
                if out:
                    self.append_run_log(out)
                self.start_monitor()
            except subprocess.CalledProcessError as e:
                messagebox.showerror(APP_NAME, f"sbatch 失败：{e}{e.output}")

    def stop_local(self):
        try:
            if self.proc and self.proc.poll() is None:
                # 发送到整组（需要 start_new_session=True）
                os.killpg(os.getpgid(self.proc.pid), 15)  # SIGTERM
                time.sleep(0.5)
                if self.proc.poll() is None:
                    os.killpg(os.getpgid(self.proc.pid), 9)  # SIGKILL
                self.append_run_log("已停止本地 VASP 进程组。\n")
            else:
                # 兜底：旧行为
                subprocess.call(["bash", "-lc", f"pkill -f 'vasp' || true"])
                self.append_run_log("已尝试 pkill -f 'vasp'。\n")
            self.refresh_run_status()
        except Exception as e:
            messagebox.showerror(APP_NAME, f"停止失败：{e}")

    # ------------------------- 页面：监视 ----------------------------------
    def _build_monitor_page(self, parent):
        frame = ttk.Frame(parent)

        status_box = ttk.LabelFrame(frame, text="运行状态概览")
        status_box.pack(fill=tk.X, padx=8, pady=6)
        row = ttk.Frame(status_box)
        row.pack(fill=tk.X, padx=6, pady=4)
        ttk.Label(row, text="当前状态：").pack(side=tk.LEFT)
        ttk.Label(row, textvariable=self.run_status_var).pack(side=tk.LEFT, padx=4)
        ttk.Button(row, text="刷新状态", command=self.refresh_run_status).pack(side=tk.RIGHT)
        monitor_suggest = tk.Text(status_box, height=3, wrap="word", state="disabled")
        monitor_suggest.pack(fill=tk.X, padx=6, pady=(0, 6))
        self._register_suggestion_widget(monitor_suggest)

        top = ttk.Frame(frame)
        top.pack(fill=tk.X, padx=8, pady=6)
        ttk.Button(top, text="开始监视", command=self.start_monitor).pack(side=tk.LEFT)
        ttk.Button(top, text="停止监视", command=self.stop_monitor).pack(side=tk.LEFT, padx=6)
        ttk.Label(top, text="文件列表(逗号分隔)").pack(side=tk.LEFT, padx=6)
        self.file_watch_var = tk.StringVar(value="vasp.out,OSZICAR,OUTCAR")
        ttk.Entry(top, textvariable=self.file_watch_var, width=36).pack(side=tk.LEFT)

        fig = Figure(figsize=(6, 4), dpi=100)
        self.ax = fig.add_subplot(111)
        self.ax.set_xlabel("Step")
        self.ax.set_ylabel("Total energy (F or E0) [eV]")
        self.ax.grid(True, linestyle=":", linewidth=0.8)
        self.line, = self.ax.plot([], [], marker="o", linestyle="-")

        self.canvas = FigureCanvasTkAgg(fig, master=frame)
        self.canvas.draw()
        self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True, padx=8, pady=8)

        # ETA 显示
        eta_row = ttk.Frame(frame)
        eta_row.pack(fill=tk.X, padx=8, pady=(0, 4))
        ttk.Label(eta_row, text="预计剩余时间：").pack(side=tk.LEFT)
        self.eta_var = tk.StringVar(value="—")
        self.eta_label = ttk.Label(eta_row, textvariable=self.eta_var, foreground="#2b8a3e")
        self.eta_label.pack(side=tk.LEFT, padx=6)
        ttk.Label(eta_row, text="(基于最近 SCF 平均耗时与 OSZICAR 迭代统计)").pack(side=tk.LEFT, padx=6)

        self.mon_info = tk.Text(frame, height=6)
        self.mon_info.pack(fill=tk.BOTH, expand=False, padx=8, pady=4)

        sys_frame = ttk.LabelFrame(frame, text="系统状态：CPU / 进程 / 文件增长")
        sys_frame.pack(fill=tk.BOTH, expand=False, padx=8, pady=6)
        self.sys_info = tk.Text(sys_frame, height=10)
        self.sys_info.pack(fill=tk.BOTH, expand=True, padx=6, pady=6)

        self.sys_info.insert(tk.END, "点击“开始监视”以获取实时系统信息。\n")

        return frame

    def start_monitor(self):
        self.stop_monitor()
        proj = self.current_project_path()
        self.monitor = EnergyMonitor(proj, self.on_energy_update)
        self.monitor.start()
        self.mon_info.insert(tk.END, f"开始监视 {proj / 'OSZICAR'}\n")
        self.mon_info.see(tk.END)
        watch_files = [s.strip() for s in self.file_watch_var.get().split(",") if s.strip()]
        self.sys_monitor = SystemStatsMonitor(proj, watch_files, self.on_system_update)
        self.sys_monitor.start()
        self.sys_info.delete("1.0", tk.END)
        self.sys_info.insert(tk.END, "系统监视线程已启动……\n")
        self.apply_run_status("🟡 正在监视…", ["系统监视线程已启动，等待数据更新。"])

        # <<< 新增：初始化刷新一次 ETA >>>
        self._update_eta()

    def stop_monitor(self):
        if self.monitor:
            self.monitor.stop()
            self.monitor = None
        if self.sys_monitor:

            monitor = self.sys_monitor
            self.sys_monitor = None
            monitor.stop()
        self.mon_info.insert(tk.END, "已停止监视。\n")
        self.mon_info.see(tk.END)
        self.sys_info.insert(tk.END, "系统监视已停止。\n")
        self.refresh_run_status()
        self._stop_following_log()

    def on_energy_update(self, steps, energies):
        def _upd():
            # 初始化坐标轴标签只做一次
            if not hasattr(self, "_plot_inited"):
                self.ax.set_xlabel("Step")
                self.ax.set_ylabel("Total energy (F or E0) [eV]")
                self.ax.grid(True, linestyle=":", linewidth=0.8)
                self._plot_inited = True

            # ★ 不再 cla：直接更新 Line2D 数据
            self.line.set_data(steps or [], energies or [])
            self.ax.relim()
            self.ax.autoscale_view()

            self.canvas.draw_idle()
            # 保证布局立即刷新
            self.canvas.get_tk_widget().update_idletasks()

            if energies:
                self.mon_info.insert(tk.END, f"最新步：{steps[-1]}, 能量：{energies[-1]:.6f} eV\n")
                self.mon_info.see(tk.END)

            # 顺手刷新 ETA
            self._update_eta()

        self.after(0, _upd)

    def on_system_update(self, stats):
        def _upd():
            self._handle_stats(stats)
            lines = []
            run_state = stats.get("run_state")
            run_pids = stats.get("run_pids", [])
            if run_state == "running" and run_pids:
                lines.append(f"运行状态：运行中 (PID {', '.join(run_pids)})")
            elif run_state == "idle":
                lines.append("运行状态：未检测到 VASP 进程")
            else:
                lines.append("运行状态：未知")
            lines.append(f"时间：{stats.get('timestamp', '-')}")
            cpu = stats.get("cpu_usage")
            if cpu is not None:
                lines.append(f"CPU 使用率：{cpu:.1f}%")
            load = stats.get("loadavg")
            if load:
                lines.append(f"平均负载：{load[0]:.2f}, {load[1]:.2f}, {load[2]:.2f}")
            lines.append("监视文件：")
            for item in stats.get("files", []):
                name = item.get("name", "-")
                if item.get("exists"):
                    size = format_bytes(item.get("size"))
                    delta = format_bytes(item.get("delta"))
                    lines.append(f"  {name}: {size} (Δ {delta})")
                else:
                    lines.append(f"  {name}: 未找到")
            procs = stats.get("processes", [])
            if procs:
                lines.append("相关进程 (前5按CPU)：")
                for p in procs:
                    mark = "★" if p.get("is_vasp") else " "
                    lines.append(
                        f" {mark} PID {p.get('pid')} {p.get('cmd')} | CPU {p.get('cpu')} | MEM {p.get('mem')}"
                    )
            else:
                lines.append("未获取到进程信息 (可能无 ps 命令或权限不足)。")
            self.sys_info.delete("1.0", tk.END)
            self.sys_info.insert(tk.END, "\n".join(lines) + "\n")

            # <<< 新增：系统状态更新后也刷新 ETA（即便 OSZICAR 暂未增长，仍可用 vasp.out 的 LOOP） >>>
            self._update_eta()

        self.after(0, _upd)

    def _estimate_eta_text(self) -> str:
        """综合 OSZICAR/vasp.out/INCAR 估算 ETA。优先针对几何优化 (NSW>0)。"""
        proj = self.current_project_path()
        osz = proj / "OSZICAR"
        vout = proj / "vasp.out"
        incar = proj / "INCAR"

        # 解析步数配置
        NSW = _parse_incar_int(incar, "NSW", None)
        NELM = _parse_incar_int(incar, "NELM", 60)  # 若未给出，VASP 默认 60

        # 统计 OSZICAR：已完成离子步、平均每步迭代数
        steps_done, avg_iter = _oszicar_stats(osz)

        # 统计 vasp.out：最近单次 SCF 的平均耗时（中位数更稳）
        t_per_scf, seen_loops = _vaspout_loop_times(vout, take_last=40)

        # 默认兜底
        if avg_iter is None:
            avg_iter = 8.0  # 常见数量级 6~15 之间
        if t_per_scf is None:
            return "—"

        # 情况A：几何优化 (NSW>0)
        if NSW and NSW > 0:
            remain_steps = max(NSW - steps_done, 0)
            eta_sec = remain_steps * avg_iter * t_per_scf
            # 若刚开始，给个宽松区间
            if steps_done <= 1:
                eta_sec *= 1.3
            return _fmt_eta_seconds(eta_sec)

        # 情况B：静态或单步 (NSW<=0) → 用 NELM 估一个上界
        # 估计已完成迭代数 = vasp.out LOOP 行数（近似）
        done_iters = seen_loops
        remain_iters = max((NELM or 60) - done_iters, 0)
        eta_sec = remain_iters * t_per_scf
        return _fmt_eta_seconds(eta_sec)

    def _update_eta(self):
        try:
            self.eta_var.set(self._estimate_eta_text())
        except Exception:
            self.eta_var.set("—")

    # ------------------------- 页面：后处理 ---------------------------
    def _build_post_page(self, parent):
        frame = ttk.Frame(parent)
        row = ttk.Frame(frame)
        row.pack(fill=tk.X, padx=8, pady=8)
        ttk.Button(row, text="收敛曲线（OSZICAR）→ 图/CSV", command=self.export_convergence).pack(side=tk.LEFT)
        ttk.Button(row, text="总 DOS（DOSCAR）→ 图/CSV", command=self.export_dos_total).pack(side=tk.LEFT, padx=8)
        ttk.Button(row, text="能带（EIGENVAL）→ 图/CSV", command=self.export_bands).pack(side=tk.LEFT)
        self.post_log = tk.Text(frame, height=18)
        self.post_log.pack(fill=tk.BOTH, expand=True, padx=8, pady=8)
        return frame

    def plot_once_from_oszicar(self):
        proj = self.current_project_path()
        osz = proj / "OSZICAR"
        if not osz.exists():
            messagebox.showwarning(APP_NAME, f"{osz} 不存在。")
            return
        steps, energies = [], []
        try:
            with osz.open("r", encoding="utf-8", errors="ignore") as f:
                i = 0
                for line in f:
                    m = ENERGY_RX.search(line)
                    if m:
                        val = m.group(1) or m.group(2)
                        try:
                            e = float(val)
                            i += 1
                            steps.append(i)
                            energies.append(e)
                        except Exception:
                            pass
        except Exception as e:
            messagebox.showerror(APP_NAME, f"解析失败：{e}")
            return
        # 复用监视页画布
        self.on_energy_update(steps, energies)
        self.post_log.insert(tk.END, f"一次性绘制完成，点数：{len(steps)}\n")
        self.post_log.see(tk.END)

    def extract_final_energy(self):
        proj = self.current_project_path()
        osz = proj / "OSZICAR"
        if not osz.exists():
            messagebox.showwarning(APP_NAME, f"{osz} 不存在。")
            return
        last_e = None
        try:
            for line in osz.read_text(encoding="utf-8", errors="ignore").splitlines():
                m = ENERGY_RX.search(line)
                if m:
                    val = m.group(1) or m.group(2)
                    try:
                        last_e = float(val)
                    except Exception:
                        pass
        except Exception as e:
            messagebox.showerror(APP_NAME, f"解析失败：{e}")
            return
        if last_e is None:
            messagebox.showwarning(APP_NAME, "未解析到能量。")
        else:
            self.post_log.insert(tk.END, f"最终能量（最后一步）：{last_e:.6f} eV\n")
            self.post_log.see(tk.END)

    # ------------------------- 配置读写（保存用户设置） ---------------------
    def load_config(self):
        if not CONFIG_PATH.exists():
            return
        try:
            data = json.loads(CONFIG_PATH.read_text(encoding="utf-8"))
        except Exception:
            return
        # 窗口几何
        geom = data.get("geometry")
        if geom:
            try:
                self.geometry(geom)
            except Exception:
                pass
        # 基本变量
        project_path = data.get("project", self.project_var.get())
        self.pot_dir_var.set(data.get("pot_dir", self.pot_dir_var.get()))
        self.run_mode.set(data.get("run_mode", self.run_mode.get()))
        self.vasp_cmd.set(data.get("vasp_cmd", self.vasp_cmd.get()))
        try:
            self.mpi_np.set(int(data.get("mpi_np", self.mpi_np.get())))
        except Exception:
            pass
        self.file_watch_var.set(data.get("file_watch", self.file_watch_var.get()))
        # SLURM
        self.slurm_part.set(data.get("slurm_part", self.slurm_part.get()))
        self.slurm_time.set(data.get("slurm_time", self.slurm_time.get()))
        try:
            self.slurm_nodes.set(int(data.get("slurm_nodes", self.slurm_nodes.get())))
            self.slurm_ntasks.set(int(data.get("slurm_ntasks", self.slurm_ntasks.get())))
        except Exception:
            pass
        self.slurm_account.set(data.get("slurm_account", self.slurm_account.get()))
        # K 网格
        k = data.get("kgrid", {})
        for var, key in [(self.k_nx, "nx"),(self.k_ny, "ny"),(self.k_nz, "nz")]:
            try:
                var.set(int(k.get(key, var.get())))
            except Exception:
                pass
        try:
            self.k_gamma.set(bool(k.get("gamma", self.k_gamma.get())))
        except Exception:
            pass
        # 选中的页签
        try:
            idx = int(data.get("tab_index", 0))
            self.nb.select(idx)
        except Exception:
            pass
        self.set_project(project_path)

    def save_config(self):
        data = {
            "geometry": self.geometry(),
            "project": self.project_var.get(),
            "pot_dir": self.pot_dir_var.get(),
            "run_mode": self.run_mode.get(),
            "vasp_cmd": self.vasp_cmd.get(),
            "mpi_np": self._int_from_var(self.mpi_np, 8),
            "slurm_part": self.slurm_part.get(),
            "slurm_time": self.slurm_time.get(),
            "slurm_nodes": self._int_from_var(self.slurm_nodes, 1),
            "slurm_ntasks": self._int_from_var(self.slurm_ntasks, 32),
            "slurm_account": self.slurm_account.get(),
            "kgrid": {
                "nx": self._int_from_var(self.k_nx, 5),
                "ny": self._int_from_var(self.k_ny, 5),
                "nz": self._int_from_var(self.k_nz, 5),
                "gamma": bool(self.k_gamma.get()),
            },
            "tab_index": self.nb.index("current"),
            "file_watch": self.file_watch_var.get(),
        }
        try:
            CONFIG_DIR.mkdir(parents=True, exist_ok=True)
            CONFIG_PATH.write_text(json.dumps(data, ensure_ascii=False, indent=2), encoding="utf-8")
        except Exception:
            pass

    def _register_suggestion_widget(self, widget: tk.Text):
        self.run_suggestion_widgets.append(widget)

    def current_project_path(self) -> Path:
        val = self.project_var.get()
        try:
            proj = Path(val).expanduser()
        except Exception:
            proj = Path(val)
        self.project_dir = proj
        return proj

    def apply_run_status(self, status_text: str, suggestions: list[str] | None = None):
        self.run_status_var.set(status_text)
        text = "暂无建议。"
        if suggestions:
            text = "\n".join(f"• {s}" for s in suggestions)
        for widget in self.run_suggestion_widgets:
            try:
                widget.configure(state="normal")
                widget.delete("1.0", tk.END)
                widget.insert("1.0", text)
                widget.configure(state="disabled")
            except Exception:
                pass

    def refresh_run_status(self):
        """后台采样 + 主线程更新；带防抖，确保同一时刻最多一个采样线程。"""
        proj = self.current_project_path()
        if not proj.exists():
            self.apply_run_status("⚠️ 项目目录不存在", ["请选择有效的项目路径。"])
            return

        # --- 防抖：已有一次刷新在路上，就直接跳过 ---
        if getattr(self, "_refresh_busy", False):
            return
        self._refresh_busy = True

        watch_files = [s.strip() for s in self.file_watch_var.get().split(",") if s.strip()]

        def _worker():
            try:
                stats = SystemStatsMonitor.snapshot(proj, watch_files)
            except Exception:
                stats = {"run_state": "unknown", "suggestions": ["状态刷新失败。"]}
            finally:
                # 回到主线程：更新 UI，并清除 busy 标记
                def _apply():
                    try:
                        self._handle_stats(stats)
                    finally:
                        self._refresh_busy = False

                self.after(0, _apply)

        threading.Thread(target=_worker, daemon=True).start()

    def _handle_stats(self, stats: dict):
        run_state = stats.get("run_state")
        run_pids = stats.get("run_pids", [])
        if run_state == "running" and run_pids:
            status = f"   运行中 (PID {', '.join(run_pids)})"
        elif run_state == "idle":
            status = "⚪ 未检测到 VASP 进程"
        else:
            status = "⚠️ 状态未知"
        suggestions = stats.get("suggestions") or []
        self.apply_run_status(status, suggestions)
        self.update_overview_with_file_stats(stats.get("files", []))

    def update_overview_with_file_stats(self, file_stats: list[dict]):
        tree = getattr(self, "workflow_tree", None)
        if not tree or not file_stats:
            return
        # 使用现有 iid 判断是否存在
        existing = set(tree.get_children()) | {"__project__", "INCAR", "POSCAR", "KPOINTS", "POTCAR", "CONTCAR",
                                               "vasp.out", "OSZICAR", "OUTCAR"}
        for item in file_stats:
            name = item.get("name")
            if not name:
                continue
            short = Path(name).name
            key = self.overview_key_map.get(short.lower())
            if not key or key not in existing:
                continue
            label = self.overview_label_map.get(key, short)
            if item.get("exists"):
                detail = f"大小 {format_bytes(item.get('size'))}"
                delta = item.get("delta")
                if isinstance(delta, (int, float)):
                    detail += f" | Δ {format_bytes(delta)}"
                status = "📈 输出增长" if isinstance(delta, (int, float)) and delta > 0 else "✅ 已存在"
            else:
                status = "⚠️ 未找到"
                detail = "尚未生成或路径不匹配"
            tree.item(key, values=(label, status, detail))

    def refresh_project_overview(self):
        tree = getattr(self, "workflow_tree", None)
        if not tree:
            return
        for row in tree.get_children():
            tree.delete(row)
        proj = self.current_project_path()
        exists = proj.exists()
        proj_status = "✅ 已存在" if exists else "⚠️ 未找到"
        tree.insert(
            "",
            tk.END,
            iid="__project__",
            values=(self.overview_label_map.get("__project__", "项目目录"), proj_status, str(proj)),
        )
        for key, label in self.overview_items:
            if key == "__project__":
                continue
            path = proj / key
            if path.exists():
                try:
                    stat = path.stat()
                    mtime = time.strftime("%Y-%m-%d %H:%M", time.localtime(stat.st_mtime))
                    status = "✅ 已存在"
                    detail = f"更新于 {mtime} | {format_bytes(stat.st_size)}"
                except Exception:
                    status = "✅ 已存在"
                    detail = "已检测到文件"
            else:
                status = "⚠️ 未找到"
                detail = "项目目录中未检测到该文件"
            tree.insert("", tk.END, iid=key, values=(label, status, detail))

    def load_project_inputs(self):
        proj = self.current_project_path()
        mapping = [
            (proj / "INCAR", getattr(self, "incar_text", None)),
            (proj / "POSCAR", getattr(self, "poscar_text", None)),
            (proj / "KPOINTS", getattr(self, "kpoints_text", None)),
        ]
        for path, widget in mapping:
            if not widget or not path.exists():
                continue
            try:
                widget.delete("1.0", tk.END)
                widget.insert("1.0", read_text(path))
            except Exception:
                pass

    def set_project(self, path: Path):
        try:
            path = Path(path).expanduser()
        except Exception:
            path = Path(path)
        self.project_dir = path
        self.project_var.set(str(path))
        self.load_project_inputs()
        self.refresh_project_overview()
        self.refresh_run_status()

    # ------------------------- 项目与体检 ----------------------------------
    def choose_project(self):
        d = filedialog.askdirectory(initialdir=self.project_var.get(), title="选择项目目录")
        if d:
            self.set_project(Path(d))

    def create_project(self):
        d = filedialog.askdirectory(initialdir=str(Path.home()), title="选择或创建项目父目录")
        if not d:
            return
        # 创建以时间命名的项目
        base = Path(d)
        name = time.strftime("vasp_proj_%Y%m%d_%H%M%S")
        p = base / name
        p.mkdir(parents=True, exist_ok=True)
        self.set_project(p)
        messagebox.showinfo(APP_NAME, f"已创建项目目录：{p}")

    def quick_check(self):
        proj = self.current_project_path()
        msgs = []
        for f in ["INCAR", "POSCAR", "POTCAR", "KPOINTS"]:
            exists = (proj / f).exists()
            msgs.append(f"{f:7s} : {'✔' if exists else '✗'}")
        for cmd in ["mpirun", self.vasp_cmd.get().strip(), "sbatch", "wsl" if os.name == "nt" else None]:
            if cmd:
                msgs.append(f"which {cmd:8s} -> {which(cmd) or '未找到'}")
        potroot = Path(self.pot_dir_var.get())
        msgs.append(f"POT 库: {potroot} {'(存在)' if potroot.exists() else '(不存在)'}")
        for msg in msgs:
            self.append_run_log(msg)
        self.refresh_project_overview()
        self.refresh_run_status()

    # === 并行推断辅助 ===
    def _read_file_text(self, p: Path) -> str:
        try:
            return p.read_text(encoding="utf-8", errors="ignore")
        except Exception:
            return ""

    def _incar_get(self, key: str) -> int | None:
        txt = self._read_file_text(self.current_project_path() / "INCAR")
        m = re.search(rf"(?mi)^\s*{re.escape(key)}\s*=\s*([-+]?\d+)", txt)
        return int(m.group(1)) if m else None

    def _incar_upsert(self, key: str, val: int):
        """在 INCAR 中插入/更新形如 'KEY = val' 的行：
        - 匹配不区分大小写，仅替换第一处，以保留后续注释或模板段落
        - 保留原有行前缩进
        - 追加时确保文件末尾带换行
        """
        proj = self.current_project_path()
        incar = proj / "INCAR"
        txt = self._read_file_text(incar)

        # 目标行（不带末尾换行，写入时再统一补 '\n'）
        new_line = f"{key:6s} = {val}"

        # 匹配：行首可有空白，然后是 key，再等号到行尾；忽略大小写、多行模式
        # 使用命名分组 'lead' 保留原有缩进
        pattern = re.compile(rf"(?mi)^(?P<lead>\s*){re.escape(key)}\s*=.*$")

        m = pattern.search(txt)
        if m:
            # 仅替换第一处匹配，保持该行原有缩进
            def _repl(mm: re.Match) -> str:
                lead = mm.group('lead') or ''
                return f"{lead}{new_line}"

            txt = pattern.sub(_repl, txt, count=1)
            # 确保文件以换行结尾
            if not txt.endswith("\n"):
                txt += "\n"
        else:
            # 末尾补换行后再追加新行
            if txt and not txt.endswith("\n"):
                txt += "\n"
            txt += new_line + "\n"

        write_text(incar, txt)

    def _infer_nbands(self) -> int | None:
        outcar = self.current_project_path() / "OUTCAR"
        m = re.search(r"(?mi)\bNBANDS\s*=\s*(\d+)", self._read_file_text(outcar))
        return int(m.group(1)) if m else None

    def _infer_kpoints_total(self) -> int | None:
        """粗略从 KPOINTS 取 Monkhorst-Pack 网格乘积；line-mode 留空。"""
        kp = self.current_project_path() / "KPOINTS"
        s = self._read_file_text(kp).splitlines()
        if len(s) >= 4 and re.search(r"(?i)gamma|monkhorst", s[2]):
            try:
                nx, ny, nz = map(int, s[3].split()[:3])
                return max(1, nx * ny * nz)
            except Exception:
                return None
        return None

    def _best_divisor(self, n: int, choices=(8, 6, 4, 3, 2, 1)) -> int:
        for c in choices:
            if n % c == 0: return c
        return 1

    def _autotune_parallel_and_write(self, np_total: int):
        """核心：根据 -np / NBANDS / KPOINTS 推断 KPAR 与 NCORE，并写回 INCAR。"""
        # 1) 读现有设置（用户若已手动设定，尊重并只做校验）
        ncore_user = self._incar_get("NCORE")
        kpar_user = self._incar_get("KPAR")

        # 2) 粗略信息
        nbands = self._infer_nbands() or 12  # 缺省 12（小体系常见）
        ktot = self._infer_kpoints_total() or np_total  # 没法判断就放宽

        # 3) 选一个合理的 NCORE（要能整除 -np）
        ncore = ncore_user if ncore_user and np_total % ncore_user == 0 else self._best_divisor(np_total)

        # 4) 估 groups（band 并行组数），不能超过 NBANDS
        groups_max = max(1, nbands)
        # KPAR 先给个上限（不能超过总 k 点的粗略值）
        kpar_max = max(1, min(ktot, np_total // ncore))

        # 若用户指定了 KPAR 就尽量用，否则我们分配尽量多的 k 点并行
        if kpar_user:
            kpar = max(1, min(kpar_user, kpar_max))
        else:
            # 让剩余核数 /ncore 尽量落到“<= NBANDS”的组数
            # np_total = KPAR * NCORE * groups  →  groups = np_total/(KPAR*NCORE)
            kpar = kpar_max
            while kpar > 1 and np_total // (kpar * ncore) > groups_max:
                kpar -= 1
            # 还要让整除成立
            while kpar > 1 and (np_total % (kpar * ncore) != 0):
                kpar -= 1
            kpar = max(1, kpar)

        groups = max(1, np_total // (kpar * ncore))

        # 5) 写回（只有当自动模式勾选或用户未设置时才写）
        if self.auto_parallel.get() or (ncore_user is None):
            self._incar_upsert("NCORE", ncore)
        if self.auto_parallel.get() or (kpar_user is None):
            self._incar_upsert("KPAR", kpar)

        self.append_run_log(
            f"[auto-parallel] np={np_total}, 推断: NCORE={ncore}, KPAR={kpar}, groups≈{groups}, NBANDS≈{nbands}, K总≈{ktot}")

    def _plots_dir(self) -> Path:
        d = self.current_project_path() / "plots"
        d.mkdir(parents=True, exist_ok=True)
        return d

    def export_convergence(self):
        proj = self.current_project_path()
        osz = proj / "OSZICAR"
        if not osz.exists():
            messagebox.showwarning(APP_NAME, f"{osz} 不存在。");
            return
        steps, energies = [], []
        with osz.open("r", encoding="utf-8", errors="ignore") as f:
            i = 0
            for line in f:
                m = ENERGY_RX.search(line)
                if m:
                    val = m.group(1) or m.group(2)
                    try:
                        e = float(val.replace("D", "E").replace("d", "E"))
                        i += 1;
                        steps.append(i);
                        energies.append(e)
                    except:
                        pass
        if not energies:
            messagebox.showwarning(APP_NAME, "OSZICAR 未解析到能量。");
            return

        # 图
        fig = Figure(figsize=(6, 4), dpi=140);
        ax = fig.add_subplot(111)
        ax.plot(steps, energies, marker="o", linestyle="-")
        ax.set_xlabel("Ionic step");
        ax.set_ylabel("Total energy [eV]")
        ax.grid(True, linestyle=":", linewidth=0.8)
        canvas = FigureCanvasTkAgg(fig, master=self.page_post); canvas.draw()
        canvas.draw()

        out = self._plots_dir()
        png = out / "convergence.png";
        svg = out / "convergence.svg";
        csv = out / "convergence.csv"
        fig.savefig(png, bbox_inches="tight");
        fig.savefig(svg, bbox_inches="tight")
        with (csv).open("w", encoding="utf-8") as g:
            g.write("step,energy_eV\n");
            g.writelines(f"{s},{e}\n" for s, e in zip(steps, energies))
        self.post_log.insert(tk.END, f"已导出收敛图：{png}\nSVG：{svg}\nCSV：{csv}\n")

    def _fermi_from_outcar(self) -> float | None:
        m = re.search(r"(?mi)E-fermi\s*:\s*([-\d.Ee+]+)", self._read_file_text(self.current_project_path() / "OUTCAR"))
        return float(m.group(1)) if m else None

    def export_dos_total(self):
        proj = self.current_project_path()
        doscar = proj / "DOSCAR"
        if not doscar.exists():
            messagebox.showwarning(APP_NAME, "未找到 DOSCAR。请先做 DOS 计算。");
            return
        ef = self._fermi_from_outcar() or 0.0

        with doscar.open("r", encoding="utf-8", errors="ignore") as f:
            lines = f.read().splitlines()
        if len(lines) < 6:
            messagebox.showwarning(APP_NAME, "DOSCAR 文件太短。");
            return
        # 第6行起为 DOS 数据，直到 NEDOS 行数结束；简单做法：跳过前5行，直到遇到空行/非数字
        data = []
        for ln in lines[5:]:
            parts = ln.split()
            if len(parts) < 3: break
            try:
                nums = list(map(float, parts))
                data.append(nums)
            except:
                break
        if not data:
            messagebox.showwarning(APP_NAME, "未解析到 DOS 数据。");
            return

        arr = list(zip(*data))  # 转置
        E = [x - ef for x in arr[0]]
        if len(arr) >= 5:  # 自旋极化：E, DOS_up, DOS_dn, Int_up, Int_dn
            DOS = [u + d for u, d in zip(arr[1], arr[2])]
        else:  # 非极化：E, DOS, Int
            DOS = list(arr[1])

        # 图
        fig = Figure(figsize=(6, 4), dpi=140);
        ax = fig.add_subplot(111)
        ax.plot(E, DOS, linewidth=1.2)
        ax.axvline(0.0, linestyle="--", linewidth=0.8)  # EF
        ax.set_xlabel("Energy - $E_F$ (eV)");
        ax.set_ylabel("DOS (states/eV)")
        ax.grid(True, linestyle=":", linewidth=0.8)
        out = self._plots_dir()
        png = out / "dos_total.png";
        svg = out / "dos_total.svg";
        csv = out / "dos_total.csv"
        fig.savefig(png, bbox_inches="tight");
        fig.savefig(svg, bbox_inches="tight")
        with (csv).open("w", encoding="utf-8") as g:
            g.write("E-EF,DOS\n");
            g.writelines(f"{x},{y}\n" for x, y in zip(E, DOS))
        self.post_log.insert(tk.END, f"已导出 DOS：{png}\nSVG：{svg}\nCSV：{csv}\n")

    def export_bands(self):
        proj = self.current_project_path()
        eig = proj / "EIGENVAL"
        if not eig.exists():
            messagebox.showwarning(APP_NAME, "未找到 EIGENVAL。请使用 KPOINTS 路径做 band 计算。");
            return
        ef = self._fermi_from_outcar() or 0.0
        txt = self._read_file_text(eig).splitlines()

        # 头部：第6行通常包含 NKPTS, NBANDS, NIONS
        try:
            parts = txt[5].split()
            nk, nb = int(parts[0]), int(parts[1])
        except Exception:
            messagebox.showwarning(APP_NAME, "EIGENVAL 头部解析失败。");
            return

        i = 6
        kpts = []
        bands = [[] for _ in range(nb)]

        for _ in range(nk):
            # 跳过空行（有些版本每个 k-block 前有空行）
            while i < len(txt) and not txt[i].strip():
                i += 1
            if i >= len(txt):
                break

            # kx ky kz w
            try:
                kx, ky, kz, w = map(float, txt[i].split()[:4])
            except Exception:
                messagebox.showwarning(APP_NAME, "EIGENVAL k 点块格式异常。")
                return
            i += 1
            kpts.append((kx, ky, kz))

            # nb 行： bandIndex, energy, occ
            for b in range(nb):
                parts = txt[i].split()
                e = float(parts[1]) - ef
                bands[b].append(e)
                i += 1

        import math
        xs = [0.0]
        for a, b in zip(kpts[:-1], kpts[1:]):
            xs.append(xs[-1] + math.dist(a, b))

        fig = Figure(figsize=(6, 4), dpi=140)
        ax = fig.add_subplot(111)
        for b in range(nb):
            ax.plot(xs, bands[b], linewidth=0.8)
        ax.axhline(0, linestyle="--", linewidth=0.8)  # EF
        ax.set_xlabel("k-path (arb.)")
        ax.set_ylabel("Energy - $E_F$ (eV)")
        ax.grid(True, linestyle=":", linewidth=0.8)
        out = self._plots_dir()
        png, svg, csv = out / "bands.png", out / "bands.svg", out / "bands.csv"
        fig.savefig(png, bbox_inches="tight")
        fig.savefig(svg, bbox_inches="tight")
        with csv.open("w", encoding="utf-8") as g:
            g.write("k," + ",".join(f"band{b + 1}" for b in range(nb)) + "\n")
            for j in range(nk):
                row = [f"{xs[j]}"] + [f"{bands[b][j]}" for b in range(nb)]
                g.write(",".join(row) + "\n")
        self.post_log.insert(tk.END, f"已导出能带：{png}\nSVG：{svg}\nCSV：{csv}\n")

    def import_project_files(self):
        """把项目目录下的 INCAR/POSCAR/KPOINTS 一键读入三个编辑器，并刷新概览与状态。"""
        self.load_project_inputs()
        self.refresh_project_overview()
        self.refresh_run_status()
        messagebox.showinfo(APP_NAME, "已读取项目文件并刷新状态。")

    # ------------------------- 退出清理 ------------------------------------
    def on_close(self):
        try:
            # 保存配置
            self.save_config()
            # 停止监视与 tail 进程
            self.stop_monitor()
            if self.proc and self.proc.poll() is None:
                self.proc.terminate()
        except Exception:
            pass
        self.destroy()
        self._stop_following_log()


if __name__ == "__main__":
    app = VaspGUI()
    app.mainloop()
