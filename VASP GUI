#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
VASP Linux 一体化GUI（Tkinter 版 | 单文件可运行）
=================================================
目标：把 Linux 下常用 VASP 操作整合到简洁 GUI：项目管理、INCAR/POSCAR/KPOINTS 编辑、
POTCAR 拼接（本地已有赝势）、K 点生成、作业脚本生成与提交（本地 / SLURM）、
以及 OSZICAR 能量-步数监视与简单可视化。

依赖（尽量轻）：
- Python 3.8+
- tkinter（随 Python 自带）
- matplotlib（绘图）

可选依赖（提升体验，但不是必须）：
- ttkbootstrap（更美观的主题）
- pymatgen / ase（将来可扩展结构与后处理）

使用：
- python vasp_gui.py

说明：
- 本工具不包含、也不会分发任何 VASP 程序或赝势文件。请确保你拥有 VASP 许可，
  并在"POTCAR 面板"正确设置本地赝势库路径。
- 监视功能主要解析 OSZICAR（F= 或 E0= 行），用于快速查看收敛趋势。
- SLURM 模板可在 GUI 中一键生成，你可以直接提交或先手动修改。

作者：ChatGPT（GPT-5 Thinking）
许可：MIT
"""
from __future__ import annotations
import os
import sys
import re
import time
import json
import textwrap
import shutil
import math
import threading
import subprocess
import hashlib
import datetime as _dt
import pickle
import tempfile
from collections import deque
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Tuple, Literal, Callable
from pathlib import Path

try:
    import tkinter as tk
    from tkinter import ttk, filedialog, messagebox
    from tkinter.scrolledtext import ScrolledText
except Exception as e:
    print("[FATAL] Tkinter 未安装或不可用：", e)
    sys.exit(1)

# matplotlib 放在 TkAgg 嵌入
import matplotlib
matplotlib.use("TkAgg")
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib.figure import Figure

try:
    import ttkbootstrap as tb
    HAS_TTKBOOTSTRAP = True
except Exception:
    tb = None
    HAS_TTKBOOTSTRAP = False

try:
    import pymatgen  # type: ignore  # noqa: F401
    HAS_PYMATGEN = True
except Exception:
    HAS_PYMATGEN = False

# === CODEX BEGIN: imports for twist/shift page ===
try:
    import numpy as np  # 数值与线性代数
    HAS_NUMPY = True
except Exception:
    HAS_NUMPY = False

try:
    from pymatgen.analysis.interfaces.zsl import ZSLGenerator  # type: ignore
    HAS_ZSL = True
except Exception:
    HAS_ZSL = False
# === CODEX END: imports for twist/shift page ===

try:
    import seekpath  # type: ignore  # noqa: F401
    HAS_SEEKPATH = True
except Exception:
    HAS_SEEKPATH = False

EV_TO_J = 1.602176634e-19
HBAR = 1.054571817e-34  # J*s
M_E = 9.10938356e-31     # kg
ANG_TO_M = 1e-10


def _ensure_report_dirs(workdir: Path, opts: Dict[str, Any]) -> tuple[Path, Path, Path]:
    """确保报告输出目录存在，返回 (report_dir, figs_dir, tables_dir)。"""
    report_dir = opts.get("report_dir")
    if not report_dir:
        ts = _dt.datetime.now().strftime("%Y%m%d-%H%M%S")
        report_dir = workdir / "reports" / f"post_{ts}"
    report_dir = Path(report_dir)
    figs_dir = report_dir / "figs"
    figs_dir.mkdir(parents=True, exist_ok=True)
    tables_dir = report_dir / "tables"
    tables_dir.mkdir(parents=True, exist_ok=True)
    return report_dir, figs_dir, tables_dir


def _read_kpoints_linemode(kpoints_path: Path) -> tuple[list[list[float]], list[str]]:
    """解析 line-mode KPOINTS（含 ! 标签），返回 (kpoints_frac, labels)。
    labels 与点一一对应，若无标签用空串。
    """
    ks: list[list[float]] = []
    labs: list[str] = []
    try:
        lines = read_text(kpoints_path).splitlines()
    except Exception:
        return ks, labs
    if len(lines) < 5:
        return ks, labs
    for ln in lines[4:]:
        s = ln.strip()
        if not s:
            continue
        parts = s.split("!")
        xyz = parts[0].split()
        if len(xyz) >= 3:
            try:
                kx, ky, kz = float(xyz[0]), float(xyz[1]), float(xyz[2])
                ks.append([kx, ky, kz])
                labs.append(parts[1].strip() if len(parts) > 1 else "")
            except Exception:
                pass
    return ks, labs


APP_NAME = "VASP GUI"

# 配置文件路径（保存用户设置）
CONFIG_DIR = Path.home() / ".config" / "vasp_gui"
CONFIG_PATH = CONFIG_DIR / "config.json"


@dataclass
class PostResult:
    metrics: Dict[str, float]
    figs: Dict[str, Path]
    tables: Dict[str, Path]
    notes: List[str]
    extra: Dict[str, Any] = field(default_factory=dict)


@dataclass
class PostProc:
    name: str
    needs: List[str]
    runner: Callable[[Path, Dict[str, Any]], PostResult]


POSTPROCS: Dict[str, PostProc] = {}


def register_postproc(proc: PostProc) -> None:
    POSTPROCS[proc.name] = proc


@dataclass
class WizardProfile:
    system_type: Literal["metal", "semiconductor", "insulator"]
    workflow: Literal["relax_scf_dos", "relax_scf_bands", "scf_dos"]
    encut_strategy: Literal["auto", "manual"]
    encut_value: Optional[int]
    k_mode: Literal["kspacing", "kpoints"]
    kspacing: Optional[float]
    kgrid: Optional[Tuple[int, int, int]]
    use_slurm: bool
    np: int
    slurm: Dict[str, Any]
    figure_style: Literal["AFM"]
    emit_report: bool


FIG_STYLES: Dict[str, Dict[str, Any]] = {
    "AFM": {
        "font": "Times New Roman",
        "size": {"title": 12, "label": 11, "tick": 10},
        "linew": 1.2,
        "tick_dir": "in",
        "tick_len": 3,
        "box": True,
    },
}

POST_FIG_DPI = 240


def _normalize_style(style: str | None) -> str:
    if style in FIG_STYLES:
        return style  # type: ignore[return-value]
    return "AFM"


def _clone_2d_table(table: list[list[float]] | None) -> list[list[float]]:
    if not table:
        return []
    return [list(row) for row in table]


def _extract_kcoords(raw_kpts: list[Any] | None) -> list[list[float]]:
    coords: list[list[float]] = []
    if not raw_kpts:
        return coords
    for item in raw_kpts:
        vec: Any = None
        if isinstance(item, (list, tuple)):
            if item and isinstance(item[0], (list, tuple)):
                vec = item[0]
            else:
                vec = item
        if vec is None:
            continue
        try:
            triple = [float(vec[i]) for i in range(3)]
        except Exception:
            continue
        coords.append(triple)
    return coords


def _coords_close(a: list[float], b: list[float], tol: float = 1e-6) -> bool:
    if len(a) != len(b):
        return False
    return all(abs(x - y) <= tol for x, y in zip(a, b))


def _align_band_lengths(
    bands: list[list[float]],
    occs: list[list[float]] | None,
    coords: list[list[float]] | None,
) -> tuple[list[list[float]], list[list[float]] | None, list[list[float]] | None]:
    if coords and len(coords) != len(bands):
        limit = min(len(coords), len(bands))
        bands = bands[:limit]
        if occs:
            occs = occs[:limit]
        coords = coords[:limit]
    if occs and len(occs) != len(bands):
        occs = occs[: len(bands)]
    return bands, occs, coords


def _trim_periodic_path(
    coords: list[list[float]] | None,
    bands: list[list[float]],
    occs: list[list[float]] | None,
) -> tuple[list[list[float]] | None, list[list[float]], list[list[float]] | None, bool]:
    trimmed = False
    if coords and bands and len(coords) == len(bands) and len(coords) > 1:
        if _coords_close(coords[0], coords[-1]):
            coords = coords[:-1]
            bands = bands[:-1]
            if occs:
                occs = occs[:-1]
            trimmed = True
    return coords, bands, occs, trimmed


def _transpose_band_table(table: list[list[float]]) -> list[list[float]]:
    if not table:
        return []
    widths = [len(row) for row in table if row]
    if not widths:
        return []
    nb = min(widths)
    if nb <= 0:
        return []
    return [[row[i] for row in table if i < len(row)] for i in range(nb)]


def _compute_kpath_positions(
    coords: list[list[float]] | None,
    recip: list[list[float]] | None = None,
) -> list[float]:
    if not coords:
        return []
    positions: list[float] = []
    accum = 0.0
    prev_vec: list[float] | None = None
    use_recip = (
        recip is not None
        and len(recip) >= 3
        and all(isinstance(row, (list, tuple)) and len(row) >= 3 for row in recip[:3])
    )
    for frac in coords:
        if len(frac) < 3:
            continue
        if use_recip:
            vec = [
                frac[0] * float(recip[0][i])
                + frac[1] * float(recip[1][i])
                + frac[2] * float(recip[2][i])
                for i in range(3)
            ]
        else:
            vec = [float(frac[i]) for i in range(3)]
        if prev_vec is not None:
            delta = math.sqrt(sum((vec[i] - prev_vec[i]) ** 2 for i in range(3)))
            if delta > 1e-9:
                accum += delta
        positions.append(accum)
        prev_vec = vec
    return positions


def _split_segments_from_positions(positions: list[float]) -> list[tuple[int, int]]:
    if len(positions) < 2:
        return []
    segments: list[tuple[int, int]] = []
    start = 0
    for idx in range(1, len(positions)):
        if abs(positions[idx] - positions[idx - 1]) < 1e-9:
            if idx - start > 1:
                segments.append((start, idx))
            start = idx
    if len(positions) - start > 1:
        segments.append((start, len(positions)))
    if not segments:
        segments.append((0, len(positions)))
    return segments

DEFAULT_POSCAR_TEMPLATE = """Si
1.0
5.430000 0.000000 0.000000
0.000000 5.430000 0.000000
0.000000 0.000000 5.430000
Si
1
Direct
0.000000 0.000000 0.000000
"""

EXAMPLE_SI_POSCAR = """Si example (diamond)
1.0
0.000000 2.715000 2.715000
2.715000 0.000000 2.715000
2.715000 2.715000 0.000000
Si
2
Direct
0.000000 0.000000 0.000000
0.250000 0.250000 0.250000
"""

EXAMPLE_SI_INCAR = """# 示例项目默认 INCAR
SYSTEM = example_Si
ENCUT = 520
PREC  = Accurate
EDIFF = 1e-6
IBRION = 2
ISIF   = 3
NSW    = 60
ISMEAR = 0
SIGMA  = 0.05
LREAL  = Auto
LWAVE  = .FALSE.
LCHARG = .TRUE.
"""

EXAMPLE_SI_KPOINTS = """Automatic mesh
0
Gamma
6 6 6
0 0 0
"""


# === DEMO DATA (improved realistic set) ======================================
# 口径：PBE-like Si (diamond)；间接带隙 ~0.62 eV (VBM@Γ, CBM@X)

def _linspace(a: float, b: float, n: int) -> list[float]:
    if n <= 1:
        return [a]
    step = (b - a) / (n - 1)
    return [a + i * step for i in range(n)]

def _lerp_vec(a: list[float], b: list[float], t: float) -> list[float]:
    return [a[i] + (b[i] - a[i]) * t for i in range(3)]

def _cumtrapz(y: list[float], x: list[float]) -> list[float]:
    # 简单梯形积分，不依赖 numpy
    out = [0.0]
    for i in range(1, len(x)):
        dx = x[i] - x[i-1]
        out.append(out[-1] + 0.5 * (y[i] + y[i-1]) * dx)
    return out

def _smoothstep(x: float, k: float = 6.0) -> float:
    # logistic-based smooth step: 0~1 过渡，用于柔化带边
    # s(x)=1/(1+exp(-k*x))
    import math
    return 1.0 / (1.0 + math.exp(-k * x))

def _build_demo_twist_results() -> list[dict[str, float]]:
    """生成二维材料演示用的扭转/滑移扫参数据。"""
    import math

    thetas = [0.0, 2.0, 4.0, 6.0, 8.0]
    ux_list = [0.00, 0.25, 0.50, 0.75]
    uy_list = [0.00, 0.33, 0.66]

    Eg0 = 1.55  # 近似 "MoS2-like" 双层带隙（演示用途）
    results: list[dict[str, float]] = []
    for th in thetas:
        for ux in ux_list:
            for uy in uy_list:
                gap = (
                    Eg0
                    - 0.10 * (th / 8.0)  # 小角扭转轻微减隙
                    + 0.12 * math.cos(math.pi * ux)
                    + 0.10 * math.cos(math.pi * uy)
                )
                gap = max(0.85, gap)

                Etot = -500.0 + 0.08 * th + 0.20 * ux + 0.18 * uy

                results.append(
                    {
                        "theta": round(float(th), 6),
                        "ux": round(float(ux), 6),
                        "uy": round(float(uy), 6),
                        "gap": round(float(gap), 6),
                        "E": round(float(Etot), 6),
                        "path": f"theta_{th:04.1f}_ux_{ux:04.2f}_uy_{uy:04.2f}",
                        "note": "2D-demo-mos2",
                    }
                )

    return results


def _build_demo_si():
    import math

    # ---------- DOS / PDOS ----------
    E_MIN, E_MAX, DE = -12.0, 8.0, 0.02
    energies = []
    e = E_MIN
    while e <= E_MAX + 1e-12:
        energies.append(round(e, 6))
        e += DE
    EF = 0.0
    Eg = 0.62  # PBE-like Si 间接带隙近似值（演示）

    # 价带以 p 为主，深能级掺点 s；导带弱 d
    dos_s, dos_p, dos_d = [], [], []
    for E in energies:
        # 抑制带隙内 DOS（光滑衰减）
        gate_v = 1.0 - _smoothstep(E - (-1e-3), k=55.0)   # E<0 强，E>0 抑制
        gate_c = _smoothstep(E - Eg, k=55.0)              # E<Eg 抑制，E>Eg 放大

        # 简单的多峰近似（不追求材料级拟合，只追求形态合理）
        valence_p = 1.8 * math.exp(-((E + 3.5) / 1.8) ** 2)                   + 1.2 * math.exp(-((E + 7.5) / 1.3) ** 2)
        valence_s = 0.9 * math.exp(-((E + 6.5) / 1.0) ** 2)

        # 导带从 Eg 起，逐渐抬升
        conduction_p = 1.0 * math.exp(-((E - (Eg + 1.2)) / 1.4) ** 2)
        conduction_d = 0.35 * math.exp(-((E - (Eg + 2.6)) / 1.2) ** 2)

        s = gate_v * (0.35 * valence_s) + gate_c * (0.25 * conduction_p)
        p = gate_v * (1.00 * valence_p) + gate_c * (0.85 * conduction_p)
        d = gate_c * conduction_d

        # 防止极小负值/NaN
        dos_s.append(max(0.0, s))
        dos_p.append(max(0.0, p))
        dos_d.append(max(0.0, d))

    pdos_curves = {"Si-s": dos_s, "Si-p": dos_p, "Si-d": dos_d}
    total_dos = [dos_s[i] + dos_p[i] + dos_d[i] for i in range(len(energies))]
    integrated = _cumtrapz(total_dos, energies)

    # --------- bands (Γ–X–W–K–Γ–L) ----------
    # fcc 常用高对称路径（分数坐标，近似即可）
    # Γ(0,0,0) → X(0,1/2,1/2) → W(1/4,1/2,3/4) → K(3/8,3/4,3/8) → Γ → L(1/2,1/2,1/2)
    nodes = [
        ("Γ", [0.0,   0.0,  0.0]),
        ("X", [0.0,   0.5,  0.5]),
        ("W", [0.25,  0.5,  0.75]),
        ("K", [0.375, 0.75, 0.375]),
        ("Γ", [0.0,   0.0,  0.0]),
        ("L", [0.5,   0.5,  0.5]),
    ]
    pts_per_seg = 9  # 每段插 9 点（含端点），全路径约 41 点，渲染顺滑
    kpoints = []
    labels = []
    # 生成分段直线插值路径；端点不重复
    for idx in range(len(nodes) - 1):
        name_a, ka = nodes[idx]
        name_b, kb = nodes[idx + 1]
        for i in range(pts_per_seg):
            t = i / (pts_per_seg - 1)
            if idx > 0 and i == 0:
                # 跳过重复端点
                continue
            kpoints.append(_lerp_vec(ka, kb, t))
            lbl = name_a if i == 0 else (name_b if i == (pts_per_seg - 1) else "")
            labels.append(lbl)

    nk = len(kpoints)
    distances = [0.0]
    for i in range(1, nk):
        # 用等步长的“虚拟距离”即可，不依赖晶格
        distances.append(distances[-1] + 1.0)

    # 构造 6 条带：3 条价带（VB1~VB3），3 条导带（CB1~CB3）
    # 形状：VB1 最高在 Γ（0 eV），到 X 降至 ~-0.45 eV；CB1 最低在 X（Eg）
    def _seg_u(i0: int, i1: int, i: int) -> float:
        # 返回 i 在段 [i0,i1] 上的线性 0..1
        if i1 == i0:
            return 0.0
        return (i - i0) / float(i1 - i0)

    # 找到各段索引范围
    idxs = []
    start_idx = 0
    for name, _ in nodes[1:]:
        # 找 label == name 的位置作为段末
        end_idx = max(j for j, lbl in enumerate(labels) if lbl == name)
        idxs.append((start_idx, end_idx))
        start_idx = end_idx

    # 能量生成：按段定义线性/轻微余弦变化，保证 CB1(X)≈Eg、VB1(Γ)=0
    def _bands_along_path():
        # 初始化二维表：nk 行 × 6 带
        B = [[0.0] * 6 for _ in range(nk)]

        # 目标锚点（单位 eV）
        E_Gamma_VBM = 0.0
        E_X_VBM     = -0.45
        E_W_VBM     = -0.35
        E_K_VBM     = -0.40
        E_L_VBM     = -0.15

        E_Gamma_CBM = 3.2
        E_X_CBM     = Eg
        E_W_CBM     = 1.4
        E_K_CBM     = 1.6
        E_L_CBM     = 2.0

        anchors_v = [E_Gamma_VBM, E_X_VBM, E_W_VBM, E_K_VBM, E_Gamma_VBM, E_L_VBM]
        anchors_c = [E_Gamma_CBM, E_X_CBM, E_W_CBM, E_K_CBM, E_Gamma_CBM, E_L_CBM]

        # 逐段插值
        for s, (i0, i1) in enumerate(idxs):
            Ev0, Ev1 = anchors_v[s], anchors_v[s+1]
            Ec0, Ec1 = anchors_c[s], anchors_c[s+1]
            for i in range(i0, i1 + 1):
                u = _seg_u(i0, i1, i)
                # 轻微余弦，避免过于生硬
                w = 0.5 - 0.5 * math.cos(math.pi * u)
                Ev = Ev0 + (Ev1 - Ev0) * w
                Ec = Ec0 + (Ec1 - Ec0) * w

                # 六条带：VB1 最高，其余下移；CB1 最低，其余上移
                B[i][0] = Ev                       # VB1
                B[i][1] = Ev - 0.80                # VB2
                B[i][2] = Ev - 1.60                # VB3
                B[i][3] = Ec                       # CB1
                B[i][4] = Ec + 0.80                # CB2
                B[i][5] = Ec + 1.60                # CB3
        return B

    band_values = _bands_along_path()
    band_occs = []
    for i in range(nk):
        row = []
        for e_val in band_values[i]:
            row.append(1.0 if e_val < EF else 0.0)
        band_occs.append(row)

    # ---------- 平面平均势（z） ----------
    # 设一维 slab，z∈[0, 24] Å，两层原子平面在 z≈6 Å 与 18 Å，势能凹谷 + 轻微表面偶极
    z = _linspace(0.0, 24.0, 180)
    pot = []
    for zi in z:
        # 两个“层内势阱” + 真空中的缓慢起伏 + 表面偶极台阶
        v = -0.18 * math.exp(-((zi - 6.0) / 0.8) ** 2)             -0.18 * math.exp(-((zi - 18.0) / 0.8) ** 2)             + 0.02 * math.sin(2.0 * math.pi * zi / 24.0)             + (0.06 if zi > 12.0 else 0.0)
        pot.append(v)
    # 归一到 V(0)=0 的相对势
    pot0 = pot[0]
    pot_rel = [v - pot0 for v in pot]

    # ---------- 2D 扭转/滑移扫参（演示） ----------
    twist_results = _build_demo_twist_results()

    # ---------- 汇总成原有全局变量 ----------
    demo = {}

    demo["DEMO_DOS_ENERGIES"]   = energies
    demo["DEMO_DOS_TOTAL"]      = total_dos
    demo["DEMO_DOS_INTEGRATED"] = integrated
    demo["DEMO_PDOS_CURVES"]    = pdos_curves
    demo["DEMO_PDOS_TOTAL"]     = [dos_s[i] + dos_p[i] + dos_d[i] for i in range(len(energies))]

    demo["DEMO_BAND_KPOINTS"]   = kpoints
    demo["DEMO_BAND_LABELS"]    = labels
    demo["DEMO_BAND_VALUES"]    = band_values          # 形状：nk × 6
    demo["DEMO_BAND_OCCS"]      = band_occs            # 形状：nk × 6
    demo["DEMO_BAND_DISTANCES"] = distances

    demo["DEMO_PLANAR_Z"]       = z
    demo["DEMO_PLANAR_VALUES"]  = pot_rel

    demo["DEMO_TWIST_RESULTS"]  = twist_results

    # demo 项目文件（KPOINTS 含路径标签；其余与原逻辑兼容）
    kpoints_linemode = """Si band path (fcc)
18
Line-mode
Reciprocal
0.0000 0.0000 0.0000 ! Γ
0.0000 0.0625 0.0625 !
0.0000 0.1250 0.1250 !
0.0000 0.1875 0.1875 !
0.0000 0.2500 0.2500 !
0.0000 0.3125 0.3125 !
0.0000 0.3750 0.3750 !
0.0000 0.4375 0.4375 !
0.0000 0.5000 0.5000 ! X
0.1250 0.5000 0.6250 ! W
0.1875 0.6250 0.5000 !
0.2812 0.6875 0.4375 !
0.3750 0.7500 0.3750 ! K
0.2812 0.5000 0.2812 !
0.1875 0.2500 0.1875 !
0.0938 0.1250 0.0938 !
0.0000 0.0000 0.0000 ! Γ
0.5000 0.5000 0.5000 ! L
"""

    demo["DEMO_PROJECT_FILES"] = {
        "INCAR": EXAMPLE_SI_INCAR + "\n# 演示模式示例输入（改良版数据）\n",
        "POSCAR": EXAMPLE_SI_POSCAR,
        "KPOINTS": kpoints_linemode,
        "README.txt": (
            "演示模式项目（改良数据）\n"
            "========================\n"
            "包含更贴近 Si(PBE-like) 的 DOS/PDOS、间接带隙能带（Γ→X 为主）、\n"
            "以及平面平均势与二维扭转/滑移扫参的示例结果。用于验证 GUI 流程与出图。\n"
            "无需真实 VASP 输出。"
        ),
        "vasprun.xml": "<!-- demo placeholder: 数据由内置样本提供 -->\n",
        "EIGENVAL": "# demo placeholder\n",
        "DOSCAR": "# demo placeholder\n",
        "OUTCAR": "# demo placeholder\nE-fermi : 5.4000\n",
        "LOCPOT": "# demo placeholder\n",
    }

    # 方便下方直接赋值
    return demo

# 生成并绑定到原有全局名
_demo = _build_demo_si()
DEMO_DOS_ENERGIES   = _demo["DEMO_DOS_ENERGIES"]
DEMO_DOS_TOTAL      = _demo["DEMO_DOS_TOTAL"]
DEMO_DOS_INTEGRATED = _demo["DEMO_DOS_INTEGRATED"]
DEMO_PDOS_CURVES    = _demo["DEMO_PDOS_CURVES"]
DEMO_PDOS_TOTAL     = _demo["DEMO_PDOS_TOTAL"]

DEMO_BAND_KPOINTS   = _demo["DEMO_BAND_KPOINTS"]
DEMO_BAND_LABELS    = _demo["DEMO_BAND_LABELS"]
DEMO_BAND_VALUES    = _demo["DEMO_BAND_VALUES"]
DEMO_BAND_OCCS      = _demo["DEMO_BAND_OCCS"]
DEMO_BAND_DISTANCES = _demo["DEMO_BAND_DISTANCES"]

DEMO_PLANAR_Z       = _demo["DEMO_PLANAR_Z"]
DEMO_PLANAR_VALUES  = _demo["DEMO_PLANAR_VALUES"]

DEMO_TWIST_RESULTS  = _demo["DEMO_TWIST_RESULTS"]
DEMO_POSTPROCS = {
    "dos":   {"energies": DEMO_DOS_ENERGIES, "dos": DEMO_DOS_TOTAL,
              "integrated": DEMO_DOS_INTEGRATED, "fermi": 0.0},
    "pdos":  {"energies": DEMO_DOS_ENERGIES, "total": DEMO_PDOS_TOTAL,
              "curves": DEMO_PDOS_CURVES, "fermi": 0.0, "gap": 0.62},
    "bands": {"bands": DEMO_BAND_VALUES, "occupancies": DEMO_BAND_OCCS,
              "kpoints": DEMO_BAND_KPOINTS, "fermi": 0.0,
              "distances": DEMO_BAND_DISTANCES},
    "bands_lbl": {"bands": DEMO_BAND_VALUES, "occupancies": DEMO_BAND_OCCS,
                  "kpoints": DEMO_BAND_KPOINTS, "labels": DEMO_BAND_LABELS,
                  "fermi": 0.0, "distances": DEMO_BAND_DISTANCES},
    "emass": {"bands": DEMO_BAND_VALUES, "occupancies": DEMO_BAND_OCCS,
              "distances": DEMO_BAND_DISTANCES, "fermi": 0.0,
              "me_star": 0.26, "mh_star": 0.49},  # 典型 Si 有效质量近似
    "pot_z": {"z": DEMO_PLANAR_Z, "values": DEMO_PLANAR_VALUES},
}
DEMO_PROJECT_FILES = _demo["DEMO_PROJECT_FILES"]
# === END DEMO DATA (improved realistic set) ==================================
# ----------------------------- 工具函数区 ----------------------------------

def which(cmd: str) -> str | None:
    """返回可执行文件绝对路径，找不到则 None。"""
    return shutil.which(cmd)

def read_text(p: Path) -> str:
    try:
        return p.read_text(encoding="utf-8")
    except Exception:
        try:
            return p.read_text(encoding="latin-1")
        except Exception:
            return ""

def write_text(p: Path, s: str) -> None:
    p.write_text(s, encoding="utf-8")

def format_bytes(num: int | float | None) -> str:
    """将字节数转为易读字符串。"""
    if num is None:
        return "-"
    try:
        n = float(num)
    except Exception:
        return str(num)
    if n < 0:
        n = 0.0
    units = ["B", "KB", "MB", "GB", "TB", "PB"]
    for unit in units:
        if n < 1024.0 or unit == units[-1]:
            if unit == "B":
                return f"{int(n)} {unit}"
            return f"{n:.1f} {unit}"
        n /= 1024.0
    return f"{n:.1f} PB"

POSCAR_ELEM_LINE_RX = re.compile(r"^\s*([A-Za-z][a-z]?(?:\s+[A-Za-z][a-z]?)*?)\s*$")
COUNTS_RX = re.compile(r"^\s*(\d+(?:\s+\d+)*)\s*$")
# 兼容:  -12.34   12.   .1234   -1.23E+02   3.4D-01
ENERGY_RX = re.compile(
    r"F=\s*([+-]?(?:\d+(?:\.\d*)?|\.\d+)(?:[EeDd][+-]?\d+)?)"
    r"|E0=\s*([+-]?(?:\d+(?:\.\d*)?|\.\d+)(?:[EeDd][+-]?\d+)?)"
)
# 备用：从 OUTCAR 也能抓（有时 OSZICAR 很慢才写）
TOTEN_RX = re.compile(
    r"free\s+energy\s+TOTEN\s*=\s*([+-]?(?:\d+(?:\.\d*)?|\.\d+)(?:[EeDd][+-]?\d+)?)",
    re.IGNORECASE
)



def parse_poscar(poscar_text: str):
    """粗略解析 POSCAR 的元素与计数。尽量兼容两种第6/7行写法。
    返回 (elements: list[str], counts: list[int])，可能为空。"""
    lines = [ln.rstrip("\n") for ln in poscar_text.splitlines() if ln.strip() != ""]
    if len(lines) < 8:
        return [], []
    # 寻找元素与计数两行：兼容存在 Selective dynamics 行
    # 常见：
    # 1: comment
    # 2: scale
    # 3-5: lattice
    # 6: elements OR counts
    # 7: counts (if 6 is elements)
    # 8: Selective dynamics? OR Direct/Cartesian
    elem_line = None
    cnt_line = None

    # 尝试 line6 作为元素，line7 作为计数
    l6 = lines[5]
    l7 = lines[6]
    if POSCAR_ELEM_LINE_RX.match(l6) and COUNTS_RX.match(l7):
        elem_line = l6
        cnt_line = l7
    else:
        # 也可能 line6 就是计数（没有元素符号行）
        if COUNTS_RX.match(l6):
            cnt_line = l6
            elem_line = None

    elements = []
    if elem_line:
        elements = elem_line.split()
    # 计数
    counts = []
    if cnt_line:
        counts = [int(x) for x in cnt_line.split()]

    return elements, counts


def unique_elements_from_poscar(poscar_text: str):
    elems, _ = parse_poscar(poscar_text)
    return elems


def find_potcar_candidates(elem: str, pot_dir: Path) -> list[Path]:
    """在 pot_dir 下递归查找包含给定元素名称的 POTCAR 文件，返回候选列表。
    常见目录层级（示例）：
      PAW_PBE/Si/POTCAR  或  potcars/PBE/Si/POTCAR  或  potpaw_PBE.54/Si/POTCAR
    策略：深度<=3 的广度优先查找，目录名包含元素精确匹配。"""
    elem = elem.strip()
    max_depth = 3
    queue = [(pot_dir, 0)]
    candidates = []
    while queue:
        d, depth = queue.pop(0)
        if depth > max_depth:
            continue
        try:
            for entry in d.iterdir():
                if entry.is_dir():
                    name = entry.name
                    if name == elem:
                        pot = entry / "POTCAR"
                        if pot.exists():
                            candidates.append(pot)
                    queue.append((entry, depth + 1))
        except PermissionError:
            pass
        except FileNotFoundError:
            pass
    seen = []
    unique: list[Path] = []
    for cand in candidates:
        key = str(cand)
        if key not in seen:
            seen.append(key)
            unique.append(cand)
    return unique


def build_potcar(pot_files: list[Path], out_path: Path) -> tuple[bool, str]:
    """将 pot_files 中的 POTCAR 依序拼接到 out_path。返回 (ok, msg)。"""
    if not pot_files:
        return False, "未提供任何 POTCAR 文件。"
    try:
        with open(out_path, "wb") as fout:
            for p in pot_files:
                pp = Path(p)
                if not pp.exists():
                    return False, f"未找到 POTCAR：{pp}"
                fout.write(pp.read_bytes())
        return True, f"POTCAR 已生成：{out_path}"
    except Exception as ex:
        return False, f"生成 POTCAR 失败：{ex}"


def gen_kpoints_monkhorst(nx: int, ny: int, nz: int, gamma_center: bool) -> str:
    lines = [
        "Auto KPOINTS",
        "0",
        "Gamma" if gamma_center else "Monkhorst-Pack",
        f"{nx} {ny} {nz}",
        "0 0 0",
    ]
    return "\n".join(lines) + "\n"


def apply_style(ax, style: str) -> None:
    """Apply a lightweight journal style preset to a Matplotlib axis."""
    cfg = FIG_STYLES.get(style, FIG_STYLES["AFM"])
    font = cfg.get("font", "Arial")
    size_cfg = cfg.get("size", {})
    for label in ax.get_xticklabels():
        label.set_fontfamily(font)
        label.set_fontsize(size_cfg.get("tick", 10))
    for label in ax.get_yticklabels():
        label.set_fontfamily(font)
        label.set_fontsize(size_cfg.get("tick", 10))
    ax.tick_params(direction=cfg.get("tick_dir", "in"), length=cfg.get("tick_len", 3))
    ax.set_title(ax.get_title(), fontfamily=font, fontsize=size_cfg.get("title", 12))
    ax.set_xlabel(ax.get_xlabel(), fontfamily=font, fontsize=size_cfg.get("label", 11))
    ax.set_ylabel(ax.get_ylabel(), fontfamily=font, fontsize=size_cfg.get("label", 11))
    for spine in ax.spines.values():
        spine.set_linewidth(cfg.get("linew", 1.2))
        spine.set_visible(True)
    if not cfg.get("box", True):
        for spine in ("top", "right"):
            ax.spines[spine].set_visible(False)


def _fingerprint_files(files: list[Path]) -> str:
    h = hashlib.sha1()
    for path in files:
        try:
            st = path.stat()
        except Exception:
            continue
        h.update(str(path).encode("utf-8", "ignore"))
        h.update(str(st.st_size).encode())
        h.update(str(int(st.st_mtime_ns)).encode())
    return h.hexdigest()


def _load_cached(workdir: Path, cache_key: str, files: list[Path], builder: Callable[[], Any]) -> Any:
    cache_dir = workdir / ".cache"
    fingerprint = _fingerprint_files(files)
    meta_path = cache_dir / f"{cache_key}.json"
    data_path = cache_dir / f"{cache_key}.pkl"
    if cache_dir.exists() and meta_path.exists() and data_path.exists():
        try:
            meta = json.loads(meta_path.read_text(encoding="utf-8"))
        except Exception:
            meta = {}
        if meta.get("fingerprint") == fingerprint:
            try:
                with data_path.open("rb") as fp:
                    return pickle.load(fp)
            except Exception:
                pass
    data = builder()
    if data is None:
        return None
    try:
        cache_dir.mkdir(parents=True, exist_ok=True)
        meta_path.write_text(json.dumps({"fingerprint": fingerprint}, ensure_ascii=False), encoding="utf-8")
        with data_path.open("wb") as fp:
            pickle.dump(data, fp)
    except Exception:
        pass
    return data


def _parse_fermi_from_outcar(workdir: Path) -> Optional[float]:
    outcar = workdir / "OUTCAR"
    if not outcar.exists():
        return None
    tail: deque[str] = deque(maxlen=2000)
    try:
        with outcar.open("r", encoding="utf-8", errors="ignore") as fh:
            for line in fh:
                tail.append(line)
    except Exception:
        return None
    rx = re.compile(r"E-?fermi\s*[:=]\s*([-+0-9.eE]+)")
    for line in reversed(tail):
        m = rx.search(line)
        if m:
            try:
                return float(m.group(1))
            except Exception:
                continue
    return None


def _parse_dos_vasprun(workdir: Path) -> Optional[dict[str, Any]]:
    vasprun = workdir / "vasprun.xml"
    if not vasprun.exists():
        return None
    try:
        from xml.etree import ElementTree as ET
    except Exception:
        return None

    energies: list[float] = []
    dos: list[float] = []
    integ: list[float] = []
    efermi: Optional[float] = None

    try:
        context = ET.iterparse(str(vasprun), events=("end",))
        for event, elem in context:
            if elem.tag == "i" and elem.attrib.get("name") == "efermi" and elem.text:
                try:
                    efermi = float(elem.text)
                except Exception:
                    pass
            if elem.tag == "set" and elem.attrib.get("comment", "").lower().startswith("spin 1"):
                energies.clear()
                dos.clear()
                integ.clear()
                for row in elem.findall("r"):
                    text = row.text or ""
                    parts = text.split()
                    if len(parts) >= 3:
                        try:
                            energies.append(float(parts[0]))
                            dos.append(float(parts[1]))
                            integ.append(float(parts[2]))
                        except Exception:
                            continue
                elem.clear()
                break
            elem.clear()
    except Exception:
        return None

    if not energies:
        return None
    return {"energies": energies, "dos": dos, "integrated": integ, "fermi": efermi}


def _parse_dos_doscar(workdir: Path) -> Optional[dict[str, Any]]:
    doscar = workdir / "DOSCAR"
    if not doscar.exists():
        return None
    try:
        with doscar.open("r", encoding="utf-8", errors="ignore") as fh:
            header = [next(fh) for _ in range(5)]
            line = next(fh)
            while line.strip() == "":
                line = next(fh)
            parts = line.split()
            if len(parts) < 3:
                return None
            ngrid = int(parts[2])
            efermi = float(parts[3]) if len(parts) > 3 else None
            energies: list[float] = []
            dos: list[float] = []
            integ: list[float] = []
            for _ in range(ngrid):
                vals = next(fh).split()
                if len(vals) < 3:
                    continue
                try:
                    e = float(vals[0])
                    up = float(vals[1])
                    dn = float(vals[2])
                    energies.append(e)
                    if len(vals) >= 5:
                        # spin polarized: up, down, integrated up, integrated down
                        dos.append(up + dn)
                        integ.append(float(vals[3]) + float(vals[4]))
                    else:
                        dos.append(up)
                        integ.append(dn)
                except Exception:
                    continue
    except Exception:
        return None
    return {"energies": energies, "dos": dos, "integrated": integ, "fermi": efermi}


def _estimate_gap_from_dos(energies: list[float], dos: list[float], threshold: float) -> tuple[float, str]:
    if not energies or not dos or len(energies) != len(dos):
        return 0.0, "unknown"
    pairs = sorted(zip(energies, dos), key=lambda x: x[0])
    lower = [p for p in pairs if p[0] <= 0]
    upper = [p for p in pairs if p[0] >= 0]
    if not lower or not upper:
        return 0.0, "unknown"
    # find valence edge: energy closest to zero from below where DOS < threshold
    val_states = [e for e, d in lower if abs(d) <= threshold]
    cond_states = [e for e, d in upper if abs(d) <= threshold]
    if not val_states or not cond_states:
        return 0.0, "metal"
    ev = max(val_states)
    ec = min(cond_states)
    gap = max(ec - ev, 0.0)
    if gap <= 1e-4:
        return 0.0, "metal"
    return gap, "insulator"


def proc_dos(workdir: Path, opts: Dict[str, Any]) -> PostResult:
    style = _normalize_style(opts.get("style"))
    threshold = float(opts.get("metal_threshold", 0.02))
    demo_payload = opts.get("demo_payload")
    if demo_payload:
        data = demo_payload
    else:
        cache_key = "dos_total"
        files = [workdir / "vasprun.xml", workdir / "DOSCAR", workdir / "OUTCAR"]

        def _builder():
            data = _parse_dos_vasprun(workdir)
            if data is None:
                data = _parse_dos_doscar(workdir)
            if data is None:
                raise FileNotFoundError("缺少 DOS 数据文件 (vasprun.xml/DOSCAR)")
            return data

        data = _load_cached(workdir, cache_key, files, _builder)
        if data is None:
            raise RuntimeError("无法解析 DOS 数据。")

    energies = data.get("energies", [])
    dos = data.get("dos", [])
    efermi = data.get("fermi")
    if efermi is None:
        outcar_fermi = _parse_fermi_from_outcar(workdir)
        if outcar_fermi is not None:
            efermi = outcar_fermi
        elif energies:
            efermi = (max(energies) + min(energies)) / 2
        else:
            efermi = 0.0
    rel_energies = [e - efermi for e in energies]
    dos_at_ef = 0.0
    if rel_energies and dos:
        # interpolate around zero
        closest_idx = min(range(len(rel_energies)), key=lambda i: abs(rel_energies[i]))
        dos_at_ef = float(dos[closest_idx])
    gap, band_type = _estimate_gap_from_dos(rel_energies, dos, threshold)
    is_metal = 1.0 if dos_at_ef > threshold else 0.0

    report_dir, figs_dir, tables_dir = _ensure_report_dirs(workdir, opts)

    fig = Figure(figsize=(5.0, 3.2))
    ax = fig.add_subplot(111)
    ax.plot(rel_energies, dos, color="#1f77b4", lw=1.4)
    ax.axvline(0.0, color="#d62728", ls="--", lw=1.0)
    ax.set_xlabel("E - E$_F$ (eV)")
    ax.set_ylabel("DOS (states/eV)")
    apply_style(ax, style)
    fig.tight_layout()
    fig_path = figs_dir / "dos.png"
    fig.savefig(fig_path, dpi=POST_FIG_DPI)

    csv_path = tables_dir / "dos.csv"
    with csv_path.open("w", encoding="utf-8") as fh:
        fh.write("E-Ef (eV),DOS\n")
        for e, d in zip(rel_energies, dos):
            fh.write(f"{e:.6f},{d:.6f}\n")

    notes = []
    if band_type == "metal":
        notes.append("DOS 显示体系为金属态（带隙≈0）。")
    elif gap > 0:
        notes.append(f"估算带隙 ~ {gap:.3f} eV。")

    metrics = {
        "E_F": float(efermi),
        "DOS(E_F)": float(dos_at_ef),
        "is_metal": float(is_metal),
        "gap": float(gap),
    }

    return PostResult(
        metrics=metrics,
        figs={"dos": fig_path},
        tables={"dos": csv_path},
        notes=notes,
        extra={"plot": {"x": rel_energies, "y": dos, "style": style}},
    )


def _parse_eigenval(workdir: Path) -> Optional[dict[str, Any]]:
    eigenval = workdir / "EIGENVAL"
    if not eigenval.exists():
        return None
    try:
        with eigenval.open("r", encoding="utf-8", errors="ignore") as fh:
            header = [next(fh) for _ in range(5)]
            counts = next(fh)
            while counts.strip() == "":
                counts = next(fh)
            nel, nk, nb = map(int, counts.split()[:3])
            kpts: list[tuple[list[float], float]] = []
            bands: list[list[float]] = []
            occs: list[list[float]] = []
            for ik in range(nk):
                line = next(fh)
                while line.strip() == "":
                    line = next(fh)
                parts = list(map(float, line.split()))
                kcoord = parts[:3]
                weight = parts[3] if len(parts) > 3 else 1.0 / nk
                energies: list[float] = []
                occ: list[float] = []
                for ib in range(nb):
                    vals = next(fh).split()
                    if len(vals) < 3:
                        continue
                    energies.append(float(vals[1]))
                    occ.append(float(vals[2]))
                kpts.append((kcoord, weight))
                bands.append(energies)
                occs.append(occ)
    except Exception:
        return None
    return {"kpoints": kpts, "bands": bands, "occupancies": occs}


def _estimate_gap_from_bands(bands: list[list[float]], occs: list[list[float]], fermi: float) -> tuple[float, str, float, float]:
    if not bands:
        return 0.0, "unknown", fermi, fermi
    vbm = -1e9
    cbm = 1e9
    direct_gap = 1e9
    vb_k = cb_k = None
    for kidx, (energies, occ) in enumerate(zip(bands, occs)):
        v_local = max((e for e, o in zip(energies, occ) if o > 0.5), default=-1e9)
        c_local = min((e for e, o in zip(energies, occ) if o < 0.5), default=1e9)
        if v_local > vbm:
            vbm = v_local
            vb_k = kidx
        if c_local < cbm:
            cbm = c_local
            cb_k = kidx
        gap_k = max(c_local - v_local, 0.0)
        if gap_k < direct_gap:
            direct_gap = gap_k
    gap = max(cbm - vbm, 0.0)
    if gap <= 1e-4:
        return 0.0, "metal", vbm, cbm
    nature = "direct" if vb_k == cb_k and direct_gap <= gap + 1e-3 else "indirect"
    return gap, nature, vbm, cbm


def proc_bands(workdir: Path, opts: Dict[str, Any]) -> PostResult:
    style = _normalize_style(opts.get("style"))
    threshold = float(opts.get("metal_threshold", 0.02))
    demo_payload = opts.get("demo_payload") if isinstance(opts.get("demo_payload"), dict) else None
    data: dict[str, Any] | None = None
    fermi_hint: float | None = None
    distance_hint: list[float] = []
    if isinstance(demo_payload, dict):
        data = demo_payload
        try:
            fermi_hint = float(demo_payload.get("fermi"))
        except Exception:
            fermi_hint = None
        dist_val = demo_payload.get("distances")
        if isinstance(dist_val, (list, tuple)):
            try:
                distance_hint = [float(x) for x in dist_val]
            except Exception:
                distance_hint = []
    if data is None:
        cache_key = "bands"
        files = [workdir / "vasprun.xml", workdir / "EIGENVAL", workdir / "OUTCAR"]

        def _builder():
            data = _parse_dos_vasprun(workdir)
            if data and data.get("energies"):
                # vasprun already parsed for dos; but band requires dedicated parse
                pass
            bands_data = _parse_eigenval(workdir)
            if bands_data is None:
                raise FileNotFoundError("缺少能带数据 (vasprun.xml/EIGENVAL)")
            return bands_data

        data = _load_cached(workdir, cache_key, files, _builder)
        if data is None:
            raise RuntimeError("无法解析能带数据。")

    raw_bands = _clone_2d_table(data.get("bands"))
    if not raw_bands:
        raise RuntimeError("未能在 vasprun.xml/EIGENVAL 中解析到能带数据，请确认已完成能带计算。")
    occs = _clone_2d_table(data.get("occupancies"))
    coords = _extract_kcoords(data.get("kpoints"))

    if not coords and isinstance(demo_payload, dict):
        coords = _extract_kcoords(demo_payload.get("kpoints"))
    if not coords:
        kp_file, _ = _read_kpoints_linemode(workdir / "KPOINTS")
        coords = _extract_kcoords(kp_file)
    bands, occs, coords = _align_band_lengths(raw_bands, occs, coords)
    coords, bands, occs, trimmed = _trim_periodic_path(coords, bands, occs)


    fermi = fermi_hint
    if fermi is None:
        fermi = _parse_fermi_from_outcar(workdir)
    if fermi is None and bands:
        flat = [e for energies in bands for e in energies]
        fermi = sum(flat) / len(flat)

    gap, nature, vbm, cbm = _estimate_gap_from_bands(bands, occs or [], fermi)

    rel_bands = [[e - fermi for e in row] for row in bands]

    positions = distance_hint or _compute_kpath_positions(coords)
    if not positions:
        positions = list(range(len(rel_bands)))
    if len(positions) != len(rel_bands):
        common = min(len(positions), len(rel_bands))
        positions = positions[:common]
        rel_bands = rel_bands[:common]
        bands = bands[:common]
        if occs:
            occs = occs[:common]
    segments = _split_segments_from_positions(positions)
    band_series = _transpose_band_table(rel_bands)
    if not band_series:
        raise RuntimeError("能带数据为空，请确认已完成能带计算。")

    report_dir, figs_dir, tables_dir = _ensure_report_dirs(workdir, opts)

    fig = Figure(figsize=(5.0, 3.5))
    ax = fig.add_subplot(111)
    plotted = False
    for series in band_series:
        for start, end in segments:
            xs = positions[start:end]
            ys = series[start:end]
            if len(xs) >= 2:
                ax.plot(xs, ys, color="#1f77b4", lw=1.0)
                plotted = True
    if not plotted and positions and band_series:
        ax.plot(positions, band_series[0], color="#1f77b4", lw=1.0)
    if positions and min(positions) != max(positions):
        ax.set_xlim(min(positions), max(positions))
    ax.axhline(0.0, color="#d62728", ls="--", lw=1.0)
    ax.set_ylabel("E - E$_F$ (eV)")
    ax.set_xlabel("k-path distance (arb.)")
    apply_style(ax, style)
    fig.tight_layout()
    fig_path = figs_dir / "bands.png"
    fig.savefig(fig_path, dpi=POST_FIG_DPI)

    csv_path = tables_dir / "bands.csv"
    with csv_path.open("w", encoding="utf-8") as fh:
        fh.write("k_index,band_index,E-Ef (eV),occupation\n")
        for kidx, row in enumerate(rel_bands):
            occ_row = occs[kidx] if occs and kidx < len(occs) else []
            for bidx, val in enumerate(row, start=1):
                occ = occ_row[bidx - 1] if bidx - 1 < len(occ_row) else 0.0
                fh.write(f"{kidx},{bidx},{val:.6f},{occ:.3f}\n")

    use_index_axis = not coords or all(abs(positions[i] - float(i)) < 1e-9 for i in range(len(positions)))

    notes = []
    if gap <= 1e-4:
        notes.append("能带结构显示体系为金属态。")
    else:
        notes.append(f"估算带隙约 {gap:.3f} eV（{nature}）。")
    if trimmed:
        notes.append("检测到重复路径端点，已仅保留一个周期的数据。")
    if use_index_axis and positions:
        notes.append("缺少 KPOINTS 路径信息，x 轴按路径索引绘制。")

    metrics = {
        "gap": float(gap),
        "vbm": float(vbm - fermi if vbm != -1e9 else 0.0),
        "cbm": float(cbm - fermi if cbm != 1e9 else 0.0),
        "is_metal": 1.0 if gap <= threshold else 0.0,
        "fermi": float(fermi),
    }

    return PostResult(
        metrics=metrics,
        figs={"bands": fig_path},
        tables={"bands": csv_path},
        notes=notes,
        extra={"plot": {"bands": rel_bands, "style": style}},
    )


register_postproc(PostProc(name="dos", needs=["vasprun.xml|DOSCAR"], runner=proc_dos))
register_postproc(PostProc(name="bands", needs=["vasprun.xml|EIGENVAL"], runner=proc_bands))


def proc_pdos(workdir: Path, opts: Dict[str, Any]) -> PostResult:
    """投影态密度图与数据导出。"""
    style = _normalize_style(opts.get("style"))
    group = (opts.get("group") or "element").lower()
    want_elems = opts.get("elements") or None
    want_orbs = [o.lower() for o in (opts.get("orbitals") or [])]
    ewin = opts.get("energy_window") or (-6.0, 6.0)

    report_dir, figs_dir, tables_dir = _ensure_report_dirs(workdir, opts)

    demo_payload = opts.get("demo_payload") if isinstance(opts.get("demo_payload"), dict) else None

    if demo_payload:
        energies = [float(e) for e in demo_payload.get("energies", [])]
        total = [float(v) for v in demo_payload.get("total", [])]
        raw_curves = demo_payload.get("curves") or {}
        curves = {str(k): [float(x) for x in v] for k, v in raw_curves.items()}
        try:
            efermi = float(demo_payload.get("fermi", 0.0))
        except Exception:
            efermi = 0.0
        gap_val = float(demo_payload.get("gap", 0.0))
        notes = ["演示模式示例 PDOS：数据来源于内置样本。"]
    else:
        if not HAS_PYMATGEN:
            raise RuntimeError("需要 pymatgen 才能生成 PDOS，请安装 pymatgen。")

        from pymatgen.io.vasp.outputs import Vasprun  # type: ignore

        vxml = workdir / "vasprun.xml"
        if not vxml.exists():
            raise FileNotFoundError("未找到 vasprun.xml，无法生成投影态密度。")

        vasprun = Vasprun(str(vxml), parse_dos=True, parse_projected_dos=True)
        cdos = vasprun.complete_dos
        efermi = float(cdos.efermi)
        energies = [float(e) - efermi for e in cdos.energies]

        curves: dict[str, list[float]] = {}
        total = [float(x) for x in cdos.densities["total"]]

        if group == "element":
            wanted = {str(el) for el in want_elems} if want_elems else None
            for el, edos in cdos.get_element_dos().items():
                name = str(el)
                if wanted and name not in wanted:
                    continue
                curves[name] = [float(x) for x in edos.densities["total"]]
        elif group == "orbital":
            for spd, odos in cdos.get_spd_dos().items():
                key = str(spd).lower()
                if want_orbs and key not in want_orbs:
                    continue
                curves[key] = [float(x) for x in odos.densities["total"]]
        elif group == "site":
            structure = cdos.structure
            for idx, site in enumerate(structure.sites[:8]):
                sd = cdos.get_site_dos(site)
                curves[f"site{idx+1}-{site.specie}"] = [float(x) for x in sd.densities["total"]]
        else:
            raise ValueError("PDOS 分组仅支持 element/orbital/site。")

        try:
            gap_info = vasprun.get_band_structure().get_band_gap()
            gap_val = float(gap_info.get("energy", 0.0)) if gap_info else 0.0
        except Exception:
            gap_val = 0.0

        if not curves:
            raise RuntimeError("未在 vasprun.xml 中找到投影 DOS，请确认 INCAR 设置 LORBIT=11/12 并保留投影数据。")

        notes = [
            "PDOS 由 vasprun.xml 投影得到；如需更细分的投影，请在 INCAR 设置 LORBIT=11/12 并确保写出投影数据。",
        ]

    if not curves:
        raise RuntimeError("未在 vasprun.xml 中找到投影 DOS，请确认 INCAR 设置 LORBIT=11/12 并保留投影数据。")

    fig = Figure(figsize=(5.4, 3.3))
    ax = fig.add_subplot(111)
    ax.plot(energies, total, lw=1.6, label="total")
    for name, values in curves.items():
        ax.plot(energies, values, lw=1.0, label=name)
    ax.axvline(0.0, ls="--", lw=1.0)
    ax.set_xlim(ewin[0], ewin[1])
    ax.set_xlabel("E - E$_F$ (eV)")
    ax.set_ylabel("DOS (states/eV)")
    ax.legend(ncol=2, fontsize=8, frameon=False)
    apply_style(ax, style)
    fig.tight_layout()
    fig_path = figs_dir / f"pdos_{group}.png"
    fig.savefig(fig_path, dpi=POST_FIG_DPI)

    csv_path = tables_dir / f"pdos_{group}.csv"
    with csv_path.open("w", encoding="utf-8") as fh:
        headers = ["E-Ef (eV)", "total"] + list(curves.keys())
        fh.write(",".join(headers) + "\n")
        for idx, energy in enumerate(energies):
            row = [f"{energy:.6f}", f"{total[idx]:.6f}"]
            for name in curves.keys():
                values = curves[name]
                val = values[idx] if idx < len(values) else 0.0
                row.append(f"{val:.6f}")
            fh.write(",".join(row) + "\n")

    metrics = {"E_F": float(efermi), "gap": float(gap_val)}
    return PostResult(metrics=metrics, figs={"pdos": fig_path}, tables={"pdos": csv_path}, notes=notes)


register_postproc(PostProc(name="pdos", needs=["vasprun.xml"], runner=proc_pdos))


def _fallback_reciprocal_from_poscar(poscar: Path) -> Optional[list[list[float]]]:
    try:
        lines = read_text(poscar).splitlines()
    except Exception:
        return None
    if len(lines) < 5:
        return None
    try:
        scale = float(lines[1].strip())
        a1 = [float(x) for x in lines[2].split()[:3]]
        a2 = [float(x) for x in lines[3].split()[:3]]
        a3 = [float(x) for x in lines[4].split()[:3]]
    except Exception:
        return None
    lat = [[scale * a1[i], scale * a2[i], scale * a3[i]] for i in range(3)]
    try:
        import numpy as _np

        mat = _np.array(lat, dtype=float)
        recip = 2 * _np.pi * _np.linalg.inv(mat).T
        return recip.tolist()
    except Exception:
        return None


def proc_bands_labeled(workdir: Path, opts: Dict[str, Any]) -> PostResult:
    style = _normalize_style(opts.get("style"))
    report_dir, figs_dir, tables_dir = _ensure_report_dirs(workdir, opts)

    demo_payload = opts.get("demo_payload") if isinstance(opts.get("demo_payload"), dict) else None
    if demo_payload:
        kpts = _extract_kcoords(demo_payload.get("kpoints"))
        raw_labels = demo_payload.get("labels")
        labels = [str(lbl) for lbl in raw_labels] if isinstance(raw_labels, (list, tuple)) else []
    else:
        kpts, labels = _read_kpoints_linemode(workdir / "KPOINTS")

    if demo_payload is None and HAS_PYMATGEN and (workdir / "vasprun.xml").exists():
        from pymatgen.io.vasp.outputs import BSVasprun  # type: ignore

        bsrun = BSVasprun(str(workdir / "vasprun.xml"), parse_projected_eigen=False)
        bands = bsrun.get_band_structure(line_mode=True)
        efermi = float(bands.efermi)
        distances = [float(d) for d in bands.distance]
        rel_bands = [[float(e - efermi) for e in row] for row in bands.bands[bands.spin_keys[0]]]
        ticks = bands.get_ticks()
        tick_pos = [float(p) for p in ticks["distance"]]
        tick_lab = [str(lbl) for lbl in ticks["label"]]
        gap_info = bands.get_band_gap()
        vbm = bands.get_vbm()
        cbm = bands.get_cbm()
        gap_val = float(gap_info.get("energy", 0.0)) if gap_info else 0.0
        nature = "direct" if gap_info and gap_info.get("direct") else "indirect"
        vbm_rel = float(vbm["energy"] - efermi) if vbm else 0.0
        cbm_rel = float(cbm["energy"] - efermi) if cbm else 0.0

        fig = Figure(figsize=(5.6, 3.6))
        ax = fig.add_subplot(111)
        segments = _split_segments_from_positions(distances)
        for series in rel_bands:
            for start, end in segments:
                xs = distances[start:end]
                ys = series[start:end]
                if len(xs) >= 2:
                    ax.plot(xs, ys, lw=1.0)
        for pos in tick_pos:
            ax.axvline(pos, lw=0.6, ls=":", alpha=0.6)
        ax.axhline(0.0, lw=1.0, ls="--")
        ax.set_xticks(tick_pos)
        ax.set_xticklabels(tick_lab)
        ax.set_ylabel("E - E$_F$ (eV)")
        apply_style(ax, style)
        fig.tight_layout()
        fig_path = figs_dir / "bands_labeled.png"
        fig.savefig(fig_path, dpi=POST_FIG_DPI)

        csv_path = tables_dir / "bands_labeled.csv"
        with csv_path.open("w", encoding="utf-8") as fh:
            fh.write("distance,band_index,E-Ef (eV)\n")
            for bidx, row in enumerate(rel_bands, start=1):
                for dist, energy in zip(distances, row):
                    fh.write(f"{dist:.6f},{bidx},{energy:.6f}\n")

        metrics = {
            "gap": float(gap_val),
            "nature": nature,
            "vbm": vbm_rel,
            "cbm": cbm_rel,
        }
        notes = ["x 轴依据高对称路径距离，刻度为自动识别的高对称点。"]
        return PostResult(metrics=metrics, figs={"bands_labeled": fig_path}, tables={"bands_labeled": csv_path}, notes=notes)


    distance_hint: list[float] = []
    if isinstance(demo_payload, dict):
        dist_val = demo_payload.get("distances")
        if isinstance(dist_val, (list, tuple)):
            try:
                distance_hint = [float(x) for x in dist_val]
            except Exception:
                distance_hint = []

    if demo_payload:
        data = demo_payload
    else:
        data = _parse_eigenval(workdir)
        if data is None:
            raise FileNotFoundError("缺少能带数据 (vasprun.xml 或 EIGENVAL)，请先完成能带计算。")

    raw_bands = _clone_2d_table(data.get("bands"))
    if not raw_bands:
        raise RuntimeError("EIGENVAL 中未解析到能带数据，请确认计算输出完整。")
    occs = _clone_2d_table(data.get("occupancies"))
    coords = kpts or _extract_kcoords(data.get("kpoints"))
    bands, occs, coords = _align_band_lengths(raw_bands, occs, coords)
    coords, bands, occs, trimmed = _trim_periodic_path(coords, bands, occs)
    if labels:
        labels = labels[: len(coords) if coords else len(bands)]

    fermi = None
    if isinstance(demo_payload, dict):
        try:
            fermi = float(demo_payload.get("fermi"))
        except Exception:
            fermi = None
    if fermi is None:
        fermi = _parse_fermi_from_outcar(workdir)
    if fermi is None:
        flat = [e for row in bands for e in row]
        fermi = sum(flat) / len(flat) if flat else 0.0

    recip = None
    if HAS_PYMATGEN and (workdir / "POSCAR").exists():
        try:
            from pymatgen.core import Structure  # type: ignore

            structure = Structure.from_file(str(workdir / "POSCAR"))
            recip = structure.lattice.reciprocal_lattice_crystallographic.matrix
        except Exception:
            recip = None
    if recip is None:
        recip = _fallback_reciprocal_from_poscar(workdir / "POSCAR")


    distances = distance_hint or _compute_kpath_positions(coords, recip)
    if not distances:
        distances = list(range(len(bands)))
    if len(distances) != len(bands):
        limit = min(len(distances), len(bands))
        distances = distances[:limit]
        bands = bands[:limit]
        if occs:
            occs = occs[:limit]
        if labels:
            labels = labels[:limit]

    rel_bands = [[e - fermi for e in row] for row in bands]
    gap_val, nature, vabs, cabs = _estimate_gap_from_bands(bands, occs or [], fermi)
    vbm_rel = float(vabs - fermi)
    cbm_rel = float(cabs - fermi)

    band_series = _transpose_band_table(rel_bands)
    if not band_series:
        raise RuntimeError("能带数据不足，无法生成路径图。")

    segments = _split_segments_from_positions(distances)

    fig = Figure(figsize=(5.6, 3.6))
    ax = fig.add_subplot(111)
    plotted = False
    for series in band_series:
        for start, end in segments:
            xs = distances[start:end]
            ys = series[start:end]
            if len(xs) >= 2:
                ax.plot(xs, ys, lw=1.0)
                plotted = True
    if not plotted and distances and band_series:
        ax.plot(distances, band_series[0], color="#1f77b4", lw=1.0)
    if distances and min(distances) != max(distances):
        ax.set_xlim(min(distances), max(distances))
    if labels:
        tick_pos: list[float] = []
        tick_lab: list[str] = []
        for dist, lab in zip(distances, labels):
            if lab:
                tick_pos.append(dist)
                tick_lab.append(lab)
                ax.axvline(dist, lw=0.6, ls=":", alpha=0.6)
        if tick_pos:
            ax.set_xticks(tick_pos)
            ax.set_xticklabels(tick_lab)
    ax.axhline(0.0, lw=1.0, ls="--")
    ax.set_ylabel("E - E$_F$ (eV)")
    apply_style(ax, style)
    fig.tight_layout()
    fig_path = figs_dir / "bands_labeled.png"
    fig.savefig(fig_path, dpi=POST_FIG_DPI)

    csv_path = tables_dir / "bands_labeled.csv"
    with csv_path.open("w", encoding="utf-8") as fh:
        fh.write("distance,band_index,E-Ef (eV)\n")
        for bidx, series in enumerate(band_series, start=1):
            for dist, energy in zip(distances, series):
                fh.write(f"{dist:.6f},{bidx},{energy:.6f}\n")

    metrics = {
        "gap": float(max(cbm_rel - vbm_rel, 0.0)),
        "nature": nature,
        "vbm": vbm_rel,
        "cbm": cbm_rel,
    }
    notes = [
        "EIGENVAL 回退模式：若需精确路径建议使用非自洽能带计算并生成 vasprun.xml。",
    ]
    if trimmed:
        notes.append("检测到重复路径端点，已仅保留一个周期的数据。")
    if not distances or distances == list(range(len(distances))):
        notes.append("缺少晶格信息，x 轴按路径索引绘制。")
    return PostResult(metrics=metrics, figs={"bands_labeled": fig_path}, tables={"bands_labeled": csv_path}, notes=notes)


register_postproc(PostProc(name="bands_lbl", needs=["vasprun.xml|EIGENVAL"], runner=proc_bands_labeled))


def proc_effective_mass(workdir: Path, opts: Dict[str, Any]) -> PostResult:
    style = _normalize_style(opts.get("style"))
    window = max(int(opts.get("window_k", 4)), 2)
    report_dir, figs_dir, tables_dir = _ensure_report_dirs(workdir, opts)
    demo_payload = opts.get("demo_payload") if isinstance(opts.get("demo_payload"), dict) else None

    if demo_payload:
        bands_raw = demo_payload.get("bands") or []
        occs_raw = demo_payload.get("occupancies") or []
        try:
            fermi = float(demo_payload.get("fermi", 0.0))
        except Exception:
            fermi = 0.0

        rel = []
        for row in bands_raw:
            try:
                rel.append([float(e) - fermi for e in row])
            except Exception:
                continue

        occs = []
        for row in occs_raw:
            try:
                occs.append([float(o) for o in row])
            except Exception:
                occs.append([])

        distances: list[float] = []
        raw_dist = demo_payload.get("distances") or []
        if isinstance(raw_dist, (list, tuple)):
            try:
                distances = [float(x) for x in raw_dist]
            except Exception:
                distances = []

        if not rel or not rel[0]:
            raise RuntimeError("演示数据缺少能带或路径信息，无法估算有效质量。")

        nk = len(rel)
        nb = len(rel[0])

        if distances and len(distances) != nk:
            if nb == len(distances):
                rel = _transpose_band_table(rel)
                occs = _transpose_band_table(occs) if occs else occs
                nk = len(rel)
                nb = len(rel[0]) if rel and rel[0] else 0
            distances = [float(x) for x in distances[:nk]]
        if not distances or len(distances) != nk:
            distances = [float(i) for i in range(nk)]

        v_idx = (0, 0)
        c_idx = (0, 0)
        vbm_E = -1e9
        cbm_E = 1e9
        for k in range(nk):
            occ_row = occs[k] if k < len(occs) else []
            for b in range(nb):
                energy = rel[k][b]
                occupied = occ_row[b] if b < len(occ_row) else (1.0 if energy < 0 else 0.0)
                if occupied > 0.5 and energy > vbm_E:
                    vbm_E = energy
                    v_idx = (b, k)
                if occupied < 0.5 and energy < cbm_E:
                    cbm_E = energy
                    c_idx = (b, k)

        rel_by_band = _transpose_band_table(rel)
        if not rel_by_band:
            raise RuntimeError("演示数据缺少能带或路径信息，无法估算有效质量。")

        def _safe_float(val: Any, default: float = 0.0) -> float:
            try:
                return float(val)
            except Exception:
                return default

        me_star = _safe_float(demo_payload.get("me_star"), 0.0)
        mh_star = _safe_float(demo_payload.get("mh_star"), 0.0)

        fig = Figure(figsize=(5.2, 3.4))
        ax = fig.add_subplot(111)
        for series in rel_by_band:
            if not series:
                continue
            length = min(len(series), len(distances))
            if length <= 1:
                continue
            ax.plot(distances[:length], series[:length], lw=0.7, alpha=0.6)
        if distances and v_idx[0] < len(rel_by_band) and v_idx[1] < len(distances) and v_idx[1] < len(rel_by_band[v_idx[0]]):
            ax.scatter([distances[v_idx[1]]], [rel_by_band[v_idx[0]][v_idx[1]]], s=28, label=f"VBM m*_h≈{mh_star:.2f} m_e")
        if distances and c_idx[0] < len(rel_by_band) and c_idx[1] < len(distances) and c_idx[1] < len(rel_by_band[c_idx[0]]):
            ax.scatter([distances[c_idx[1]]], [rel_by_band[c_idx[0]][c_idx[1]]], s=28, label=f"CBM m*_e≈{me_star:.2f} m_e")
        ax.axhline(0.0, lw=1.0, ls="--")
        ax.set_ylabel("E - E$_F$ (eV)")
        apply_style(ax, style)
        ax.legend(fontsize=9, frameon=False)
        fig.tight_layout()
        fig_path = figs_dir / "effective_mass.png"
        fig.savefig(fig_path, dpi=POST_FIG_DPI)

        csv_path = tables_dir / "effective_mass.csv"
        with csv_path.open("w", encoding="utf-8") as fh:
            fh.write("edge,band_index,k_index,m*/m_e\n")
            fh.write(f"VBM,{v_idx[0]},{v_idx[1]},{mh_star:.6f}\n")
            fh.write(f"CBM,{c_idx[0]},{c_idx[1]},{me_star:.6f}\n")

        notes = ["演示模式示例有效质量，数值基于内置数据。"]
        metrics = {"mh*": float(mh_star), "me*": float(me_star)}
        return PostResult(metrics=metrics, figs={"effective_mass": fig_path}, tables={"effective_mass": csv_path}, notes=notes)

    if not HAS_NUMPY:
        raise RuntimeError("需要 numpy 才能估算有效质量，请安装 numpy。")

    import numpy as _np

    if HAS_PYMATGEN and (workdir / "vasprun.xml").exists():
        from pymatgen.io.vasp.outputs import BSVasprun  # type: ignore

        bsrun = BSVasprun(str(workdir / "vasprun.xml"), parse_projected_eigen=False)
        bs = bsrun.get_band_structure(line_mode=True)
        efermi = float(bs.efermi)
        distances = [float(d) for d in bs.distance]
        bands = [[float(e) for e in row] for row in bs.bands[bs.spin_keys[0]]]
        occs = [[1.0 if e < efermi else 0.0 for e in row] for row in bs.bands[bs.spin_keys[0]]]
    else:
        data = _parse_eigenval(workdir)
        if data is None or not data.get("bands"):
            raise FileNotFoundError("缺少能带数据 (vasprun.xml 或 EIGENVAL)，请先完成能带计算。")
        bands = data.get("bands", [])
        occs = data.get("occupancies", [])
        efermi = _parse_fermi_from_outcar(workdir) or 0.0
        kpts, _ = _read_kpoints_linemode(workdir / "KPOINTS")
        recip = None
        if HAS_PYMATGEN and (workdir / "POSCAR").exists():
            try:
                from pymatgen.core import Structure  # type: ignore

                structure = Structure.from_file(str(workdir / "POSCAR"))
                recip = structure.lattice.reciprocal_lattice_crystallographic.matrix
            except Exception:
                recip = None
        if recip is None:
            recip = _fallback_reciprocal_from_poscar(workdir / "POSCAR")
        if recip is not None and kpts:
            distances = []
            accum = 0.0
            prev = None
            for frac in kpts:
                vec = _np.dot(frac, _np.array(recip))
                if prev is None:
                    prev = vec
                dist = float(_np.linalg.norm(vec - prev))
                accum += dist
                distances.append(accum)
                prev = vec
        else:
            distances = list(range(len(bands[0]))) if bands else []

    bands_clean = []
    for row in bands:
        try:
            bands_clean.append([float(e) for e in row])
        except Exception:
            continue
    occs_clean = []
    for row in occs:
        try:
            occs_clean.append([float(o) for o in row])
        except Exception:
            occs_clean.append([])

    if not bands_clean or not bands_clean[0]:
        raise RuntimeError("有效质量拟合失败：能带数据为空，请确认能带计算输出完整。")

    if distances and len(distances) == len(bands_clean[0]) and len(distances) != len(bands_clean):
        bands_k = _transpose_band_table(bands_clean)
        occs_k = _transpose_band_table(occs_clean) if occs_clean else occs_clean
    else:
        bands_k = bands_clean
        occs_k = occs_clean

    nk = len(bands_k)
    if nk == 0:
        raise RuntimeError("有效质量拟合失败：能带数据为空，请确认能带计算输出完整。")

    if distances:
        distances = [float(x) for x in distances[:nk]]
    if not distances or len(distances) != nk:
        distances = [float(i) for i in range(nk)]

    rel = [[val - efermi for val in row] for row in bands_k]
    nb = len(rel[0]) if rel else 0

    v_idx = (0, 0)
    c_idx = (0, 0)
    vbm_E = -1e9
    cbm_E = 1e9
    for k in range(nk):
        occ_row = occs_k[k] if k < len(occs_k) else []
        for b in range(nb):
            energy = rel[k][b]
            occupied = occ_row[b] if b < len(occ_row) else (1.0 if energy < 0 else 0.0)
            if occupied > 0.5 and energy > vbm_E:
                vbm_E = energy
                v_idx = (b, k)
            if occupied < 0.5 and energy < cbm_E:
                cbm_E = energy
                c_idx = (b, k)

    rel_by_band = _transpose_band_table(rel)
    if not rel_by_band:
        raise RuntimeError("有效质量拟合失败：能带数据为空，请确认能带计算输出完整。")

    def _fit_mass(idx: tuple[int, int]) -> tuple[float, list[float], list[float]]:
        band, k0 = idx
        if band < 0 or band >= len(rel_by_band):
            return float("nan"), [], []
        series = rel_by_band[band]
        if not series:
            return float("nan"), [], []
        k0 = max(0, min(k0, len(series) - 1, len(distances) - 1))
        lo = max(0, k0 - window)
        hi = min(len(distances), len(series), k0 + window + 1)
        xs = _np.array(distances[lo:hi], dtype=float)
        ys = _np.array(series[lo:hi], dtype=float)
        if len(xs) < 3:
            return float("nan"), xs.tolist(), ys.tolist()
        coeffs = _np.polyfit(xs, ys, 2)
        a = coeffs[0]
        d2E = 2.0 * a * EV_TO_J * (ANG_TO_M**2)
        if abs(d2E) < 1e-40:
            return float("nan"), xs.tolist(), ys.tolist()
        m_star = HBAR**2 / d2E
        return float(m_star / M_E), xs.tolist(), ys.tolist()

    me_star, _, _ = _fit_mass(c_idx)
    mh_star, _, _ = _fit_mass(v_idx)

    fig = Figure(figsize=(5.2, 3.4))
    ax = fig.add_subplot(111)
    for series in rel_by_band:
        if not series:
            continue
        length = min(len(series), len(distances))
        if length <= 1:
            continue
        ax.plot(distances[:length], series[:length], lw=0.7, alpha=0.6)
    if distances and v_idx[0] < len(rel_by_band) and v_idx[1] < len(distances) and v_idx[1] < len(rel_by_band[v_idx[0]]):
        ax.scatter([distances[v_idx[1]]], [rel_by_band[v_idx[0]][v_idx[1]]], s=28, label=f"VBM m*_h≈{mh_star:.2f} m_e")
    if distances and c_idx[0] < len(rel_by_band) and c_idx[1] < len(distances) and c_idx[1] < len(rel_by_band[c_idx[0]]):
        ax.scatter([distances[c_idx[1]]], [rel_by_band[c_idx[0]][c_idx[1]]], s=28, label=f"CBM m*_e≈{me_star:.2f} m_e")
    ax.axhline(0.0, lw=1.0, ls="--")
    ax.set_ylabel("E - E$_F$ (eV)")
    apply_style(ax, style)
    ax.legend(fontsize=9, frameon=False)
    fig.tight_layout()
    fig_path = figs_dir / "effective_mass.png"
    fig.savefig(fig_path, dpi=POST_FIG_DPI)

    csv_path = tables_dir / "effective_mass.csv"
    with csv_path.open("w", encoding="utf-8") as fh:
        fh.write("edge,band_index,k_index,m*/m_e\n")
        fh.write(f"VBM,{v_idx[0]},{v_idx[1]},{mh_star:.6f}\n")
        fh.write(f"CBM,{c_idx[0]},{c_idx[1]},{me_star:.6f}\n")

    metrics = {"mh*": float(mh_star), "me*": float(me_star)}
    notes = [
        "m* 为路径方向的一维近似，建议在关键方向上复核。",
        f"拟合窗口 ±{window} 个 k 点，可在界面调整。",
    ]
    return PostResult(metrics=metrics, figs={"effective_mass": fig_path}, tables={"effective_mass": csv_path}, notes=notes)


register_postproc(PostProc(name="emass", needs=["vasprun.xml|EIGENVAL"], runner=proc_effective_mass))


def _parse_locpot_planar_z(locpot: Path) -> Optional[tuple[list[float], list[float]]]:
    if not HAS_NUMPY:
        return None
    import numpy as _np

    text = read_text(locpot)
    if not text:
        return None
    lines = text.splitlines()
    if len(lines) < 20:
        return None
    try:
        scale = float(lines[1].strip())
        a1 = [float(x) for x in lines[2].split()[:3]]
        a2 = [float(x) for x in lines[3].split()[:3]]
        a3 = [float(x) for x in lines[4].split()[:3]]
    except Exception:
        return None
    idx = 5
    counts = None
    if idx < len(lines) and re.match(r"^[A-Za-z]", lines[idx].strip() or ""):
        idx += 1
    if idx >= len(lines):
        return None
    try:
        counts = [int(x) for x in lines[idx].split()]
    except Exception:
        return None
    idx += 1
    if idx < len(lines) and lines[idx].strip().lower().startswith("selective"):
        idx += 1
    if idx < len(lines):
        mode = lines[idx].strip().lower()
        if mode.startswith("direct") or mode.startswith("cart"):
            idx += 1
    natoms = sum(counts) if counts else 0
    idx += natoms
    if idx >= len(lines):
        return None
    try:
        nx, ny, nz = map(int, lines[idx].split()[:3])
    except Exception:
        return None
    idx += 1
    values: list[float] = []
    while idx < len(lines):
        s = lines[idx].strip()
        if s:
            try:
                values.extend([float(x) for x in s.split()])
            except Exception:
                pass
        idx += 1
    arr = _np.array(values, dtype=float)
    if arr.size != nx * ny * nz:
        return None
    arr = arr.reshape((nz, ny, nx))
    planar = arr.mean(axis=(1, 2))
    lattice = _np.array([a1, a2, a3], dtype=float) * scale
    c_len = float(_np.linalg.norm(lattice[2]))
    z = [c_len * i / nz for i in range(nz)]
    return z, planar.tolist()


def proc_planar_potential(workdir: Path, opts: Dict[str, Any]) -> PostResult:

    style = _normalize_style(opts.get("style"))
    report_dir, figs_dir, tables_dir = _ensure_report_dirs(workdir, opts)
    demo_payload = opts.get("demo_payload") if isinstance(opts.get("demo_payload"), dict) else None

    if demo_payload:
        z = [float(v) for v in demo_payload.get("z", [])]
        values = [float(v) for v in demo_payload.get("values", [])]
        if not z or not values:
            raise RuntimeError("演示数据缺少平面势信息，无法绘制。")
    else:
        if not HAS_NUMPY:
            raise RuntimeError("需要 numpy 才能解析平面平均势，请安装 numpy。")


        locpot = workdir / "LOCPOT"
        if not locpot.exists():
            raise FileNotFoundError("未找到 LOCPOT，请在计算中输出局域势。")

        data = _parse_locpot_planar_z(locpot)
        if not data:
            raise RuntimeError("解析 LOCPOT 失败或数据不完整，请确认计算输出了 LOCPOT/CHGCAR 并保持文件完整。")
        z, values = data
        if not values:
            raise RuntimeError("LOCPOT 中未获得平面平均势数据，请检查 LOCPOT 是否写全。")

    baseline = values[0]
    rel = [v - baseline for v in values]

    fig = Figure(figsize=(5.2, 3.2))
    ax = fig.add_subplot(111)
    ax.plot(z, rel, lw=1.4)
    ax.set_xlabel("z (Å)")
    ax.set_ylabel("V(z) - V(0) (eV)")
    apply_style(ax, style)
    fig.tight_layout()
    fig_path = figs_dir / "planar_potential.png"
    fig.savefig(fig_path, dpi=POST_FIG_DPI)

    csv_path = tables_dir / "planar_potential.csv"
    with csv_path.open("w", encoding="utf-8") as fh:
        fh.write("z_A,V_rel_eV\n")
        for zi, val in zip(z, rel):
            fh.write(f"{zi:.6f},{val:.6f}\n")

    metrics = {"V_peak": float(max(rel, default=0.0)), "V_min": float(min(rel, default=0.0))}
    if demo_payload:
        notes = ["演示模式示例平面平均势，展示界面势垒轮廓。"]
    else:
        notes = [
            "平面平均势反映沿 z 的势垒分布，可结合滑动平均进一步分析界面偶极。",
        ]
    return PostResult(metrics=metrics, figs={"planar_potential": fig_path}, tables={"planar_potential": csv_path}, notes=notes)


register_postproc(PostProc(name="pot_z", needs=["LOCPOT"], runner=proc_planar_potential))

# ----------------------------- GUI 组件 ------------------------------------

class SystemStatsMonitor(threading.Thread):
    """后台线程：监视 CPU/进程以及关键文件增长情况。"""

    def __init__(self, workdir: Path, watch_files: list[str] | None, on_update=None):
        super().__init__(daemon=True)
        self.workdir = Path(workdir).expanduser()
        try:
            self.workdir_resolved = self.workdir.resolve()
        except Exception:
            self.workdir_resolved = self.workdir
        self.watch_files = watch_files or []
        self.on_update = on_update  # callback(dict)
        self._stop_event = threading.Event()
        self._prev_cpu = None  # tuple(total, idle)
        self._prev_sizes: dict[Path, int] = {}

    def stop(self):
        self._stop_event.set()

        if self.is_alive():
            try:
                self.join(timeout=2.0)
            except RuntimeError:
                pass

    def run(self):
        while not self._stop_event.is_set():
            stats = self._collect_stats()
            if self.on_update:
                try:
                    self.on_update(stats)
                except Exception:
                    pass
            for _ in range(6):
                if self._stop_event.is_set():
                    break
                time.sleep(0.5)

    def _collect_stats(self) -> dict:
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
        cpu_usage = self._cpu_usage_percent()
        loadavg = self._loadavg()
        files = self._file_stats()
        procs = self._process_stats()
        run_state, run_pids, suggestions = self._run_status(procs, files)
        return {
            "timestamp": timestamp,
            "cpu_usage": cpu_usage,
            "loadavg": loadavg,
            "files": files,
            "processes": procs,
            "run_state": run_state,
            "run_pids": run_pids,
            "suggestions": suggestions,
        }

    def _cpu_usage_percent(self) -> float | None:
        proc_stat = Path("/proc/stat")
        if not proc_stat.exists():
            return None
        try:
            line = proc_stat.read_text().splitlines()[0]
        except Exception:
            return None
        parts = line.split()
        if len(parts) < 5 or parts[0] != "cpu":
            return None
        try:
            values = [float(x) for x in parts[1:]]
        except Exception:
            return None
        idle = values[3]
        total = sum(values)
        if self._prev_cpu is None:
            self._prev_cpu = (total, idle)
            return None
        prev_total, prev_idle = self._prev_cpu
        total_delta = total - prev_total
        idle_delta = idle - prev_idle
        self._prev_cpu = (total, idle)
        if total_delta <= 0:
            return None
        usage = max(0.0, min(100.0, (1.0 - idle_delta / total_delta) * 100.0))
        return usage

    def _loadavg(self) -> tuple[float, float, float] | None:
        if hasattr(os, "getloadavg"):
            try:
                return os.getloadavg()
            except OSError:
                return None
        return None

    def _file_stats(self) -> list[dict]:
        stats = []
        for name in self.watch_files:
            if not name:
                continue
            p = Path(name)
            if not p.is_absolute():
                p = self.workdir / name
            p = p.resolve()
            info = {
                "name": str(p),
                "exists": False,
                "size": 0,
                "delta": 0,
            }
            try:
                if p.exists():
                    size = p.stat().st_size
                    prev = self._prev_sizes.get(p, size)
                    info.update({
                        "exists": True,
                        "size": size,
                        "delta": size - prev,
                    })
                    self._prev_sizes[p] = size
            except Exception:
                pass
            stats.append(info)
        return stats

    def _process_stats(self) -> list[dict]:
        # 限制输出 + 超时，避免在某些系统里 ps 卡住
        try:
            out = subprocess.check_output(
                ["bash", "-lc", "ps -eo pid,%cpu,%mem,cmd --sort=-%cpu | head -n 6"],
                text=True, stderr=subprocess.DEVNULL, timeout=2.0
            )
        except Exception:
            try:
                out = subprocess.check_output(
                    ["ps", "-eo", "pid,%cpu,%mem,cmd"],
                    text=True, stderr=subprocess.DEVNULL, timeout=2.0
                )
                out = "\n".join(out.splitlines()[:6])
            except Exception:
                return []

        lines = out.strip().splitlines()
        procs = []
        for line in lines[1:6]:
            parts = line.split(None, 3)
            if len(parts) < 3:
                continue
            pid, cpu, mem = parts[0], parts[1], parts[2]
            cmd_full = parts[3] if len(parts) >= 4 else ""
            cwd = self._proc_cwd(pid)

            in_project = False
            try:
                if cwd:
                    resolved = Path(cwd).resolve()
                    in_project = (resolved == self.workdir_resolved)
                    if not in_project:
                        try:
                            resolved.relative_to(self.workdir_resolved)
                            in_project = True
                        except Exception:
                            in_project = False
            except Exception:
                in_project = False

            cmd_lower = cmd_full.lower()
            is_vasp = ("vasp" in cmd_lower) or ("mpi" in cmd_lower and "vasp" in cmd_lower)
            procs.append({
                "pid": pid, "cmd": cmd_full.strip(),
                "cpu": cpu, "mem": mem,
                "is_vasp": is_vasp, "cwd": cwd, "in_project": in_project,
            })
        return procs

    def _proc_cwd(self, pid: str) -> str | None:
        proc_path = Path("/proc") / str(pid) / "cwd"
        try:
            return os.readlink(proc_path)
        except Exception:
            return None

    def _run_status(self, procs: list[dict], files: list[dict]) -> tuple[str, list[str], list[str]]:
        run_pids: list[str] = []
        suggestions: list[str] = []
        for proc in procs:
            if proc.get("is_vasp") and proc.get("in_project"):
                run_pids.append(proc.get("pid", ""))
        run_state = "running" if run_pids else "idle"
        if run_pids:
            suggestions.append(
                f"检测到 {len(run_pids)} 个 VASP 相关进程在 {self.workdir} 运行。"
            )
        else:
            suggestions.append("未检测到项目内的 VASP 进程，可检查作业或尝试重新启动。")

        for item in files:
            short = Path(item.get("name", "")).name
            if not item.get("exists"):
                suggestions.append(f"未发现 {short}，请确认计算是否已开始输出。")
            else:
                delta = item.get("delta")
                if isinstance(delta, (int, float)) and delta <= 0 and run_pids:
                    suggestions.append(f"{short} 暂未增长，可稍后再次检查。")
        if len(suggestions) > 5:
            suggestions = suggestions[:5]
        return run_state, run_pids, suggestions

    @classmethod
    def snapshot(cls, workdir: Path, watch_files: list[str] | None) -> dict:
        monitor = cls(workdir, watch_files, on_update=None)
        return monitor._collect_stats()


class PostprocWorker(threading.Thread):
    """后台线程：统一调度后处理任务。"""

    def __init__(self, app: "VaspGUI", key: str, opts: Dict[str, Any]):
        super().__init__(daemon=True)
        self.app = app
        self.key = key
        self.opts = opts

    def run(self):
        app = self.app
        proc = POSTPROCS.get(self.key)
        workdir: Path = self.opts.get("workdir", app.current_project_path())
        if not proc:
            app.after(0, lambda: app._on_postproc_error(self.key, "未注册的后处理任务"))
            return
        try:
            result = proc.runner(workdir, self.opts)
        except FileNotFoundError as exc:
            err_msg = str(exc)
            app.after(0, app._on_postproc_error, self.key, err_msg)
            return
        except Exception as exc:
            err_msg = f"后处理异常：{exc}"
            app.after(0, app._on_postproc_error, self.key, err_msg)
            return
        app.after(0, lambda: app._on_postproc_success(self.key, result, workdir, self.opts))


class EnergyMonitor(threading.Thread):
    """后台线程：周期性解析 OSZICAR，提取 F/E0 能量，供主线程绘图。"""
    def __init__(self, workdir: Path, on_update):
        super().__init__(daemon=True)
        self.workdir = workdir
        self.on_update = on_update  # callback(steps:list[int], energies:list[float])
        self._stop_event = threading.Event()
        self.steps = []
        self.energies = []
        self._last_size = 0
        self._last_pos = 0

    def stop(self):
        self._stop_event.set()
        if self.is_alive():
            try:
                self.join(timeout=2.0)
            except RuntimeError:
                pass

    def run(self):
        osz = self.workdir / "OSZICAR"
        outcar = self.workdir / "OUTCAR"
        while not self._stop_event.is_set():
            try:
                target = None
                if osz.exists() and osz.stat().st_size > 0:
                    target = osz
                elif outcar.exists() and outcar.stat().st_size > 0:
                    target = outcar
                if target:
                    size = target.stat().st_size
                    reset = False
                    if size < self._last_size:
                        reset = True
                        self._last_pos = 0
                        self._last_size = 0
                        self.steps = [];
                        self.energies = []
                    if reset or size > self._last_size:
                        self._parse(target, reset)
                        self._last_size = size
                        if self.on_update:
                            self.on_update(self.steps, self.energies)
            except Exception:
                pass
            time.sleep(1.0)

    def _parse(self, path: Path, reset: bool):
        try:
            with path.open("r", encoding="utf-8", errors="ignore") as f:
                if not reset and self._last_pos:
                    f.seek(self._last_pos)
                else:
                    self.steps = []
                    self.energies = []
                new_pts = 0
                for line in f:
                    val = None
                    m = ENERGY_RX.search(line)
                    if m:
                        val = m.group(1) or m.group(2)
                    else:
                        # 若传入的是 OUTCAR，尝试 TOTEN 兜底
                        m2 = TOTEN_RX.search(line)
                        if m2:
                            val = m2.group(1)
                    if val is not None:
                        try:
                            # Fortran 指数 D 替换为 E
                            e = float(val.replace("D", "E").replace("d", "E"))
                            self.steps.append(len(self.steps) + 1)
                            self.energies.append(e)
                            new_pts += 1
                        except Exception:
                            pass
                self._last_pos = f.tell()
        except Exception:
            return


class VaspGUI(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title(f"{APP_NAME}")
        self.geometry("1200x800")
        if HAS_TTKBOOTSTRAP and tb is not None:
            try:
                tb.Style("cosmo")
            except Exception:
                pass

        self.project_dir = Path.cwd()
        self.proc = None  # subprocess.Popen or None
        self.monitor = None  # EnergyMonitor
        self.sys_monitor = None  # SystemStatsMonitor
        self.run_status_var = tk.StringVar(value="⚪ 未检测")
        self.figure_style_var = tk.StringVar(value="AFM")
        self.emit_report_var = tk.BooleanVar(value=True)
        self.demo_mode = False
        self.demo_project_dir: Path | None = None
        self._pre_demo_project: Path | None = None
        self.run_suggestion_widgets: list[tk.Text] = []
        self.post_results: dict[str, PostResult] = {}
        self.post_latest_reports: dict[str, Path] = {}
        self.overview_items = [
            ("__project__", "项目目录"),
            ("INCAR", "INCAR"),
            ("POSCAR", "POSCAR"),
            ("KPOINTS", "KPOINTS"),
            ("POTCAR", "POTCAR"),
            ("CONTCAR", "CONTCAR"),
            ("vasp.out", "vasp.out"),
            ("OSZICAR", "OSZICAR"),
            ("OUTCAR", "OUTCAR"),
        ]
        self.overview_label_map = {k: label for k, label in self.overview_items}
        self.overview_key_map = {k.lower(): k for k, _ in self.overview_items}

        self._build_ui()
        self.set_project(self.project_dir)

        # 加载历史配置（若存在）
        try:
            self.load_config()
        except Exception:
            pass

    # ------------------------- UI 构建 ----------------------------------
    def _build_ui(self):
        # 顶部工具栏
        toolbar = ttk.Frame(self)
        toolbar.pack(side=tk.TOP, fill=tk.X)

        ttk.Label(toolbar, text="项目目录:").pack(side=tk.LEFT, padx=6)
        self.project_var = tk.StringVar(value=str(self.project_dir))
        self.project_entry = ttk.Entry(toolbar, textvariable=self.project_var, width=80)
        self.project_entry.pack(side=tk.LEFT, padx=4)
        ttk.Button(toolbar, text="选择…", command=self.choose_project).pack(side=tk.LEFT)
        ttk.Button(toolbar, text="新建项目", command=self.create_project).pack(side=tk.LEFT, padx=4)
        ttk.Button(toolbar, text="首次向导", command=self.launch_first_time_wizard).pack(side=tk.LEFT, padx=4)
        ttk.Button(toolbar, text="创建示例项目", command=self.on_create_example_project).pack(side=tk.LEFT, padx=4)
        self.demo_mode_var = tk.BooleanVar(value=False)
        ttk.Checkbutton(toolbar, text="演示模式", variable=self.demo_mode_var, command=self.toggle_demo_mode).pack(side=tk.LEFT, padx=6)

        # Notebook
        self.nb = ttk.Notebook(self)
        self.nb.pack(fill=tk.BOTH, expand=True)

        self.page_inputs = self._build_inputs_page(self.nb)

        # 先把 workflow 会引用到的页面都建好
        self.page_run = self._build_run_page(self.nb)
        self.page_monitor = self._build_monitor_page(self.nb)
        self.page_post = self._build_post_page(self.nb)

        # 最后再建 workflow（里面会引用上面三个）
        self.page_workflow = self._build_workflow_page(self.nb)

        self.nb.add(self.page_inputs, text="输入 / POTCAR / K 点")
        self.nb.add(self.page_workflow, text="流程助手")
        self.nb.add(self.page_run, text="运行 / 提交")
        self.nb.add(self.page_monitor, text="监视")
        self.nb.add(self.page_post, text="后处理")

        # === CODEX BEGIN: add twist/shift tab ===
        self.page_twist = self._build_twistshift_page(self.nb)
        self.nb.add(self.page_twist, text="二维材料·滑移/扭转")
        # 结果演示页：用于快速加载 CSV/JSON 并绘制热图
        self.page_twist_results = self._build_twistshift_results_page(self.nb)
        self.nb.add(self.page_twist_results, text="二维材料·结果演示")
        # === CODEX END: add twist/shift tab ===

        self.protocol("WM_DELETE_WINDOW", self.on_close)

    def toggle_demo_mode(self):
        if self.demo_mode_var.get():
            self._activate_demo_mode()
        else:
            self._deactivate_demo_mode()

    def _activate_demo_mode(self):
        if self.demo_mode:
            return
        self._pre_demo_project = self.current_project_path()
        try:
            demo_dir = self._prepare_demo_project()
        except Exception as exc:
            self.demo_mode_var.set(False)
            messagebox.showerror(APP_NAME, f"演示模式初始化失败：{exc}")
            return
        self.demo_mode = True
        self.demo_project_dir = demo_dir
        self.demo_mode_var.set(True)
        self.set_project(demo_dir)
        try:
            twist_dir = demo_dir / "twist_sweep"
            self._tw_write_demo_results(twist_dir)
        except Exception:
            pass
        try:
            demo_poscar = demo_dir / "POSCAR"
            if demo_poscar.exists():
                self.tw_top_path.set(str(demo_poscar))
                self.tw_bot_path.set(str(demo_poscar))
        except Exception:
            pass
        try:
            self.tw_dir.set(str(twist_dir))
            self._tw_load_dir(twist_dir)
        except Exception:
            pass
        self.apply_run_status("🧪 演示模式", ["已加载内置示例数据，可直接体验全部后处理功能。"])

    def _deactivate_demo_mode(self):
        if not self.demo_mode:
            return
        prev = self._pre_demo_project or Path.cwd()
        self.demo_mode = False
        self.demo_mode_var.set(False)
        self._pre_demo_project = None
        try:
            self.set_project(prev)
        finally:
            self._cleanup_demo_project()
        self.refresh_run_status()

    def _prepare_demo_project(self) -> Path:
        self._cleanup_demo_project()
        demo_root = Path(tempfile.mkdtemp(prefix="vasp_gui_demo_"))
        self._ensure_project_scaffold(demo_root)
        for name, content in DEMO_PROJECT_FILES.items():
            try:
                write_text(demo_root / name, content)
            except Exception:
                pass
        (demo_root / "reports").mkdir(parents=True, exist_ok=True)
        return demo_root

    def _cleanup_demo_project(self):
        demo_dir = self.demo_project_dir
        if demo_dir and demo_dir.exists():
            try:
                shutil.rmtree(demo_dir)
            except Exception:
                pass
        self.demo_project_dir = None

    # ------------------------- 页面：输入文件 -----------------------------
    def _build_inputs_page(self, parent):
        frame = ttk.Frame(parent)

        # 外层滚动容器，确保内容较多时仍可完整浏览
        canvas = tk.Canvas(frame, highlightthickness=0)
        vscroll = ttk.Scrollbar(frame, orient=tk.VERTICAL, command=canvas.yview)
        canvas.configure(yscrollcommand=vscroll.set)
        canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        vscroll.pack(side=tk.RIGHT, fill=tk.Y)

        inner = ttk.Frame(canvas)
        inner_id = canvas.create_window((0, 0), window=inner, anchor="nw")

        def _update_scrollregion(event=None):
            canvas.configure(scrollregion=canvas.bbox("all"))

        def _sync_inner_width(event):
            canvas.itemconfigure(inner_id, width=event.width)

        inner.bind("<Configure>", _update_scrollregion)
        canvas.bind("<Configure>", _sync_inner_width)

        def _on_mousewheel(event):
            if isinstance(event.widget, tk.Text):
                return
            delta = 0
            if event.delta:
                delta = -int(event.delta / 120)
            elif getattr(event, "num", None) in (4, 5):
                delta = -1 if event.num == 4 else 1
            if delta:
                canvas.yview_scroll(delta, "units")

        def _bind_mousewheel(widget):
            def _on_enter(_event):
                canvas.bind_all("<MouseWheel>", _on_mousewheel)
                canvas.bind_all("<Button-4>", _on_mousewheel)
                canvas.bind_all("<Button-5>", _on_mousewheel)

            def _on_leave(_event):
                canvas.unbind_all("<MouseWheel>")
                canvas.unbind_all("<Button-4>")
                canvas.unbind_all("<Button-5>")

            widget.bind("<Enter>", _on_enter)
            widget.bind("<Leave>", _on_leave)

        _bind_mousewheel(inner)

        paned = ttk.PanedWindow(inner, orient=tk.HORIZONTAL)
        paned.pack(fill=tk.BOTH, expand=True, padx=8, pady=8)

        # 左边：INCAR 模板
        left = ttk.Frame(paned, padding=8)
        paned.add(left, weight=1)

        ttk.Label(left, text="INCAR 模板与编辑").pack(anchor=tk.W)
        temp_bar = ttk.Frame(left)
        temp_bar.pack(fill=tk.X, pady=4)
        self.incar_template = tk.StringVar(value="relax")
        for key, txt in [
            ("relax", "几何优化"),
            ("static", "静态自洽"),
            ("dos", "态密度"),
            ("bands", "能带预设"),
        ]:
            ttk.Radiobutton(temp_bar, text=txt, value=key, variable=self.incar_template, command=self.load_incar_template).pack(side=tk.LEFT)
        ttk.Button(temp_bar, text="加载模板到编辑器", command=self.load_incar_template).pack(side=tk.RIGHT)

        # INCAR 简单面板
        simple_box = ttk.LabelFrame(left, text="INCAR 简单面板")
        simple_box.pack(fill=tk.X, pady=4)
        self.incar_simple_vars: dict[str, tk.StringVar] = {}
        simple_items = [
            ("ENCUT", "ENCUT (eV)"),
            ("EDIFF", "EDIFF"),
            ("EDIFFG", "EDIFFG"),
            ("ISMEAR", "ISMEAR"),
            ("SIGMA", "SIGMA"),
            ("KSPACING", "KSPACING"),
            ("NSW", "NSW"),
        ]
        for idx, (key, label) in enumerate(simple_items):
            row = idx // 2
            col = idx % 2
            frame_cell = ttk.Frame(simple_box)
            frame_cell.grid(row=row, column=col, sticky="ew", padx=4, pady=2)
            ttk.Label(frame_cell, text=label + ":").pack(side=tk.LEFT)
            var = tk.StringVar()
            self.incar_simple_vars[key] = var
            entry = ttk.Entry(frame_cell, textvariable=var, width=12)
            entry.pack(side=tk.LEFT, padx=4)
        for i in range(2):
            simple_box.grid_columnconfigure(i, weight=1)
        btn_row = ttk.Frame(simple_box)
        btn_row.grid(row=(len(simple_items)+1)//2, column=0, columnspan=2, sticky="ew", pady=(4, 0))
        ttk.Button(btn_row, text="从编辑器读取", command=self.refresh_incar_simple_panel).pack(side=tk.LEFT)
        ttk.Button(btn_row, text="写入到编辑器", command=self.apply_incar_simple_panel).pack(side=tk.LEFT, padx=6)

        self.incar_text = ScrolledText(left, height=20, undo=True, wrap="none")
        self.incar_text.pack(fill=tk.BOTH, expand=True)
        btns = ttk.Frame(left)
        btns.pack(fill=tk.X, pady=4)
        ttk.Button(btns, text="打开现有 INCAR", command=lambda: self.open_into_editor("INCAR", self.incar_text)).pack(side=tk.LEFT)
        ttk.Button(btns, text="保存到项目", command=lambda: self.save_from_editor("INCAR", self.incar_text)).pack(side=tk.LEFT, padx=6)

        # 右边：POSCAR & KPOINTS 编辑
        right = ttk.Frame(paned, padding=8)
        paned.add(right, weight=1)

        ttk.Label(right, text="POSCAR 编辑").pack(anchor=tk.W)
        self.poscar_text = ScrolledText(right, height=10, undo=True, wrap="none")
        self.poscar_text.pack(fill=tk.BOTH, expand=True)
        row = ttk.Frame(right)
        row.pack(fill=tk.X, pady=4)
        ttk.Button(row, text="打开 POSCAR", command=lambda: self.open_into_editor("POSCAR", self.poscar_text)).pack(side=tk.LEFT)
        ttk.Button(row, text="保存 POSCAR", command=lambda: self.save_from_editor("POSCAR", self.poscar_text)).pack(side=tk.LEFT, padx=6)
        ttk.Button(row, text="从 POSCAR 解析元素", command=self.show_poscar_elements).pack(side=tk.LEFT, padx=6)

        ttk.Separator(right, orient=tk.HORIZONTAL).pack(fill=tk.X, pady=6)

        ttk.Label(right, text="KPOINTS 编辑（可在K 点生成页自动生成）").pack(anchor=tk.W)
        self.kpoints_text = ScrolledText(right, height=10, undo=True, wrap="none")
        self.kpoints_text.pack(fill=tk.BOTH, expand=True)
        row2 = ttk.Frame(right)
        row2.pack(fill=tk.X, pady=4)
        ttk.Button(row2, text="打开 KPOINTS", command=lambda: self.open_into_editor("KPOINTS", self.kpoints_text)).pack(side=tk.LEFT)
        ttk.Button(row2, text="保存 KPOINTS", command=lambda: self.save_from_editor("KPOINTS", self.kpoints_text)).pack(side=tk.LEFT, padx=6)

        ttk.Separator(inner, orient=tk.HORIZONTAL).pack(fill=tk.X, padx=8, pady=6)

        potcar_box = ttk.LabelFrame(inner, text="POTCAR 赝势")
        potcar_box.pack(fill=tk.BOTH, expand=False, padx=8, pady=4)
        self._populate_potcar_section(potcar_box)

        ttk.Separator(inner, orient=tk.HORIZONTAL).pack(fill=tk.X, padx=8, pady=6)

        kpoints_box = ttk.LabelFrame(inner, text="K 点生成")
        kpoints_box.pack(fill=tk.BOTH, expand=False, padx=8, pady=4)
        self._populate_kpoints_section(kpoints_box)

        # 默认加载模板并同步简单面板
        self.load_incar_template()
        self.refresh_incar_simple_panel()
        return frame

    def load_incar_template(self):
        tpl = self.incar_template.get()
        presets = {
            "relax": (
                """# ==== 几何优化（PBE）====\nSYSTEM = relax\nENCUT = 520\nPREC  = Accurate\nEDIFF = 1e-6\nEDIFFG = -0.02\nISMEAR = 0\nSIGMA  = 0.05\nIBRION = 2\nISIF   = 3\nNSW    = 100\nISPIN  = 1\nLREAL  = Auto\n# 可选：KSPACING = 0.22\n"""
            ),
            "static": (
                """# ==== 静态自洽（SCF）====\nSYSTEM = scf\nENCUT = 520\nPREC  = Accurate\nEDIFF = 1e-6\nISMEAR = 0\nSIGMA  = 0.05\nIBRION = -1\nNSW    = 0\nLREAL  = Auto\nLWAVE  = .FALSE.\nLCHARG = .TRUE.\n# 可选：KSPACING = 0.22\n"""
            ),
            "dos": (
                """# ==== DOS 计算（在已收敛电荷上）====\nSYSTEM = dos\nENCUT = 520\nPREC  = Accurate\nEDIFF = 1e-6\nISMEAR = 0\nSIGMA  = 0.05\nIBRION = -1\nNSW    = 0\nLORBIT = 11\nNEDOS  = 2000\nLCHARG = .TRUE.\nLWAVE  = .FALSE.\n# 可选：KSPACING = 0.18\n"""
            ),
            "bands": (
                """# ==== 能带预设（非自洽）====\nSYSTEM = bands\nENCUT = 520\nPREC  = Accurate\nEDIFF = 1e-6\nISMEAR = 0\nSIGMA  = 0.05\nIBRION = -1\nNSW    = 0\nICHARG = 11\nLORBIT = 11\nLCHARG = .FALSE.\nLWAVE  = .TRUE.\n# KPOINTS 请使用路径方式或外部生成器\n"""
            ),
        }
        self.incar_text.delete("1.0", tk.END)
        self.incar_text.insert("1.0", presets.get(tpl, presets["relax"]))
        self.refresh_incar_simple_panel()

    def refresh_incar_simple_panel(self):
        if not hasattr(self, "incar_simple_vars"):
            return
        text = self.incar_text.get("1.0", tk.END)
        values: dict[str, str] = {}
        for line in text.splitlines():
            stripped = line.strip()
            if not stripped or stripped.startswith("#"):
                continue
            m = re.match(r"([A-Za-z0-9_+-]+)\s*=\s*(.+)", stripped)
            if m:
                key = m.group(1).upper()
                values[key] = m.group(2).strip()
        for key, var in self.incar_simple_vars.items():
            var.set(values.get(key, ""))

    def apply_incar_simple_panel(self):
        if not hasattr(self, "incar_simple_vars"):
            return
        updates = {}
        for key, var in self.incar_simple_vars.items():
            val = var.get().strip()
            updates[key] = val
        text = self.incar_text.get("1.0", tk.END)
        new_text = self._update_incar_text(text, updates)
        self.incar_text.delete("1.0", tk.END)
        self.incar_text.insert("1.0", new_text)
        self.refresh_incar_simple_panel()

    @staticmethod
    def _update_incar_text(text: str, updates: dict[str, str]) -> str:
        keys = {k.upper(): v for k, v in updates.items()}
        lines = text.splitlines()
        new_lines: list[str] = []
        handled: set[str] = set()
        for line in lines:
            stripped = line.strip()
            if not stripped or stripped.startswith("#"):
                new_lines.append(line)
                continue
            m = re.match(r"([A-Za-z0-9_+-]+)\s*=", stripped)
            if m:
                key = m.group(1).upper()
                if key in keys:
                    val = keys[key]
                    if val:
                        new_lines.append(f"{key} = {val}")
                    handled.add(key)
                    continue
            new_lines.append(line)
        for key, val in keys.items():
            if not val or key in handled:
                continue
            new_lines.append(f"{key} = {val}")
        result = "\n".join(new_lines)
        if result and not result.endswith("\n"):
            result += "\n"
        return result

    def launch_first_time_wizard(self):
        profile = self.run_first_time_wizard()
        if profile:
            self.apply_profile_to_project(profile)

    def run_first_time_wizard(self) -> WizardProfile | None:
        dialog = FirstTimeWizard(self)
        self.wait_window(dialog)
        return getattr(dialog, "result", None)

    def apply_profile_to_project(self, profile: WizardProfile, project_path: Path | None = None) -> None:
        proj = self.current_project_path() if project_path is None else Path(project_path)
        try:
            proj = proj.expanduser()
        except Exception:
            proj = Path(proj)
        proj.mkdir(parents=True, exist_ok=True)
        self._ensure_project_scaffold(proj)

        smear_defaults = {"metal": (1, 0.2), "semiconductor": (0, 0.05), "insulator": (0, 0.05)}
        isme, sigma = smear_defaults.get(profile.system_type, (0, 0.05))
        encut_value = profile.encut_value or 520
        encut_comment = ""
        if profile.encut_strategy == "auto" and profile.encut_value is None:
            encut_comment = "# ENCUT ≈ 1.3×ENMAX_max，已使用默认值 520"

        incar_lines = [
            "# === Generated by wizard ===",
            f"# Workflow: {profile.workflow}",
        ]
        if encut_comment:
            incar_lines.append(encut_comment)
        incar_lines.extend([
            f"SYSTEM = {proj.name}",
            f"ENCUT = {encut_value}",
            "PREC  = Accurate",
            "EDIFF = 1e-6",
        ])
        if profile.workflow.startswith("relax"):
            incar_lines.extend(["IBRION = 2", "ISIF   = 3", "NSW    = 80"])
        else:
            incar_lines.extend(["IBRION = -1", "NSW    = 0"])
        incar_lines.extend([
            f"ISMEAR = {isme}",
            f"SIGMA  = {sigma}",
            "LREAL  = Auto",
            "LWAVE  = .FALSE.",
            "LCHARG = .TRUE.",
        ])

        if profile.k_mode == "kspacing":
            kspacing = profile.kspacing or 0.22
            incar_lines.append(f"KSPACING = {kspacing}")
            kpoints_text = (
                f"# 使用 KSPACING = {kspacing}\n"
                "# 若需 Monkhorst 网格请替换为标准 KPOINTS 文件\n"
            )
        else:
            grid = profile.kgrid or (6, 6, 6)
            kpoints_text = gen_kpoints_monkhorst(grid[0], grid[1], grid[2], True)

        write_text(proj / "INCAR", "\n".join(filter(None, incar_lines)) + "\n")
        if not (proj / "POSCAR").exists():
            write_text(proj / "POSCAR", DEFAULT_POSCAR_TEMPLATE)
        write_text(proj / "KPOINTS", kpoints_text)

        self.figure_style_var.set(profile.figure_style)
        self.emit_report_var.set(bool(profile.emit_report))
        try:
            self.mpi_np.set(int(profile.np))
        except Exception:
            pass

        self.run_mode.set("slurm" if profile.use_slurm else "local")
        slurm_cfg = profile.slurm or {}
        self.slurm_part.set(slurm_cfg.get("partition", self.slurm_part.get()))
        self.slurm_time.set(slurm_cfg.get("time", self.slurm_time.get()))
        try:
            self.slurm_nodes.set(int(slurm_cfg.get("nodes", self.slurm_nodes.get())))
        except Exception:
            pass
        try:
            ntasks = int(slurm_cfg.get("ntasks", profile.np))
            self.slurm_ntasks.set(ntasks)
        except Exception:
            pass
        self.slurm_account.set(slurm_cfg.get("account", self.slurm_account.get()))

        self.last_wizard_profile = profile
        self.set_project(proj)
        try:
            self.write_job_script()
        except Exception:
            pass
        try:
            self.save_config()
        except Exception:
            pass

    def create_example_project(self, name: str = "example_Si") -> Path:
        root = Path.home() / "vasp_gui_projects"
        root.mkdir(parents=True, exist_ok=True)
        candidate = root / name
        idx = 1
        while candidate.exists():
            candidate = root / f"{name}_{idx:02d}"
            idx += 1
        style = _normalize_style(self.figure_style_var.get())
        profile = WizardProfile(
            system_type="semiconductor",
            workflow="relax_scf_dos",
            encut_strategy="auto",
            encut_value=None,
            k_mode="kpoints",
            kspacing=None,
            kgrid=(6, 6, 6),
            use_slurm=False,
            np=max(1, self._int_from_var(self.mpi_np, 8)),
            slurm={},
            figure_style=style,
            emit_report=True,
        )
        self.apply_profile_to_project(profile, project_path=candidate)
        write_text(candidate / "POSCAR", EXAMPLE_SI_POSCAR)
        write_text(candidate / "INCAR", EXAMPLE_SI_INCAR)
        write_text(candidate / "KPOINTS", EXAMPLE_SI_KPOINTS)
        self.load_project_inputs()
        self._create_example_figures(candidate, style)
        return candidate

    def on_create_example_project(self):
        try:
            path = self.create_example_project()
        except Exception as exc:
            messagebox.showerror(APP_NAME, f"示例项目创建失败：{exc}")
            return
        messagebox.showinfo(APP_NAME, f"示例项目已创建：{path}")

    def _create_example_figures(self, proj: Path, style: str) -> None:
        fig_dir = proj / "figures"
        plots_dir = proj / "plots"
        fig_dir.mkdir(parents=True, exist_ok=True)
        plots_dir.mkdir(parents=True, exist_ok=True)

        energies = [i * 0.1 for i in range(-40, 41)]
        dos_vals = [max(0.0, 6.0 * math.exp(-((e) / 0.9) ** 2) - 0.15) for e in energies]
        fig = Figure(figsize=(4.0, 3.0), dpi=150)
        ax = fig.add_subplot(111)
        lw = FIG_STYLES.get(style, FIG_STYLES["AFM"]).get("linew", 1.2)
        ax.plot(energies, dos_vals, color="#1f77b4", linewidth=lw)
        ax.axvline(0.0, color="#444444", linestyle="--", linewidth=0.9)
        ax.set_xlabel("Energy (eV)")
        ax.set_ylabel("Total DOS (states/eV)")
        ax.set_title("Example DOS")
        apply_style(ax, style)
        fig.tight_layout()
        dos_png = fig_dir / "dos_demo.png"
        dos_svg = fig_dir / "dos_demo.svg"
        fig.savefig(dos_png, dpi=300)
        fig.savefig(dos_svg)
        with (fig_dir / "dos_demo.csv").open("w", encoding="utf-8") as f:
            f.write("energy_eV,total_dos\n")
            for e, d in zip(energies, dos_vals):
                f.write(f"{e:.3f},{d:.6f}\n")

        k_points = [i / 10 for i in range(11)]
        valence = [-0.5 + 0.25 * math.cos(math.pi * x) for x in k_points]
        conduction = [0.5 + 0.35 * math.cos(math.pi * x) for x in k_points]
        gap = min(conduction) - max(valence)
        fig2 = Figure(figsize=(4.0, 3.0), dpi=150)
        ax2 = fig2.add_subplot(111)
        ax2.plot(k_points, valence, color="#d62728", linewidth=lw)
        ax2.plot(k_points, conduction, color="#2ca02c", linewidth=lw)
        ax2.fill_between(k_points, valence, conduction, where=[c > v for c, v in zip(conduction, valence)], color="#cccccc", alpha=0.3)
        ax2.set_xlabel("k-path (arb.)")
        ax2.set_ylabel("Energy (eV)")
        ax2.set_title("Example Bands")
        ax2.text(0.02, 0.9, f"Gap ≈ {gap:.2f} eV", transform=ax2.transAxes)
        ax2.axhline(0.0, color="#444444", linestyle="--", linewidth=0.9)
        apply_style(ax2, style)
        fig2.tight_layout()
        band_png = fig_dir / "bands_demo.png"
        band_svg = fig_dir / "bands_demo.svg"
        fig2.savefig(band_png, dpi=300)
        fig2.savefig(band_svg)
        with (fig_dir / "bands_demo.csv").open("w", encoding="utf-8") as f:
            f.write("k_index,valence_eV,conduction_eV\n")
            for idx, (k, v, c) in enumerate(zip(k_points, valence, conduction)):
                f.write(f"{idx},{v:.6f},{c:.6f}\n")

        try:
            shutil.copyfile(dos_png, plots_dir / dos_png.name)
        except Exception:
            pass
        try:
            shutil.copyfile(band_png, plots_dir / band_png.name)
        except Exception:
            pass

        manifest = {"figures": [
            {"name": "dos_demo", "files": {"png": dos_png.name, "svg": dos_svg.name, "csv": "dos_demo.csv"}},
            {"name": "bands_demo", "files": {"png": band_png.name, "svg": band_svg.name, "csv": "bands_demo.csv"}},
        ]}
        (fig_dir / "manifest.json").write_text(json.dumps(manifest, ensure_ascii=False, indent=2), encoding="utf-8")

    def _ensure_project_scaffold(self, proj: Path) -> None:
        for name in ("plots", "snapshots", "figures", "reports"):
            try:
                (proj / name).mkdir(parents=True, exist_ok=True)
            except Exception:
                pass

    def open_into_editor(self, name: str, editor: tk.Text):
        proj = self.current_project_path()
        candidate = proj / name
        path = None
        if candidate.exists():
            path = candidate
        else:
            p = filedialog.askopenfilename(
                initialdir=self.project_dir,
                title=f"打开 {name}",
                filetypes=[(name, name), ("全部", "*")],
            )
            if not p:
                return
            path = Path(p)
        if path is None:
            path = candidate
        try:
            s = read_text(path)
            editor.delete("1.0", tk.END)
            editor.insert("1.0", s)
            if editor is getattr(self, "incar_text", None):
                self.refresh_incar_simple_panel()
        except Exception as e:
            messagebox.showerror(APP_NAME, f"读取失败：{e}")

    def save_from_editor(self, name: str, editor: tk.Text):
        proj = self.current_project_path()
        proj.mkdir(parents=True, exist_ok=True)
        p = proj / name
        try:
            write_text(p, editor.get("1.0", tk.END))
            messagebox.showinfo(APP_NAME, f"已保存 {name} -> {p}")
            self.refresh_project_overview()
        except Exception as e:
            messagebox.showerror(APP_NAME, f"保存失败：{e}")

    def show_poscar_elements(self):
        s = self.poscar_text.get("1.0", tk.END)
        elems = unique_elements_from_poscar(s)
        if elems:
            messagebox.showinfo(APP_NAME, f"POSCAR 元素：{', '.join(elems)}")
        else:
            messagebox.showwarning(APP_NAME, "未解析到元素，请检查第6/7行。")

    # ------------------------- 页面：POTCAR --------------------------------
    def _populate_potcar_section(self, container):
        row1 = ttk.Frame(container)
        row1.pack(fill=tk.X, padx=8, pady=8)
        ttk.Label(row1, text="赝势库根目录：").pack(side=tk.LEFT)
        self.pot_dir_var = tk.StringVar(value=str(Path.home() / "potcars"))
        ttk.Entry(row1, textvariable=self.pot_dir_var, width=80).pack(side=tk.LEFT, padx=6)
        ttk.Button(row1, text="选择…", command=self.choose_pot_dir).pack(side=tk.LEFT)
        ttk.Button(row1, text="探测赝势库", command=self.detect_pot_roots).pack(side=tk.LEFT, padx=6)

        row2 = ttk.Frame(container)
        row2.pack(fill=tk.X, padx=8, pady=4)
        ttk.Label(row2, text="从 POSCAR 自动解析元素并生成 POTCAR：").pack(side=tk.LEFT)
        ttk.Button(row2, text="生成 POTCAR", command=self.do_build_potcar).pack(side=tk.LEFT, padx=8)

        self.pot_msg = ScrolledText(container, height=12, wrap="word")
        self.pot_msg.pack(fill=tk.BOTH, expand=True, padx=8, pady=8)

        return container

    def _build_potcar_page(self, parent):
        frame = ttk.Frame(parent)
        self._populate_potcar_section(frame)
        return frame

    def choose_pot_dir(self):
        d = filedialog.askdirectory(initialdir=self.pot_dir_var.get(), title="选择赝势库根目录")
        if d:
            self.pot_dir_var.set(d)

    def do_build_potcar(self):
        proj = self.current_project_path()
        pos = proj / "POSCAR"
        if not pos.exists():
            # 尝试从编辑器
            s = self.poscar_text.get("1.0", tk.END).strip()
            if s:
                write_text(pos, s)
            else:
                messagebox.showwarning(APP_NAME, "项目目录中不存在 POSCAR，且编辑器为空。")
                return
        elems, _ = parse_poscar(read_text(pos))
        if not elems:
            messagebox.showwarning(APP_NAME, "未从 POSCAR 解析到元素。")
            return
        pot_base = Path(self.pot_dir_var.get())
        selections: list[Path] = []
        for e in elems:
            cands = find_potcar_candidates(e, pot_base)
            if not cands:
                msg = f"未找到元素 {e} 的 POTCAR（在 {pot_base} 下）。"
                self.pot_msg.insert(tk.END, msg + "\n")
                messagebox.showerror(APP_NAME, msg)
                return
            if len(cands) == 1:
                selected = cands[0]
            else:
                options = [str(p) for p in cands]
                sel = self.select_from_list(f"选择 {e} 的 POTCAR", options)
                if not sel:
                    cancel_msg = f"已取消 {e} 的 POTCAR 选择，终止生成。"
                    self.pot_msg.insert(tk.END, cancel_msg + "\n")
                    messagebox.showinfo(APP_NAME, cancel_msg)
                    return
                selected = Path(sel)
            selections.append(selected)
            self.pot_msg.insert(tk.END, f"{e}: 使用 {selected}\n")
            self.pot_msg.see(tk.END)
        ok, msg = build_potcar(selections, proj / "POTCAR")
        self.pot_msg.insert(tk.END, (msg + "\n"))
        self.pot_msg.see(tk.END)
        if not ok:
            messagebox.showerror(APP_NAME, msg)
        else:
            messagebox.showinfo(APP_NAME, msg)
            self.refresh_project_overview()

    # --------- 赝势库探测与选择 ---------
    def detect_pot_roots(self):
        cands = self.scan_pot_roots(limit=30)
        if not cands:
            messagebox.showwarning(APP_NAME, "未在常见位置发现赝势库候选。你也可以手动选择根目录。")
            return
        if len(cands) == 1:
            self.pot_dir_var.set(cands[0])
            messagebox.showinfo(APP_NAME, f"已设置赝势库根目录：\n{cands[0]}")
            return
        sel = self.select_from_list("选择赝势库根目录", cands)
        if sel:
            self.pot_dir_var.set(sel)

    def select_from_list(self, title, items):
        top = tk.Toplevel(self)
        top.title(title)
        top.geometry("720x380")
        lb = tk.Listbox(top, selectmode=tk.SINGLE)
        for it in items:
            lb.insert(tk.END, it)
        lb.pack(fill=tk.BOTH, expand=True, padx=8, pady=8)
        sel = {"val": None}
        def ok():
            try:
                i = lb.curselection()
                sel["val"] = items[i[0]] if i else None
            except Exception:
                sel["val"] = None
            top.destroy()
        ttk.Button(top, text="使用选中", command=ok).pack(pady=6)
        top.transient(self); top.grab_set(); self.wait_window(top)
        return sel["val"]

    def scan_pot_roots(self, limit=20):
        bases = []
        # 当前设置与常见路径为起点
        try:
            bases.append(Path(self.pot_dir_var.get()).expanduser())
        except Exception:
            pass
        for p in [Path.home()/"potcars", Path.home()/"vasp", Path.home()/"apps", Path.home()/"Downloads", Path.home()/"下载", Path("/opt/vasp"), Path("/usr/local/share/vasp"), Path("/mnt/c/Users")]:
            if p.exists():
                bases.append(p)
        seen = set(); cands = []
        def looks_like_root(d: Path):
            try:
                cnt = 0
                for child in d.iterdir():
                    if child.is_dir() and (child/"POTCAR").exists():
                        cnt += 1
                        if cnt >= 3:
                            return True
                return False
            except Exception:
                return False
        # BFS 限深 3
        from collections import deque
        for base in list(dict.fromkeys(bases)):
            if not base.exists():
                continue
            q = deque([(base, 0)])
            while q and len(cands) < limit:
                cur, dep = q.popleft()
                try:
                    key = str(cur.resolve())
                except Exception:
                    key = str(cur)
                if key in seen:
                    continue
                seen.add(key)
                if looks_like_root(cur):
                    cands.append(key)
                if dep < 3:
                    try:
                        for ch in cur.iterdir():
                            if ch.is_dir():
                                q.append((ch, dep+1))
                    except Exception:
                        pass
        # 去重与排序（包含关键词的优先）
        def score(path):
            name = path.lower(); s = 0
            for kw in ("potpaw","paw","pbe","lda","potential","psp"):
                if kw in name:
                    s += 1
            return (-s, len(path))
        cands = sorted(list(dict.fromkeys(cands)), key=score)
        return cands[:limit]

    # ------------------------- 页面：KPOINTS -------------------------------
    def _populate_kpoints_section(self, container):
        box = ttk.LabelFrame(container, text="Monkhorst-Pack 网格")
        box.pack(fill=tk.X, padx=8, pady=8)

        self.k_nx = tk.IntVar(value=5)
        self.k_ny = tk.IntVar(value=5)
        self.k_nz = tk.IntVar(value=5)
        self.k_gamma = tk.BooleanVar(value=True)

        row = ttk.Frame(box)
        row.pack(fill=tk.X, pady=4)
        ttk.Label(row, text="Nx").pack(side=tk.LEFT)
        ttk.Spinbox(row, from_=1, to=50, textvariable=self.k_nx, width=5).pack(side=tk.LEFT, padx=6)
        ttk.Label(row, text="Ny").pack(side=tk.LEFT)
        ttk.Spinbox(row, from_=1, to=50, textvariable=self.k_ny, width=5).pack(side=tk.LEFT, padx=6)
        ttk.Label(row, text="Nz").pack(side=tk.LEFT)
        ttk.Spinbox(row, from_=1, to=50, textvariable=self.k_nz, width=5).pack(side=tk.LEFT, padx=6)
        ttk.Checkbutton(box, text="Gamma 中心", variable=self.k_gamma).pack(anchor=tk.W, padx=8)

        btns = ttk.Frame(container)
        btns.pack(fill=tk.X, padx=8, pady=4)
        ttk.Button(btns, text="生成到编辑器", command=self.kpoints_to_editor).pack(side=tk.LEFT)
        ttk.Button(btns, text="保存到项目(KPOINTS)", command=self.kpoints_save).pack(side=tk.LEFT, padx=8)

        tip = ttk.Label(container, text="提示：也可在 INCAR 使用 KSPACING，省去 KPOINTS（VASP 5.4.4+）")
        tip.pack(anchor=tk.W, padx=12, pady=4)

        return container

    def _build_kpoints_page(self, parent):
        frame = ttk.Frame(parent)
        self._populate_kpoints_section(frame)
        return frame

    # === CODEX BEGIN: twist/shift helpers ===
    def _show_help_dialog(self, title: str, message: str) -> None:
        """弹出一个带滚动文本的帮助对话框。"""
        dialog = tk.Toplevel(self)
        dialog.title(title)
        dialog.transient(self)
        dialog.resizable(True, True)
        dialog.grab_set()

        frame = ttk.Frame(dialog, padding=12)
        frame.pack(fill=tk.BOTH, expand=True)

        text = ScrolledText(frame, wrap=tk.WORD, width=68, height=20)
        text.insert(tk.END, message)
        text.configure(state=tk.DISABLED)
        text.pack(fill=tk.BOTH, expand=True)

        btn_row = ttk.Frame(frame)
        btn_row.pack(fill=tk.X, pady=(12, 0))
        ttk.Button(btn_row, text="关闭", command=dialog.destroy).pack(side=tk.RIGHT)

        dialog.update_idletasks()
        try:
            self.update_idletasks()
            w = dialog.winfo_width()
            h = dialog.winfo_height()
            x = self.winfo_rootx() + (self.winfo_width() - w) // 2
            y = self.winfo_rooty() + (self.winfo_height() - h) // 2
            dialog.geometry(f"+{max(x, 0)}+{max(y, 0)}")
        except Exception:
            pass
        dialog.bind("<Escape>", lambda _e: dialog.destroy())

    def _add_help_button(self, parent, title: str, message: str) -> ttk.Button:
        btn = ttk.Button(parent, text="？", width=2,
                         command=lambda: self._show_help_dialog(title, message))
        btn.pack(side=tk.RIGHT, padx=(4, 0))
        return btn

    def _add_section_heading(self, parent, caption: str, help_text: str,
                              *, title: Optional[str] = None, pady=(8, 4)) -> ttk.Frame:
        row = ttk.Frame(parent)
        row.pack(fill=tk.X, pady=pady)
        ttk.Label(row, text=caption, font=("TkDefaultFont", 10, "bold")).pack(side=tk.LEFT)
        self._add_help_button(row, title or caption, help_text)
        return row
    # === CODEX END: twist/shift helpers ===

    # === CODEX BEGIN: twist/shift page UI ===
    def _build_twistshift_page(self, parent):
        frame = ttk.Frame(parent)

        # 左栏：输入与控制（带滚动条）
        left_container = ttk.Frame(frame)
        left_container.pack(side=tk.LEFT, fill=tk.Y)
        left_canvas = tk.Canvas(left_container, borderwidth=0, highlightthickness=0, width=420)
        left_scroll = ttk.Scrollbar(left_container, orient=tk.VERTICAL, command=left_canvas.yview)
        left_canvas.configure(yscrollcommand=left_scroll.set)
        left_canvas.pack(side=tk.LEFT, fill=tk.Y, expand=False)
        left_scroll.pack(side=tk.RIGHT, fill=tk.Y)

        left = ttk.Frame(left_canvas, padding=8)
        left_window = left_canvas.create_window((0, 0), window=left, anchor="nw")

        def _sync_scrollregion(event):
            left_canvas.configure(scrollregion=left_canvas.bbox("all"))

        def _match_width(event):
            left_canvas.itemconfigure(left_window, width=event.width)

        left.bind("<Configure>", _sync_scrollregion)
        left_canvas.bind("<Configure>", _match_width)

        def _on_mousewheel(event):
            delta = 0
            if event.delta:
                delta = -int(event.delta / 120)
            elif event.num in (4, 5):
                delta = -1 if event.num == 4 else 1
            if delta:
                left_canvas.yview_scroll(delta, "units")
                return "break"

        for widget in (left_canvas, left):
            widget.bind("<MouseWheel>", _on_mousewheel)
            widget.bind("<Button-4>", _on_mousewheel)
            widget.bind("<Button-5>", _on_mousewheel)
        ttk.Label(left, text="二维材料扭转/滑移 | 生成批量 POSCAR 与扫参任务").pack(anchor=tk.W, pady=(0,6))

        help_poscar = textwrap.dedent("""
            【基础输入】
            • 先后选择底层 (B) 与上层 (T) 的 POSCAR。
            • 默认假设 POSCAR 的 c 轴接近层法向；若不符合，请先在外部对齐晶格。
            • 上层以刚体方式旋转/滑移，并按“真空(Å)”设定层间距。
        """).strip()
        help_vacuum = textwrap.dedent("""
            【真空与容许应变】
            • “真空(Å)” 决定最终 c 轴长度 = 层间距 + 真空层，常用 15–20 Å。
            • 建议配合 INCAR 中 LDIPOL=.TRUE. 与 IDIPOL=3 以消除偶极。
            • “容许应变(%)” 控制搜索近共格超胞时允许的面内等效拉伸/压缩，常用 0.5–1.0%。
            • 程序会在限制内搜索对角超胞，若仍匹配失败可放宽容许应变或提高搜索阶数。
        """).strip()
        help_twist = textwrap.dedent("""
            【扭转角扫描】
            • 起/止/步长按闭区间生成角度序列；步长不能整除区间时，会截断在终点前的最后一个值。
            • 六角或三角晶格在 0–60° 内即可覆盖独立堆垛；异质双层通常也采用该范围。
            • 角度数量 Nθ = floor((止 − 起)/步长) + 1。
        """).strip()
        help_slide = textwrap.dedent("""
            【滑移网格】
            • 滑移向量定义为 t = uₓ·a₁ + uᵧ·a₂，其中 a₁、a₂ 为底层面内基矢。
            • 网格在 [0,1)×[0,1) 内均匀采样，u=1 与 u=0 等价。
            • 设 uₓ 步数 = nₓ、uᵧ 步数 = nᵧ，共生成 nₓ×nᵧ 个组合；六角晶格会按对称性自动去重。
        """).strip()
        help_compute = textwrap.dedent("""
            【KSPACING 与任务上限】
            • KSPACING 优先写入 INCAR：金属或小原胞常用 0.18–0.22；半导体 0.22–0.30；莫尔超胞可先用 Γ-only 或 0.35 预筛。
            • 若项目目录存在 KPOINTS 文件，则沿用原网格；否则采用 KSPACING 自动生成。
            • 任务上限用于约束 sweep 规模，总任务数近似为 Nθ × nₓ × nᵧ。
        """).strip()
        help_actions = textwrap.dedent("""
            【操作按钮】
            • “预览当前(θ,u)几何”：即时构造当前组合以核对结构。
            • “生成单例 POSCAR”：仅输出当前参数对应的单个目录。
            • “批量遍历并生成”：按角度与滑移网格生成全部任务、脚本与 meta.json。
            • “生成后自动运行”：复制项目脚本并尝试调用 run_local.sh（实验性功能）。
            • “解析 sweep 结果 → CSV”：统计能量、带隙与备注生成汇总表。
        """).strip()
        help_defaults = textwrap.dedent("""
            【推荐默认值】
            • 真空 20 Å，INCAR 建议 LDIPOL=.TRUE. 与 IDIPOL=3。
            • 容许应变 0.5–0.8%，极小角度可放宽至 1.0%。
            • 角度初扫 0–10°、步长 2°，重点角度再加密。
            • 滑移网格常用 5×5 或 7×7；势垒/摩擦研究可加密到 15×15。
            • KSPACING ≈0.22，超大胞可先用 Γ-only 预筛后再细化。
            • SCF/DOS：ISMEAR=0, SIGMA=0.05；结构优化或金属可改 ISMEAR=1, SIGMA=0.2。
            • 层间范德华建议统一采用 IVDW=12 或 rVV10。
        """).strip()
        help_notes = textwrap.dedent("""
            【常见注意事项】
            • 小角度会显著增加原子数，可结合任务上限、Γ-only 预筛或提高容许应变控制规模。
            • 滑移始终以底层基矢的分数坐标描述，可借助预览面板显示的 t = uₓ·a₁ + uᵧ·a₂ 校验。
            • 网格采用 [0,1) 范围避免端点重复；设定角度步长时请确认覆盖目标终点。
            • PBE 带隙偏低，关键构型建议追加 HSE 或 scGW 以形成多保真修正。
        """).strip()

        # 路径选择
        self._add_section_heading(left, "路径选择", help_poscar, title="上/下层 POSCAR 指南", pady=(0, 4))
        self.tw_top_path = tk.StringVar()
        self.tw_bot_path = tk.StringVar()

        row = ttk.Frame(left); row.pack(fill=tk.X, pady=2)
        ttk.Label(row, text="上层 POSCAR:").pack(side=tk.LEFT)
        ttk.Entry(row, textvariable=self.tw_top_path, width=44).pack(side=tk.LEFT, padx=4)
        ttk.Button(row, text="选择…", command=lambda: self._tw_pick_poscar(self.tw_top_path)).pack(side=tk.LEFT)

        row = ttk.Frame(left); row.pack(fill=tk.X, pady=2)
        ttk.Label(row, text="下层 POSCAR:").pack(side=tk.LEFT)
        ttk.Entry(row, textvariable=self.tw_bot_path, width=44).pack(side=tk.LEFT, padx=4)
        ttk.Button(row, text="选择…", command=lambda: self._tw_pick_poscar(self.tw_bot_path)).pack(side=tk.LEFT)

        ttk.Separator(left, orient=tk.HORIZONTAL).pack(fill=tk.X, pady=6)

        # 基本几何参数
        self.tw_vacuum = tk.DoubleVar(value=20.0)     # 目标真空 (Å)
        self.tw_allow_strain = tk.DoubleVar(value=0.8)  # 允许等效小应变（%）
        self.tw_gamma_atom_threshold = tk.IntVar(value=500)  # 超大超胞→Gamma-only
        self.tw_enable_twist = tk.BooleanVar(value=True)
        self.tw_enable_slide = tk.BooleanVar(value=True)

        self._add_section_heading(left, "基本几何参数", help_vacuum, title="真空与容许应变")
        row = ttk.Frame(left); row.pack(fill=tk.X, pady=2)
        ttk.Label(row, text="真空(Å):").pack(side=tk.LEFT); ttk.Entry(row, textvariable=self.tw_vacuum, width=7).pack(side=tk.LEFT, padx=4)
        ttk.Label(row, text="容许应变(%)").pack(side=tk.LEFT, padx=(8,0)); ttk.Entry(row, textvariable=self.tw_allow_strain, width=7).pack(side=tk.LEFT, padx=4)

        dim_frame = ttk.LabelFrame(left, text="扫描维度")
        dim_frame.pack(fill=tk.X, pady=4)
        ttk.Checkbutton(dim_frame, text="启用扭转角扫描", variable=self.tw_enable_twist).pack(anchor=tk.W, padx=6, pady=2)
        ttk.Checkbutton(dim_frame, text="启用滑移网格扫描", variable=self.tw_enable_slide).pack(anchor=tk.W, padx=6, pady=2)
        ttk.Label(dim_frame, text="可按需只做扭转或只做滑移，两者都开时则全量组合。", wraplength=340, justify=tk.LEFT, foreground="#555").pack(anchor=tk.W, padx=6, pady=(0, 4))

        ttk.Separator(left, orient=tk.HORIZONTAL).pack(fill=tk.X, pady=6)

        # 扭转角扫描
        self._add_section_heading(left, "扭转角扫描", help_twist, title="扭转角 θ（度）")
        ttk.Label(left, text="扭转角 θ (度)：").pack(anchor=tk.W)
        self.tw_theta_a = tk.DoubleVar(value=0.0)
        self.tw_theta_b = tk.DoubleVar(value=10.0)
        self.tw_theta_step = tk.DoubleVar(value=2.0)
        r=ttk.Frame(left); r.pack(fill=tk.X, pady=2)
        ttk.Label(r, text="起").pack(side=tk.LEFT); ttk.Entry(r, textvariable=self.tw_theta_a, width=7).pack(side=tk.LEFT, padx=4)
        ttk.Label(r, text="止").pack(side=tk.LEFT); ttk.Entry(r, textvariable=self.tw_theta_b, width=7).pack(side=tk.LEFT, padx=4)
        ttk.Label(r, text="步").pack(side=tk.LEFT); ttk.Entry(r, textvariable=self.tw_theta_step, width=7).pack(side=tk.LEFT, padx=4)
        ttk.Label(left, text="注：六角晶格通常只需 0–60° 区间。", foreground="#666").pack(anchor=tk.W, pady=(0,4))

        # 滑移扫描（分数坐标）
        self._add_section_heading(left, "滑移网格", help_slide, title="滑移 (分数坐标)")
        ttk.Label(left, text="滑移 (分数坐标 u_x,u_y)：").pack(anchor=tk.W)
        self.tw_ux_steps = tk.IntVar(value=5)
        self.tw_uy_steps = tk.IntVar(value=5)
        r=ttk.Frame(left); r.pack(fill=tk.X, pady=2)
        ttk.Label(r, text="u_x 步数").pack(side=tk.LEFT); ttk.Spinbox(r, from_=1, to=32, textvariable=self.tw_ux_steps, width=6).pack(side=tk.LEFT, padx=4)
        ttk.Label(r, text="u_y 步数").pack(side=tk.LEFT, padx=(8,0)); ttk.Spinbox(r, from_=1, to=32, textvariable=self.tw_uy_steps, width=6).pack(side=tk.LEFT, padx=4)
        ttk.Label(left, text="网格覆盖 [0,1)×[0,1)，自动等间隔。", foreground="#666").pack(anchor=tk.W)

        ttk.Separator(left, orient=tk.HORIZONTAL).pack(fill=tk.X, pady=6)

        # 计算与并行策略
        self.tw_kspacing = tk.DoubleVar(value=0.22)
        self.tw_max_tasks = tk.IntVar(value=200)
        self.tw_autorun = tk.BooleanVar(value=False)  # 可选：生成后立刻运行（默认关）

        self._add_section_heading(left, "计算与并行策略", help_compute, title="KSPACING 与任务上限")
        r=ttk.Frame(left); r.pack(fill=tk.X, pady=2)
        ttk.Label(r, text="KSPACING").pack(side=tk.LEFT); ttk.Entry(r, textvariable=self.tw_kspacing, width=7).pack(side=tk.LEFT, padx=4)
        ttk.Label(r, text="任务上限").pack(side=tk.LEFT, padx=(8,0)); ttk.Entry(r, textvariable=self.tw_max_tasks, width=7).pack(side=tk.LEFT, padx=4)
        ttk.Checkbutton(left, text="生成后自动运行（试验性）", variable=self.tw_autorun).pack(anchor=tk.W, pady=(2,4))

        # 操作按钮
        self._add_section_heading(left, "任务操作", help_actions, title="选项与按钮")
        btns = ttk.Frame(left); btns.pack(fill=tk.X, pady=8)
        ttk.Button(btns, text="预览当前(θ,u)几何", command=self._tw_preview_once).pack(side=tk.LEFT)
        ttk.Button(btns, text="生成单例 POSCAR", command=lambda: self._tw_generate(single=True)).pack(side=tk.LEFT, padx=6)
        ttk.Button(btns, text="批量遍历并生成", command=lambda: self._tw_generate(single=False)).pack(side=tk.LEFT)

        ttk.Separator(left, orient=tk.HORIZONTAL).pack(fill=tk.X, pady=6)
        ttk.Button(left, text="解析 sweep 结果 → CSV", command=self._tw_collect_results).pack(anchor=tk.W)
        ttk.Button(left, text="绘制 gap 热图（用当前 θ）", command=self._tw_plot_gap_heatmap_btn).pack(anchor=tk.W, pady=(4, 0))
        ttk.Button(left, text="绘制 gap–θ 曲线（min/mean/max）", command=self._tw_plot_gap_vs_theta_btn).pack(anchor=tk.W, pady=(4, 8))


        self._add_section_heading(left, "推荐默认值", help_defaults, title="计算与物理的默认值", pady=(8, 4))
        self._add_section_heading(left, "常见注意事项", help_notes, title="常见注意事项", pady=(0, 8))

        log_box = ttk.LabelFrame(left, text="运行日志")
        log_box.pack(fill=tk.BOTH, expand=True, pady=(0, 8))
        self.tw_log = ScrolledText(log_box, height=10, wrap="word")
        self.tw_log.pack(fill=tk.BOTH, expand=True, padx=4, pady=4)
        self.tw_log.insert(tk.END, "扭转/滑移任务的进度消息会显示在此处。\n")
        self.tw_log.configure(state=tk.DISABLED)

        # 右栏：俯视预览
        right = ttk.Frame(frame, padding=8); right.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True)
        self.fig_tw = Figure(figsize=(6.0,4.5), dpi=100)
        self.ax_tw = self.fig_tw.add_subplot(111)
        self.ax_tw.set_title("Top view preview")
        self.ax_tw.set_xlabel("x (Å)"); self.ax_tw.set_ylabel("y (Å)")
        self.canvas_tw = FigureCanvasTkAgg(self.fig_tw, master=right)
        self.canvas_tw.draw(); self.canvas_tw.get_tk_widget().pack(fill=tk.BOTH, expand=True)

        return frame

    def _tw_append_log(self, message: str) -> None:
        if not hasattr(self, "tw_log"):
            return
        timestamp = time.strftime("%H:%M:%S")
        try:
            self.tw_log.configure(state=tk.NORMAL)
            self.tw_log.insert(tk.END, f"[{timestamp}] {message}\n")
            self.tw_log.see(tk.END)
            self.tw_log.configure(state=tk.DISABLED)
            self.tw_log.update_idletasks()
        except Exception:
            try:
                self.tw_log.configure(state=tk.DISABLED)
            except Exception:
                pass
    # === CODEX END: twist/shift page UI ===

    # === CODEX BEGIN: twist/shift geometry core ===
    def _tw_pick_poscar(self, var):
        p = filedialog.askopenfilename(title="选择 POSCAR", filetypes=[("POSCAR","POSCAR*"),("All","*")])
        if p: var.set(p)

    def _tw_preview_once(self):
        """使用当前 θ = theta_a、u=(0,0) 快速构造一次并俯视预览。"""
        try:
            st, meta = self._tw_build_structure(
                Path(self.tw_top_path.get()), Path(self.tw_bot_path.get()),
                theta_deg=float(self.tw_theta_a.get()), ux=0.0, uy=0.0,
                vacuum=float(self.tw_vacuum.get()),
                allow_strain=float(self.tw_allow_strain.get())/100.0,
                search_limit=8
            )
        except Exception as e:
            messagebox.showerror(APP_NAME, f"预览失败：{e}")
            return
        self._tw_draw_topview(st, meta)
        self._tw_append_log(f"预览已更新：θ={meta.get('theta_deg', 0.0):.3f}°, u=(0.000,0.000)")

    def _tw_draw_topview(self, st, meta):
        """简单俯视：投影到 x-y，按层分色。"""
        try:
            from pymatgen.core import Structure  # noqa: F401
        except Exception:
            messagebox.showerror(APP_NAME, "未安装 pymatgen，无法预览结构。")
            return
        self.ax_tw.clear()
        # 取原子与层标签（site.properties.get("layer")）
        xs0, ys0, xs1, ys1 = [], [], [], []
        for site in st.sites:
            x,y,z = site.coords
            if site.properties.get("layer","bot") == "top":
                xs1.append(x); ys1.append(y)
            else:
                xs0.append(x); ys0.append(y)
        self.ax_tw.scatter(xs0, ys0, s=14, alpha=0.8, label="bottom")
        self.ax_tw.scatter(xs1, ys1, s=14, alpha=0.6, label="top")
        # 画边框（新晶格）
        M = st.lattice.matrix
        import numpy as _np
        a = _np.array(M[0]); b = _np.array(M[1])
        poly = _np.array([[0,0],[a[0],a[1]],[a[0]+b[0],a[1]+b[1]],[b[0],b[1]],[0,0]])
        self.ax_tw.plot(poly[:,0], poly[:,1], linestyle="--", linewidth=1.0)
        self.ax_tw.set_aspect("equal", adjustable="datalim")
        self.ax_tw.grid(True, linestyle=":", linewidth=0.6)
        self.ax_tw.legend()
        tdeg = meta.get("theta_deg")
        ux,uy = meta.get("ux"), meta.get("uy")
        self.ax_tw.set_title(f"θ={tdeg:.3f}°, u=({ux:.3f},{uy:.3f}), atoms={len(st)}")
        try:
            self.canvas_tw.draw()
            widget = self.canvas_tw.get_tk_widget()
            widget.update_idletasks()
            widget.update()
            self.update_idletasks()
        except Exception:
            pass

    def _tw_find_match(self, A_top_rot, A_bot, allow_strain: float, search_limit: int):
        """返回最优匹配 dict(n1,m1,n2,m2,s,resid,area,atoms)。"""
        import numpy as np

        best: Optional[Dict[str, float]] = None
        # 优先使用 ZSL（若可用），失败则自动回退
        if HAS_ZSL:
            try:
                zsl = ZSLGenerator(
                    max_area_ratio=(1.0 + allow_strain),
                    max_misfit=allow_strain,
                    max_angle_diff=allow_strain * 10.0,
                )

                def to3(mat):
                    return np.array(
                        [
                            [mat[0, 0], mat[0, 1], 0.0],
                            [mat[1, 0], mat[1, 1], 0.0],
                            [0.0, 0.0, 1.0],
                        ],
                        dtype=float,
                    )

                matches = zsl.get_zsl_matches(to3(A_top_rot), to3(A_bot), max_search=search_limit)
                for m in matches:
                    S1 = np.array(m.get("matrix_1"), dtype=float)[:2, :2]
                    S2 = np.array(m.get("matrix_2"), dtype=float)[:2, :2]
                    # 当前构建流程只支持对角超胞，若出现非对角项则跳过
                    if not np.allclose(S1, np.diag(np.diag(S1))) or not np.allclose(
                        S2, np.diag(np.diag(S2))
                    ):
                        continue
                    S1 = np.diag(np.diag(S1)).astype(int)
                    S2 = np.diag(np.diag(S2)).astype(int)
                    T = A_top_rot @ S1
                    B = A_bot @ S2
                    denom = float(np.trace(T.T @ T))
                    if denom <= 0:
                        continue
                    s_star = float(np.trace(T.T @ B) / denom)
                    resid = np.linalg.norm(B - s_star * T, ord="fro") / max(
                        1.0, np.linalg.norm(B, ord="fro")
                    )
                    area = abs(float(np.linalg.det(B)))
                    cand = dict(
                        n1=int(S1[0, 0]),
                        m1=int(S1[1, 1]),
                        n2=int(S2[0, 0]),
                        m2=int(S2[1, 1]),
                        s=s_star,
                        resid=resid,
                        area=area,
                        atoms=-1,
                    )
                    if best is None or (resid, area) < (best["resid"], best["area"]):
                        best = cand
                if best is not None:
                    return best
            except Exception:
                pass

        # 回退到对角穷举
        best = None
        for n1 in range(1, search_limit + 1):
            for m1 in range(1, search_limit + 1):
                T = A_top_rot @ np.array([[n1, 0], [0, m1]], dtype=int)
                denom = float(np.trace(T.T @ T))
                if denom <= 0:
                    continue
                for n2 in range(1, search_limit + 1):
                    for m2 in range(1, search_limit + 1):
                        B = A_bot @ np.array([[n2, 0], [0, m2]], dtype=int)
                        s_star = float(np.trace(T.T @ B) / denom)
                        if not (1.0 - allow_strain <= s_star <= 1.0 + allow_strain):
                            continue
                        resid = np.linalg.norm(B - s_star * T, ord="fro") / max(
                            1.0, np.linalg.norm(B, ord="fro")
                        )
                        area = abs(float(np.linalg.det(B)))
                        cand = dict(
                            n1=n1,
                            m1=m1,
                            n2=n2,
                            m2=m2,
                            s=s_star,
                            resid=resid,
                            area=area,
                            atoms=-1,
                        )
                        if best is None or (resid, area) < (best["resid"], best["area"]):
                            best = cand
        return best

    def _estimate_atoms(self, st_top, st_bot, best):
        return len(st_top) * (best["n1"] * best["m1"]) + len(st_bot) * (best["n2"] * best["m2"])

    def _tw_build_structure(self, top_path: Path, bot_path: Path,
                            theta_deg: float, ux: float, uy: float,
                            vacuum: float, allow_strain: float,
                            search_limit: int = 8):
        """
        构造扭转(θ) + 滑移(u_x,u_y) 的双层结构，并尽量用对角超胞近似共格。
        返回 (Structure, meta)；如果找不到低应变解，抛出异常。
        """
        if not HAS_PYMATGEN or not HAS_NUMPY:
            raise RuntimeError("需要 pymatgen + numpy")
        from pymatgen.core import Structure, Lattice
        import numpy as np

        if not top_path.exists() or not bot_path.exists():
            raise FileNotFoundError("POSCAR 路径不存在")

        st_top = Structure.from_file(str(top_path))
        st_bot = Structure.from_file(str(bot_path))

        # 取 in-plane 基矢（假定 z 为法向；若用户 POSCAR 不是这样，应先在外部对齐）
        A_bot = np.array(st_bot.lattice.matrix[:2, :2])  # (2,2)
        A_top = np.array(st_top.lattice.matrix[:2, :2])  # (2,2)

        # 绕 z 旋转上层 in-plane 基矢
        th = np.deg2rad(theta_deg)
        Rz = np.array([[np.cos(th), -np.sin(th)],
                       [np.sin(th),  np.cos(th)]], dtype=float)
        A_top_rot = Rz @ A_top  # (2,2)

        best = self._tw_find_match(A_top_rot, A_bot, allow_strain, search_limit)

        if best is None:
            raise RuntimeError("在给定容许应变与搜索限内未找到可接受的对角超胞匹配。")

        atom_est = self._estimate_atoms(st_top, st_bot, best)
        best["atoms"] = atom_est
        gamma_limit = int(self.tw_gamma_atom_threshold.get()) if hasattr(self, "tw_gamma_atom_threshold") else 500
        if atom_est > gamma_limit * 8:
            raise RuntimeError(
                f"预计原子数≈{atom_est}，过大；请调大步长或缩小角度/网格。"
            )

        # 构造下层超胞
        S_bot = np.eye(3, dtype=int)
        S_bot[0,0] = best["n2"]; S_bot[1,1] = best["m2"]
        bot_sc = st_bot.copy()
        bot_sc.make_supercell(S_bot)

        # 构造上层超胞 + 旋转 + 等比例变形
        S_top = np.eye(3, dtype=int)
        S_top[0,0] = best["n1"]; S_top[1,1] = best["m1"]
        top_sc = st_top.copy()
        top_sc.make_supercell(S_top)

        # 先设一个临时晶格做笛卡尔变换
        # 上层：旋转 + in-plane 等比例 s
        s = float(best["s"])
        # 取上层原笛卡尔 → 应用 Rz 与 s
        t_cart = np.array([site.coords for site in top_sc.sites])  # (Nt,3)
        t_cart[:,:2] = (Rz @ t_cart[:,:2].T).T * s

        # 最终公共 in-plane 晶格使用 B（下层超胞矩阵 B）
        B = A_bot @ np.array([[best["n2"],0],[0,best["m2"]]], dtype=int)
        # 组 3×3 晶格矩阵：c 轴重置为目标真空
        c_len = float(vacuum)
        L_final = np.array([[B[0,0], B[0,1], 0.0],
                            [B[1,0], B[1,1], 0.0],
                            [0.0,    0.0,    c_len]], dtype=float)

        # 把上下层点坐标映射到最终晶格分数坐标
        def cart_to_frac(L, r):
            return np.linalg.solve(L.T, r.T).T  # (N,3)

        b_cart = np.array([site.coords for site in bot_sc.sites])
        # 先把下层坐标重映射到以 B 为 in-plane 的晶格（原 in-plane 已经是 A_bot*n2,m2；z 保持）
        # bot_sc 现有晶格：
        # 先把它的 frac → cart（已是 cart），我们只需要映射到 L_final 的 frac：
        b_frac_final = cart_to_frac(L_final, b_cart)
        t_frac_final = cart_to_frac(L_final, t_cart)

        # 施加滑移（分数坐标，沿 a1,a2）
        t_frac_final[:,0] = (t_frac_final[:,0] + ux) % 1.0
        t_frac_final[:,1] = (t_frac_final[:,1] + uy) % 1.0

        # 分层放置在 z（0.4 与 0.6）
        b_frac_final[:,2] = 0.40
        t_frac_final[:,2] = 0.60

        # 合并为一个 Structure
        species = []
        frac = []
        props = []
        for site, f in zip(bot_sc.sites, b_frac_final):
            species.append(site.species)
            frac.append(f.tolist())
            props.append({"layer":"bot"})
        for site, f in zip(top_sc.sites, t_frac_final):
            species.append(site.species)
            frac.append(f.tolist())
            props.append({"layer":"top"})

        st_final = Structure(Lattice(L_final), species, frac, site_properties=props)

        meta = dict(theta_deg=float(theta_deg), ux=float(ux), uy=float(uy),
                    atoms=len(st_final), n1=best["n1"], m1=best["m1"],
                    n2=best["n2"], m2=best["m2"], strain_scale=s,
                    resid=best["resid"])
        return st_final, meta
    # === CODEX END: twist/shift geometry core ===

    # === CODEX BEGIN: generate twist/shift tasks ===
    def _tw_canonical_registry(self, ux: float, uy: float, lattice2x2):
        """规约 (ux, uy) 到具有代表性的等价点以减少重复。"""
        try:
            import numpy as _np
            import math as _math
        except Exception:
            return (float(ux % 1.0), float(uy % 1.0))

        vec_a = _np.asarray(lattice2x2)[:, 0]
        vec_b = _np.asarray(lattice2x2)[:, 1]
        if vec_a.shape[0] != 2 or vec_b.shape[0] != 2:
            return (float(ux % 1.0), float(uy % 1.0))

        a_len = _np.linalg.norm(vec_a)
        b_len = _np.linalg.norm(vec_b)
        if a_len == 0 or b_len == 0:
            return (float(ux % 1.0), float(uy % 1.0))

        cosang = _np.clip(_np.dot(vec_a, vec_b) / (a_len * b_len), -1.0, 1.0)
        ang = _math.degrees(_math.acos(cosang))

        ux_mod = float(ux % 1.0)
        uy_mod = float(uy % 1.0)

        def _rotate_candidates(order):
            cands = []
            for k in range(order):
                th = 2 * _math.pi * k / order
                rot = _np.array([[_math.cos(th), -_math.sin(th)], [_math.sin(th), _math.cos(th)]])
                u = (rot @ _np.array([ux_mod, uy_mod])) % 1.0
                cands.append((float(u[0]), float(u[1])))
            return min(cands)

        if abs(a_len - b_len) / max(a_len, b_len) < 0.02:
            if abs(ang - 60.0) < 2.0:
                return _rotate_candidates(6)
            if abs(ang - 90.0) < 2.0:
                return _rotate_candidates(4)

        return (ux_mod, uy_mod)

    def _tw_generate(self, single: bool):
        """生成单例或批量遍历任务目录与 POSCAR/INCAR。"""
        try:
            theta_a = float(self.tw_theta_a.get())
            theta_b = float(self.tw_theta_b.get())
            theta_step = float(self.tw_theta_step.get())
            vacuum = float(self.tw_vacuum.get())
            allow_strain = float(self.tw_allow_strain.get())/100.0
            kspacing = float(self.tw_kspacing.get())
            ux_steps = int(self.tw_ux_steps.get())
            uy_steps = int(self.tw_uy_steps.get())
            max_tasks = int(self.tw_max_tasks.get())
        except Exception as e:
            messagebox.showerror(APP_NAME, f"参数错误：{e}")
            return

        twist_enabled = bool(self.tw_enable_twist.get()) if hasattr(self, "tw_enable_twist") else True
        slide_enabled = bool(self.tw_enable_slide.get()) if hasattr(self, "tw_enable_slide") else True
        issues = []
        if vacuum <= 0:
            issues.append("真空(Å) 必须为正数。")
        if allow_strain < 0:
            issues.append("容许应变(%) 不能为负值。")
        if kspacing <= 0:
            issues.append("KSPACING 需为正数。")
        if max_tasks <= 0:
            issues.append("任务上限需为正整数。")
        if twist_enabled and not single and abs(theta_b - theta_a) > 1e-9 and theta_step <= 0:
            issues.append("扭转角步长需为正数，以便生成多角度扫描。")
        if slide_enabled and ux_steps <= 0:
            issues.append("u_x 步数需为正整数。")
        if slide_enabled and uy_steps <= 0:
            issues.append("u_y 步数需为正整数。")
        if issues:
            messagebox.showwarning(APP_NAME, "\n".join(issues))
            self._tw_append_log("参数校验失败：" + "；".join(issues))
            return

        if slide_enabled:
            slide_enabled = slide_enabled and ux_steps > 0 and uy_steps > 0

        top_p = Path(self.tw_top_path.get()); bot_p = Path(self.tw_bot_path.get())
        if not top_p.exists() or not bot_p.exists():
            messagebox.showwarning(APP_NAME, "请先选择上/下层 POSCAR")
            self._tw_append_log("未找到上/下层 POSCAR，生成流程已中止。")
            return

        # 任务组合
        if single or not twist_enabled:
            thetas = [theta_a]
        else:
            thetas = self._tw_linspace(theta_a, theta_b, step=theta_step)

        if single or not slide_enabled:
            uxs = [0.0]
            uys = [0.0]
        else:
            uxs = [i / ux_steps for i in range(ux_steps)]
            uys = [j / uy_steps for j in range(uy_steps)]

        lattice2x2 = None
        if (not single) and slide_enabled and HAS_PYMATGEN and HAS_NUMPY:
            try:
                from pymatgen.core import Structure as _Structure

                st_bot_sample = _Structure.from_file(str(bot_p))
                lattice2x2 = np.array(st_bot_sample.lattice.matrix[:2, :2])
            except Exception:
                lattice2x2 = None

        combos = []
        seen = set()
        for th in thetas:
            for ux in uxs:
                for uy in uys:
                    if slide_enabled and lattice2x2 is not None:
                        cu = self._tw_canonical_registry(ux, uy, lattice2x2)
                    else:
                        cu = (float(ux % 1.0), float(uy % 1.0))
                    key = (round(th, 6), round(cu[0], 6), round(cu[1], 6))
                    if key in seen:
                        continue
                    seen.add(key)
                    combos.append((th, float(cu[0]), float(cu[1])))

        self._tw_append_log(
            f"开始生成：θ 数量={len(thetas)}, u_x 数量={len(uxs)}, u_y 数量={len(uys)}，总计 {len(combos)} 个组合")
        if len(combos) > max_tasks:
            messagebox.showwarning(APP_NAME, f"任务数 {len(combos)} > 上限 {max_tasks}，请降低分辨率或步长")
            self._tw_append_log(f"任务数 {len(combos)} 超出上限 {max_tasks}，未执行生成。")
            return

        proj = self.current_project_path()
        root = proj / "twist_sweep"
        root.mkdir(parents=True, exist_ok=True)

        made = 0; skipped = 0
        for th, ux, uy in combos:
            name = f"theta_{th:+06.2f}_ux_{ux:0.3f}_uy_{uy:0.3f}".replace("+","")
            w = root / name
            w.mkdir(parents=True, exist_ok=True)
            self._tw_append_log(f"构建 θ={th:.3f}°, u=({ux:.3f},{uy:.3f}) → {w.name}")
            try:
                st, meta = self._tw_build_structure(top_p, bot_p, th, ux, uy, vacuum, allow_strain, search_limit=8)
            except Exception as e:
                # 写个失败标记
                write_text(w / "FAILED.txt", f"{e}\n")
                skipped += 1
                self._tw_append_log(f"构建失败：θ={th:.3f}°, u=({ux:.3f},{uy:.3f})，原因：{e}")
                continue
            # 写 POSCAR
            try:
                st.to(fmt="poscar", filename=str(w / "POSCAR"))
            except Exception as e:
                write_text(w / "FAILED.txt", f"写 POSCAR 失败: {e}\n")
                skipped += 1
                self._tw_append_log(f"写入 POSCAR 失败：{e}")
                continue

            # 准备 INCAR：从项目拷贝或用当前编辑器，补丁 2D 设置 + ISYM=0 + KSPACING
            incar_src = proj / "INCAR"
            if incar_src.exists():
                incar_text = read_text(incar_src)
            else:
                incar_text = self.incar_text.get("1.0", tk.END)

            patch = {
                "ISYM": "0",
                "KSPACING": f"{kspacing}",
                "LWAVE": ".FALSE.",
                "LCHARG": ".TRUE.",
            }
            # 2D 建议：去极化/偶极修正
            more2d = {"LDIPOL": ".TRUE.", "IDIPOL": "3"}
            patch.update(more2d)

            incar_new = self._update_incar_text(incar_text, patch)
            write_text(w / "INCAR", incar_new)

            # KPOINTS：建议不写（让 KSPACING 生效）。若用户执意存在 KPOINTS，可忽略或提示
            # POTCAR：若项目下已有则复制
            pot = proj / "POTCAR"
            if pot.exists():
                try:
                    shutil.copyfile(pot, w / "POTCAR")
                except Exception:
                    pass

            # 记录元数据
            meta_path = w / "meta.json"
            meta2 = dict(meta); meta2.update(dict(path=str(w)))
            (w / "meta.json").write_text(json.dumps(meta2, ensure_ascii=False, indent=2), encoding="utf-8")

            made += 1

            try:
                self._tw_draw_topview(st, meta2)
            except Exception:
                pass
            else:
                self._tw_append_log(f"完成：{w.name}，原子数 {len(st)}")

            # 可选：自动运行（实验性，依赖你的 run_local.sh 逻辑）
            if self.tw_autorun.get():
                # 简化：在该子目录下直接调用项目的 run_local.sh（需要 vasp 命令可用）
                try:
                    # 复制 run 脚本
                    for script in ("run_local.sh","run_slurm.sh"):
                        if (proj / script).exists():
                            shutil.copyfile(proj / script, w / script)
                            os.chmod(w / script, 0o755)
                    # 后台起本地
                    if (w / "run_local.sh").exists():
                        subprocess.Popen(["bash","-lc", f"cd '{w}' && ./run_local.sh"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, start_new_session=True)
                        self._tw_append_log(f"已触发自动运行：{w.name}/run_local.sh")
                except Exception as exc:
                    self._tw_append_log(f"自动运行触发失败：{w.name}，原因：{exc}")
                    pass

        messagebox.showinfo(APP_NAME, f"生成完成：成功 {made}，跳过 {skipped}（详见各子目录）。输出根目录：{root}")
        self._tw_append_log(f"生成完成：成功 {made}，跳过 {skipped}，输出目录 {root}")
        # 刷新概览
        self.refresh_project_overview()

    def _tw_linspace(self, a: float, b: float, step: float) -> list:
        if step <= 0: return [a]
        out = []
        x = a
        if b >= a:
            while x <= b + 1e-9:
                out.append(round(x, 10)); x += step
        else:
            while x >= b - 1e-9:
                out.append(round(x, 10)); x -= step
        # 防止小数误差重复
        return sorted(list(dict.fromkeys(out)))
    # === CODEX END: generate twist/shift tasks ===

    # === CODEX BEGIN: collect sweep results ===
    def _tw_collect_results(self):
        """遍历 twist_sweep/* 子目录，收集 gap / total energy / 备注，导出 CSV。"""
        root = self.current_project_path() / "twist_sweep"
        if not root.exists():
            if self.demo_mode:
                root.mkdir(parents=True, exist_ok=True)
                csv_path = self._tw_write_demo_results(root)
                messagebox.showinfo(APP_NAME, f"演示模式：已生成示例 results.csv → {csv_path}")
                self._tw_append_log("演示模式：已生成示例 twist_sweep/results.csv。")
                return
            messagebox.showwarning(APP_NAME, "未找到 twist_sweep 目录。")
            self._tw_append_log("未找到 twist_sweep 目录，无法汇总结果。")
            return
        self._tw_append_log("开始汇总 sweep 结果…")
        rows = []
        for sub in sorted(root.iterdir()):
            if not sub.is_dir(): continue
            theta = ux = uy = None
            try:
                # 从目录名回读参数
                m = re.search(r"theta_([0-9.]+)_ux_([0-9.]+)_uy_([0-9.]+)", sub.name)
                if m:
                    theta = float(m.group(1))
                    ux = float(m.group(2))
                    uy = float(m.group(3))
            except Exception:
                pass

            note = ""
            failf = sub / "FAILED.txt"
            if failf.exists():
                note = ("FAILED: " + read_text(failf).strip().splitlines()[0][:120])

            gap_eV = None
            totalE = None
            # 1) vasprun.xml
            vxml = sub / "vasprun.xml"
            if vxml.exists():
                try:
                    from pymatgen.io.vasp.outputs import Vasprun
                    v = Vasprun(str(vxml), parse_eigen=True, parse_projected_eigen=False)
                    bg = v.get_band_structure().get_band_gap()
                    gap_eV = float(bg.get("energy")) if bg else None
                    # 尝试总能
                    totalE = float(v.final_energy) if v.final_energy is not None else None
                except Exception as e:
                    if not note: note = f"vasprun parse err: {e}"
            # 2) EIGENVAL 兜底
            if gap_eV is None:
                gap_est, _ = self._tw_gap_from_eigenval(sub / "EIGENVAL", sub / "OUTCAR")
                if gap_est is not None: gap_eV = gap_est
            # 3) TOTEN 兜底
            if totalE is None:
                try:
                    outcar = read_text(sub / "OUTCAR")
                    mt = re.search(r"free\s+energy\s+TOTEN\s*=\s*([-\d.Ee+]+)", outcar, flags=re.I)
                    if mt: totalE = float(mt.group(1))
                except Exception:
                    pass

            rows.append(dict(path=sub.name, theta=theta, ux=ux, uy=uy, gap_eV=gap_eV, totalE=totalE, note=note))

        # 写 CSV
        import csv

        csv_path = root / "results.csv"
        with csv_path.open("w", encoding="utf-8", newline="") as f:
            writer = csv.writer(f)
            writer.writerow(["theta", "ux", "uy", "gap", "E", "path", "note"])
            for r in rows:
                theta = r.get("theta")
                ux = r.get("ux")
                uy = r.get("uy")
                gap = r.get("gap_eV")
                energy = r.get("totalE")
                note = (r.get("note") or "").replace(",", ";").replace("\n", " ")

                def _fmt_float(val):
                    if val is None or (isinstance(val, float) and math.isnan(val)):
                        return ""
                    if isinstance(val, float):
                        return f"{val:.6f}"
                    return str(val)

                writer.writerow(
                    [
                        _fmt_float(theta),
                        _fmt_float(ux),
                        _fmt_float(uy),
                        _fmt_float(gap),
                        _fmt_float(energy),
                        r.get("path", ""),
                        note,
                    ]
                )

        messagebox.showinfo(APP_NAME, f"已导出汇总：{csv_path}")
        self._tw_append_log(f"结果汇总完成：共 {len(rows)} 条记录，输出 {csv_path}")

    def _tw_gap_from_eigenval(self, eig_path: Path, outcar_path: Path):
        """非常规兜底：从 EIGENVAL + OUTCAR(E_F) 粗略估算带隙。返回 (gap, is_direct?)；失败返回 (None,None)。"""
        try:
            if not eig_path.exists(): return (None, None)
            ef = None
            try:
                txt = read_text(outcar_path)
                m = re.search(r"(?mi)E-fermi\s*:\s*([-\d.Ee+]+)", txt)
                if m: ef = float(m.group(1))
            except Exception:
                pass
            lines = read_text(eig_path).splitlines()
            # 第6行包含 NKPTS, NBANDS
            nk, nb = map(int, lines[5].split()[:2])
            i = 6
            energies = []
            occs = []
            for _ in range(nk):
                # 跳 k 行前的空行
                while i < len(lines) and not lines[i].strip():
                    i += 1
                i += 1  # 跳 kx ky kz w
                ks = []
                os = []
                for b in range(nb):
                    parts = lines[i].split()
                    e = float(parts[1])
                    o = float(parts[2]) if len(parts) > 2 else 0.0
                    ks.append(e); os.append(o); i += 1
                energies.append(ks); occs.append(os)
            # 估计 VBM/CBM（以占据 0.5 为界，若有 EF 则先减 EF）
            if ef is not None:
                energies = [[e-ef for e in ks] for ks in energies]
            vbm = max(max(e for e,o in zip(ks,os) if o > 0.5) for ks,os in zip(energies,occs))
            cbm = min(min(e for e,o in zip(ks,os) if o < 0.5) for ks,os in zip(energies,occs))
            gap = max(0.0, cbm - vbm)
            return (gap, None)
        except Exception:
            return (None, None)
    # === CODEX END: collect sweep results ===

    # === 2D 滑移/扭转载：页面 + 演示数据 + 可视化（最小可用版） =====================

    def _build_twistshift_results_page(self, parent):
        """二维材料·滑移/扭转（演示/载入扫参）"""
        frame = ttk.Frame(parent, padding=8)

        # ---- 变量与状态 ----
        if not hasattr(self, "tw_top_path"):
            self.tw_top_path = tk.StringVar(value="")
        if not hasattr(self, "tw_bot_path"):
            self.tw_bot_path = tk.StringVar(value="")
        self.tw_dir = tk.StringVar(value="")
        self.tw_theta = tk.DoubleVar(value=0.0)
        self.tw_ux = tk.DoubleVar(value=0.0)
        self.tw_uy = tk.DoubleVar(value=0.0)
        self.tw_results = []  # 全部结果
        self.tw_filtered = []  # 过滤到某个 theta 的切片
        self.tw_cbar = None  # 记录 colorbar 以便重绘时清理

        # ---- 顶部：文件选择与动作 ----
        top = ttk.Frame(frame)
        top.pack(fill=tk.X)
        ttk.Label(top, text="上层 POSCAR:").pack(side=tk.LEFT)
        ttk.Entry(top, textvariable=self.tw_top_path, width=48).pack(side=tk.LEFT, padx=4)
        ttk.Button(top, text="选择…", command=self._tw_choose_top).pack(side=tk.LEFT)

        ttk.Label(top, text="  下层 POSCAR:").pack(side=tk.LEFT, padx=(8, 0))
        ttk.Entry(top, textvariable=self.tw_bot_path, width=48).pack(side=tk.LEFT, padx=4)
        ttk.Button(top, text="选择…", command=self._tw_choose_bot).pack(side=tk.LEFT)

        # 第二行：扫参目录 + 快捷按钮
        row2 = ttk.Frame(frame)
        row2.pack(fill=tk.X, pady=(6, 2))
        ttk.Label(row2, text="扫参目录:").pack(side=tk.LEFT)
        ttk.Entry(row2, textvariable=self.tw_dir, width=64).pack(side=tk.LEFT, padx=4)
        ttk.Button(row2, text="选择目录…", command=self._tw_choose_dir).pack(side=tk.LEFT)
        ttk.Button(row2, text="载入目录", command=lambda: self._tw_load_dir(self.tw_dir.get())).pack(side=tk.LEFT, padx=6)
        ttk.Button(row2, text="写入演示数据并载入", command=self._tw_write_and_load_demo).pack(side=tk.LEFT, padx=6)

        # 第三行：筛选与操作
        row3 = ttk.Frame(frame)
        row3.pack(fill=tk.X, pady=(2, 6))
        ttk.Label(row3, text="θ(°)：").pack(side=tk.LEFT)
        tk.Spinbox(row3, from_=0.0, to=30.0, increment=0.5, textvariable=self.tw_theta, width=6).pack(side=tk.LEFT)
        ttk.Label(row3, text="  ux：").pack(side=tk.LEFT)
        tk.Spinbox(row3, from_=0.0, to=1.0, increment=0.05, textvariable=self.tw_ux, width=6).pack(side=tk.LEFT)
        ttk.Label(row3, text="  uy：").pack(side=tk.LEFT)
        tk.Spinbox(row3, from_=0.0, to=1.0, increment=0.05, textvariable=self.tw_uy, width=6).pack(side=tk.LEFT)
        ttk.Button(row3, text="按 θ 过滤并重绘", command=self._tw_refilter_and_redraw).pack(side=tk.LEFT, padx=8)
        ttk.Button(row3, text="导出当前切片CSV", command=self._tw_export_slice_csv).pack(side=tk.LEFT, padx=4)
        self.tw_info = ttk.Label(row3, text="—")
        self.tw_info.pack(side=tk.LEFT, padx=8)

        # ---- 主体左右：表格 + 图 ----
        body = ttk.PanedWindow(frame, orient=tk.HORIZONTAL)
        body.pack(fill=tk.BOTH, expand=True)

        # 左：结果表
        left = ttk.Frame(body)
        body.add(left, weight=1)
        cols = ("theta", "ux", "uy", "gap", "E", "path")
        self.tw_tree = ttk.Treeview(left, columns=cols, show="headings", height=16)
        for c, w in zip(cols, (70, 60, 60, 70, 70, 240)):
            self.tw_tree.heading(c, text=c)
            self.tw_tree.column(c, width=w, anchor=tk.CENTER if c != "path" else tk.W)
        self.tw_tree.pack(fill=tk.BOTH, expand=True)
        self.tw_tree.bind("<<TreeviewSelect>>", self._on_tw_tree_select)

        # 右：Matplotlib 区
        right = ttk.Frame(body)
        body.add(right, weight=1)
        self.tw_fig = Figure(figsize=(5.6, 3.6))
        self.tw_ax = self.tw_fig.add_subplot(111)
        self.tw_canvas = FigureCanvasTkAgg(self.tw_fig, master=right)
        self.tw_canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)

        return frame

    # --- 目录/文件选择 ---
    def _tw_choose_top(self):
        p = filedialog.askopenfilename(title="选择上层 POSCAR", filetypes=[("POSCAR", "POSCAR"), ("All", "*")])
        if p:
            self.tw_top_path.set(p)

    def _tw_choose_bot(self):
        p = filedialog.askopenfilename(title="选择下层 POSCAR", filetypes=[("POSCAR", "POSCAR"), ("All", "*")])
        if p:
            self.tw_bot_path.set(p)

    def _tw_choose_dir(self):
        d = filedialog.askdirectory(title="选择扫参目录")
        if d:
            self.tw_dir.set(d)
            self._tw_load_dir(d)

    # --- 写演示数据并载入 ---
    def _tw_write_and_load_demo(self):
        d = self.current_project_path() / "twist_sweep"
        try:
            csv_path = self._tw_write_demo_results(d)
            self._tw_append_log(f"演示结果已写入 {csv_path}")
        except Exception as e:
            messagebox.showerror(APP_NAME, f"写入演示数据失败：{e}")
            return
        self.tw_dir.set(str(d))
        self._tw_load_dir(d)

    def _tw_write_demo_results(self, out_dir: Path) -> Path:
        """把内置 DEMO_TWIST_RESULTS 写到 results.csv"""
        out_dir = Path(out_dir)
        out_dir.mkdir(parents=True, exist_ok=True)
        csv_path = out_dir / "results.csv"
        with csv_path.open("w", encoding="utf-8") as f:
            f.write("theta,ux,uy,gap,E,path\n")
            for r in DEMO_TWIST_RESULTS:
                f.write(f"{r['theta']},{r['ux']},{r['uy']},{r['gap']},{r['E']},{r['path']}\n")
        readme = out_dir / "README.txt"
        write_text(
            readme,
            "本目录为演示生成的二维材料扭转/滑移扫参结果（CSV）。\n列含义：theta(°), ux, uy, gap(eV), E(eV), path\n",
        )
        return csv_path

    # --- 载入目录 ---
    def _tw_load_dir(self, dpath: str | Path):
        d = Path(dpath)
        if not d.exists():
            messagebox.showwarning(APP_NAME, f"目录不存在：{d}")
            return
        csv_path = d / "results.csv"
        rows: list[dict] = []
        if csv_path.exists():
            try:
                import csv

                with csv_path.open("r", encoding="utf-8", errors="ignore") as f:
                    reader = csv.DictReader(f)
                    if reader.fieldnames is None:
                        raise ValueError("CSV 缺少表头")
                    for rec in reader:
                        rows.append(self._tw_row_from_dict(rec))
            except Exception as e:
                messagebox.showerror(APP_NAME, f"读取 {csv_path} 失败：{e}")
                return
        else:
            for jf in sorted(d.glob("*.json*")):
                try:
                    txt = jf.read_text(encoding="utf-8", errors="ignore").strip()
                    if not txt:
                        continue
                    if txt.startswith("{"):
                        data = json.loads(txt)
                        rows.append(self._tw_row_from_dict(data))
                    else:
                        for line in txt.splitlines():
                            line = line.strip()
                            if not line:
                                continue
                            data = json.loads(line)
                            rows.append(self._tw_row_from_dict(data))
                except Exception:
                    continue

        rows = [r for r in rows if r]
        if not rows:
            messagebox.showwarning(APP_NAME, f"未在 {d} 发现可用的演示/扫参数据（results.csv 或 json/jsonl）。")
            return

        self.tw_results = rows
        thetas = sorted({round(r["theta"], 6) for r in rows})
        try:
            current_theta = float(self.tw_theta.get())
        except (tk.TclError, TypeError, ValueError):
            current_theta = 0.0
            self.tw_theta.set(current_theta)
        chosen = self._tw_pick_nearest_theta(current_theta, thetas)
        self.tw_theta.set(chosen)
        self._tw_refilter_and_redraw()
        self.tw_info.config(text=f"Loaded {len(rows)} records · theta slice {chosen:.2f}°")

    def _tw_row_from_dict(self, d: dict) -> dict:
        if not isinstance(d, dict):
            return {}

        def _first(keys: tuple[str, ...], default: float | str = 0.0):
            for key in keys:
                if key in d and d[key] not in ("", None):
                    return d[key]
            return default

        try:
            theta = float(_first(("theta", "theta_deg"), 0.0))
            ux = float(_first(("ux",), 0.0))
            uy = float(_first(("uy",), 0.0))
            gap = float(_first(("gap", "gap_eV"), 0.0))
            energy = float(_first(("E", "totalE", "totalE_eV"), 0.0))
        except Exception:
            return {}

        path = str(_first(("path", "name"), ""))
        return {"theta": theta, "ux": ux, "uy": uy, "gap": gap, "E": energy, "path": path}

    def _tw_pick_nearest_theta(self, val: float, thetas: list[float]) -> float:
        if not thetas:
            return 0.0
        return min(thetas, key=lambda t: abs(t - val))

    # --- 过滤并重绘 ---
    def _tw_refilter_and_redraw(self):
        if not getattr(self, "tw_results", None):
            return
        try:
            theta_val = float(self.tw_theta.get())
        except (tk.TclError, TypeError, ValueError):
            theta_val = 0.0
            self.tw_theta.set(theta_val)
        theta = round(theta_val, 6)
        thetas = sorted({round(r["theta"], 6) for r in self.tw_results})
        if theta not in thetas:
            theta = self._tw_pick_nearest_theta(theta, thetas)
            self.tw_theta.set(theta)
        self.tw_filtered = [r for r in self.tw_results if round(r["theta"], 6) == theta]
        self._tw_refresh_tree(self.tw_filtered)
        self._tw_redraw_heatmap(self.tw_filtered)

    def _tw_refresh_tree(self, rows: list[dict]):
        if not hasattr(self, "tw_tree"):
            return
        self.tw_tree.delete(*self.tw_tree.get_children())
        rows_sorted = sorted(rows, key=lambda r: (r["ux"], r["uy"]))
        for r in rows_sorted:
            self.tw_tree.insert(
                "",
                tk.END,
                values=(
                    f"{r['theta']:.2f}",
                    f"{r['ux']:.2f}",
                    f"{r['uy']:.2f}",
                    f"{r['gap']:.3f}",
                    f"{r['E']:.3f}",
                    r["path"],
                ),
            )

    def _tw_redraw_heatmap(self, rows: list[dict]):
        if not hasattr(self, "tw_ax"):
            return
        self.tw_ax.clear()
        if not rows:
            self.tw_ax.set_title("No data available")
            self.tw_canvas.draw_idle()
            return
        xs = [r["ux"] for r in rows]
        ys = [r["uy"] for r in rows]
        cs = [r["gap"] for r in rows]
        sc = self.tw_ax.scatter(xs, ys, c=cs)
        self.tw_ax.set_xlabel("ux")
        self.tw_ax.set_ylabel("uy")
        self.tw_ax.set_title(f"Band gap heatmap (theta={self.tw_theta.get():.2f} deg)")
        if self.tw_cbar is not None:
            try:
                self.tw_cbar.update_normal(sc)
                self.tw_cbar.set_label("gap (eV)")
            except Exception:
                try:
                    self.tw_cbar.remove()
                except Exception:
                    pass
                self.tw_cbar = self.tw_fig.colorbar(sc, ax=self.tw_ax, label="gap (eV)")
        else:
            self.tw_cbar = self.tw_fig.colorbar(sc, ax=self.tw_ax, label="gap (eV)")
        apply_style(self.tw_ax, _normalize_style(self.figure_style_var.get()))
        self.tw_fig.tight_layout()
        self.tw_canvas.draw_idle()

    # --- 表格选择 ---
    def _on_tw_tree_select(self, _evt=None):
        sel = self.tw_tree.selection()
        if not sel:
            return
        vals = self.tw_tree.item(sel[0], "values")
        try:
            self.tw_theta.set(float(vals[0]))
            self.tw_ux.set(float(vals[1]))
            self.tw_uy.set(float(vals[2]))
        except Exception:
            pass

    # --- 导出当前切片 CSV ---
    def _tw_export_slice_csv(self):
        if not getattr(self, "tw_filtered", None):
            messagebox.showwarning(APP_NAME, "当前 θ 切片为空。")
            return
        p = filedialog.asksaveasfilename(
            defaultextension=".csv",
            filetypes=[("CSV", "*.csv")],
            title="导出当前θ切片为 CSV",
        )
        if not p:
            return
        with open(p, "w", encoding="utf-8") as f:
            f.write("theta,ux,uy,gap,E,path\n")
            for r in self.tw_filtered:
                f.write(f"{r['theta']},{r['ux']},{r['uy']},{r['gap']},{r['E']},{r['path']}\n")
        messagebox.showinfo(APP_NAME, f"已导出：{p}")

    # === 2D 滑移/扭转载：页面 + 演示数据 + 可视化（最小可用版） END ===============

    # === POST: twist/slide maps & curves =========================================
    def _tw_load_results_table(self, root: Optional[Path] = None) -> List[Dict[str, Any]]:
        """加载 twist_sweep/results.csv；若不存在先调用 _tw_collect_results() 生成。"""
        root = root or (self.current_project_path() / "twist_sweep")
        csv_path = root / "results.csv"
        if not csv_path.exists():
            if self.demo_mode:
                try:
                    self._tw_write_demo_results(root)
                except Exception as exc:
                    messagebox.showerror(APP_NAME, f"生成演示数据失败：{exc}")
                    return []
            try:
                self._tw_collect_results()
            except Exception as e:
                messagebox.showerror(APP_NAME, f"缺少 results.csv 且自动收集失败：{e}")
                return []
        rows: List[Dict[str, Any]] = []
        try:
            import csv

            with csv_path.open("r", encoding="utf-8") as f:
                reader = csv.DictReader(f)
                for rec in reader:
                    try:
                        gap_val = rec.get("gap")
                        if gap_val in (None, ""):
                            gap_val = rec.get("gap_eV")
                        energy_val = rec.get("E")
                        if energy_val in (None, ""):
                            energy_val = rec.get("totalE_eV")
                        rows.append(
                            {
                                "theta": float(rec.get("theta") or "nan"),
                                "ux": float(rec.get("ux") or "nan"),
                                "uy": float(rec.get("uy") or "nan"),
                                "gap": float(gap_val or "nan"),
                                "E": float(energy_val or "nan"),
                                "path": rec.get("path", ""),
                                "note": rec.get("note", ""),
                            }
                        )
                    except Exception:
                        pass
        except Exception as e:
            messagebox.showerror(APP_NAME, f"读取 {csv_path} 失败：{e}")
            return []
        rows = [
            r
            for r in rows
            if (not math.isnan(r["theta"]))
            and (not math.isnan(r["ux"]))
            and (not math.isnan(r["uy"]))
        ]
        return rows

    def _tw_plot_gap_heatmap_btn(self):
        """按钮：用当前 θ（输入框 tw_theta_a）画 gap(u_x,u_y) 热图。"""

        try:
            theta = float(self.tw_theta_a.get())
        except Exception:
            messagebox.showwarning(APP_NAME, "当前 θ 无效。")
            return
        self._tw_plot_gap_heatmap(theta)

    def _tw_plot_gap_heatmap(self, theta: float):
        """固定 θ，画 gap 在 (ux,uy) 网格上的热图。"""

        if not HAS_NUMPY:
            messagebox.showerror(APP_NAME, "需要 numpy 才能绘制热图。")
            return
        import numpy as np

        rows = [
            r
            for r in self._tw_load_results_table()
            if abs((r["theta"] or 0.0) - theta) < 1e-6
        ]
        if not rows:
            messagebox.showwarning(APP_NAME, f"未在 results.csv 中找到 θ={theta} 的数据。")
            return

        ux_vals = sorted({round(r["ux"], 6) for r in rows})
        uy_vals = sorted({round(r["uy"], 6) for r in rows})
        nx, ny = len(ux_vals), len(uy_vals)
        grid = np.full((ny, nx), np.nan, dtype=float)
        ux_index = {v: j for j, v in enumerate(ux_vals)}
        uy_index = {v: i for i, v in enumerate(uy_vals)}

        for r in rows:
            g = r.get("gap", float("nan"))
            if g is None or math.isnan(g):
                continue
            j = ux_index.get(round(r["ux"], 6))
            i = uy_index.get(round(r["uy"], 6))
            if i is not None and j is not None:
                grid[i, j] = g

        top = tk.Toplevel(self)

        top.title(f"Band gap heatmap @ θ={theta:.2f}°")
        fig = Figure(figsize=(6.2, 5.2), dpi=110)
        ax = fig.add_subplot(111)
        im = ax.imshow(
            grid,
            origin="lower",
            extent=[min(ux_vals), max(ux_vals), min(uy_vals), max(uy_vals)],
            aspect="equal",
        )
        cbar = fig.colorbar(im, ax=ax)
        cbar.set_label("Band gap (eV)")
        ax.set_xlabel("u_x")
        ax.set_ylabel("u_y")
        ax.set_title(f"Band gap heatmap @ θ={theta:.2f}°  (N={int(np.isfinite(grid).sum())})")
        apply_style(ax, _normalize_style(self.figure_style_var.get()))
        fig.tight_layout()
        canvas = FigureCanvasTkAgg(fig, master=top)
        canvas.draw()
        canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)

        def _save():
            outdir = self.current_project_path() / "reports"
            outdir.mkdir(parents=True, exist_ok=True)
            png_path = outdir / f"gap_heatmap_theta_{theta:.2f}.png"
            csv_path = outdir / f"gap_heatmap_theta_{theta:.2f}.csv"
            try:
                fig.savefig(png_path, dpi=300)
                with csv_path.open("w", encoding="utf-8") as f:
                    f.write("uy,ux,gap_eV\n")
                    for i, uy in enumerate(uy_vals):
                        for j, ux in enumerate(ux_vals):
                            val = grid[i, j]
                            if math.isnan(val):
                                continue
                            f.write(f"{uy:.6f},{ux:.6f},{val:.6f}\n")
                messagebox.showinfo(APP_NAME, f"已导出\n{png_path}\n{csv_path}")
            except Exception as e:
                messagebox.showerror(APP_NAME, f"导出失败：{e}")

        ttk.Button(top, text="导出 PNG/CSV", command=_save).pack(pady=6)

    def _tw_plot_gap_vs_theta_btn(self):
        """按钮：汇总所有 θ 的 min/mean/max gap，画曲线 + 阴影带；并导出 CSV。"""

        self._tw_plot_gap_vs_theta()

    def _tw_plot_gap_vs_theta(self):
        if not HAS_NUMPY:
            messagebox.showerror(APP_NAME, "需要 numpy 才能绘制曲线。")
            return
        import numpy as np

        rows = self._tw_load_results_table()
        if not rows:
            return
        by_theta: Dict[float, List[float]] = {}
        for r in rows:
            g = r.get("gap", float("nan"))
            if g is None or math.isnan(g):
                continue
            th = round(r.get("theta", float("nan")), 6)
            if math.isnan(th):
                continue
            by_theta.setdefault(th, []).append(float(g))
        thetas = sorted(by_theta.keys())
        if not thetas:
            messagebox.showwarning(APP_NAME, "结果中没有有效的带隙。")
            return
        g_min = np.array([np.min(by_theta[t]) for t in thetas], dtype=float)
        g_max = np.array([np.max(by_theta[t]) for t in thetas], dtype=float)
        g_mean = np.array([np.mean(by_theta[t]) for t in thetas], dtype=float)

        top = tk.Toplevel(self)

        top.title("Band gap vs. twist angle (min/mean/max)")
        fig = Figure(figsize=(6.4, 4.6), dpi=110)
        ax = fig.add_subplot(111)
        ax.plot(thetas, g_mean, label="mean gap")
        ax.fill_between(thetas, g_min, g_max, alpha=0.25, label="range [min, max]")
        ax.set_xlabel("Twist angle θ (deg)")
        ax.set_ylabel("Band gap (eV)")
        ax.set_title("Band gap vs. twist angle\n(shaded band = variation across slide grid)")
        ax.legend()
        apply_style(ax, _normalize_style(self.figure_style_var.get()))
        fig.tight_layout()
        canvas = FigureCanvasTkAgg(fig, master=top)
        canvas.draw()
        canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)

        def _save():
            outdir = self.current_project_path() / "reports"
            outdir.mkdir(parents=True, exist_ok=True)
            csv_path = outdir / "gap_vs_theta_min_mean_max.csv"
            png_path = outdir / "gap_vs_theta_min_mean_max.png"
            try:
                with csv_path.open("w", encoding="utf-8") as f:
                    f.write("theta_deg,gap_min_eV,gap_mean_eV,gap_max_eV,range_eV\n")
                    for t, mn, me, mx in zip(thetas, g_min, g_mean, g_max):
                        f.write(f"{t:.6f},{mn:.6f},{me:.6f},{mx:.6f},{(mx - mn):.6f}\n")
                fig.savefig(png_path, dpi=300)
                messagebox.showinfo(APP_NAME, f"已导出\n{png_path}\n{csv_path}")
            except Exception as e:
                messagebox.showerror(APP_NAME, f"导出失败：{e}")

        ttk.Button(top, text="导出 PNG/CSV", command=_save).pack(pady=6)

    # === END POST ================================================================

    # ------------------------- 页面：流程助手 ------------------------------
    def _build_workflow_page(self, parent):
        frame = ttk.Frame(parent)

        intro = ttk.Label(
            frame,
            text="按照从上到下的步骤完成一次 VASP 计算，可点击按钮快速跳转到对应面板。",
            wraplength=900,
            justify=tk.LEFT,
        )
        intro.pack(fill=tk.X, padx=12, pady=8)

        status_box = ttk.LabelFrame(frame, text="当前项目状态")
        status_box.pack(fill=tk.BOTH, expand=False, padx=12, pady=6)

        status_row = ttk.Frame(status_box)
        status_row.pack(fill=tk.X, padx=8, pady=6)
        ttk.Label(status_row, text="运行状态：").pack(side=tk.LEFT)
        ttk.Label(status_row, textvariable=self.run_status_var).pack(side=tk.LEFT, padx=4)
        ttk.Button(status_row, text="刷新状态", command=self.refresh_run_status).pack(side=tk.RIGHT)

        tree_frame = ttk.Frame(status_box)
        tree_frame.pack(fill=tk.BOTH, expand=True, padx=8, pady=(0, 6))
        columns = ("name", "status", "detail")
        self.workflow_tree = ttk.Treeview(tree_frame, columns=columns, show="headings", height=6)
        self.workflow_tree.heading("name", text="项目项")
        self.workflow_tree.heading("status", text="状态")
        self.workflow_tree.heading("detail", text="详情")
        self.workflow_tree.column("name", width=120, anchor=tk.W)
        self.workflow_tree.column("status", width=120, anchor=tk.W)
        self.workflow_tree.column("detail", anchor=tk.W, stretch=True)
        tree_scroll = ttk.Scrollbar(tree_frame, orient=tk.VERTICAL, command=self.workflow_tree.yview)
        self.workflow_tree.configure(yscrollcommand=tree_scroll.set)
        self.workflow_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        tree_scroll.pack(side=tk.RIGHT, fill=tk.Y)

        sugg = ttk.Frame(status_box)
        sugg.pack(fill=tk.BOTH, expand=False, padx=8, pady=(0, 6))
        ttk.Label(sugg, text="运行建议：").pack(anchor=tk.W)
        wf_suggest = ScrolledText(sugg, height=4, wrap="word", state="disabled")
        wf_suggest.pack(fill=tk.X, expand=True)
        self._register_suggestion_widget(wf_suggest)

        steps = [
            (
                "① 准备项目目录",
                "选择/新建项目文件夹，所有输入输出文件都保存在此处。",
                [
                    ("选择项目", self.choose_project),
                    ("新建项目", self.create_project),
                    ("快速体检", self.quick_check),
                ],
                self.page_inputs,
            ),
            (
                "② 编辑输入文件",
                "填写 INCAR、POSCAR、KPOINTS 等输入，确保必要信息完整。",
                [
                    ("跳转到输入面板", lambda: self.goto_tab(self.page_inputs)),
                    ("跳转到 K 点设置", lambda: self.goto_tab(self.page_inputs)),
                ],
                self.page_inputs,
            ),
            (
                "③ 准备 POTCAR",
                "解析 POSCAR 元素并在 POTCAR 面板一键拼接所需赝势。",
                [
                    ("跳转到 POTCAR", lambda: self.goto_tab(self.page_inputs)),
                    ("解析元素", self.show_poscar_elements),
                ],
                self.page_inputs,
            ),
            (
                "④ 配置运行方式",
                "根据实际环境选择本地/WSL/SLURM 运行，并生成脚本。",
                [
                    ("跳转到运行页", lambda: self.goto_tab(self.page_run)),
                    ("生成运行脚本", self.write_job_script),
                ],
                self.page_run,
            ),
            (
                "⑤ 启动并监视",
                "启动计算后，利用监视页关注能量收敛、CPU 使用率及文件增长。",
                [
                    ("启动/提交", self.start_run),
                    ("跳转到监视", lambda: self.goto_tab(self.page_monitor)),
                    ("开始监视", self.start_monitor),
                ],
                self.page_monitor,
            ),
            (
                "⑥ 后处理与结果",
                "提取最终能量或绘制一次性曲线，整理输出文件。",
                [
                    ("跳转到后处理", lambda: self.goto_tab(self.page_post)),
                    ("提取最终能量", self.extract_final_energy),
                ],
                self.page_post,
            ),
        ]

        steps_frame = ttk.Frame(frame)
        steps_frame.pack(fill=tk.BOTH, expand=True, padx=12, pady=6)
        steps_frame.grid_columnconfigure(0, weight=1)
        steps_frame.grid_columnconfigure(1, weight=1)
        for idx, (title, desc, buttons, page) in enumerate(steps):
            row, col = divmod(idx, 2)
            box = ttk.LabelFrame(steps_frame, text=title)
            box.grid(row=row, column=col, sticky="nsew", padx=6, pady=6)
            ttk.Label(box, text=desc, justify=tk.LEFT, wraplength=360).pack(anchor=tk.W, padx=8, pady=4)
            row_frame = ttk.Frame(box)
            row_frame.pack(anchor=tk.W, padx=8, pady=4)
            for txt, cmd in buttons:
                ttk.Button(row_frame, text=txt, command=cmd).pack(side=tk.LEFT, padx=4)
            ttk.Button(row_frame, text="打开此面板", command=lambda p=page: self.goto_tab(p)).pack(side=tk.LEFT, padx=8)

        notes = ttk.LabelFrame(frame, text="流程备注 / 待办")
        notes.pack(fill=tk.BOTH, expand=True, padx=12, pady=8)
        self.workflow_notes = ScrolledText(notes, height=8, wrap="word")
        self.workflow_notes.pack(fill=tk.BOTH, expand=True, padx=6, pady=6)
        self.workflow_notes.insert(
            tk.END,
            "可在此记录当前任务的特殊参数、检查列表或备注。内容不会自动保存。",
        )
        return frame

    def kpoints_to_editor(self):
        s = gen_kpoints_monkhorst(self.k_nx.get(), self.k_ny.get(), self.k_nz.get(), self.k_gamma.get())
        self.kpoints_text.delete("1.0", tk.END)
        self.kpoints_text.insert("1.0", s)

    def kpoints_save(self):
        proj = self.current_project_path()
        proj.mkdir(parents=True, exist_ok=True)
        s = self.kpoints_text.get("1.0", tk.END)
        write_text(proj / "KPOINTS", s)
        messagebox.showinfo(APP_NAME, f"KPOINTS 已保存到 {proj/'KPOINTS'}")
        self.refresh_project_overview()

    def goto_tab(self, page):
        try:
            self.nb.select(page)
        except Exception:
            pass


    def append_run_log(self, msg: str):
        text = (msg or "")
        lines = text.splitlines() or [""]
        for line in lines:
            self.run_log.insert(tk.END, line.rstrip("\n") + "\n")
        self.run_log.see(tk.END)

    # ====== 非阻塞跟随 vasp.out 到 GUI ======
    def _start_following_log(self, log_path: Path, interval_ms: int = 500):
        """非阻塞跟随 log_path，将新增内容追加到 self.run_log。"""
        self._log_path = Path(log_path)
        self._tail_pos = 0
        self._tail_interval = int(interval_ms)
        # 若之前有定时任务，先取消
        if hasattr(self, "_tail_job") and self._tail_job:
            try:
                self.after_cancel(self._tail_job)
            except Exception:
                pass
        # 立即触发一次
        self._follow_log_tick()

    def _follow_log_tick(self):
        chunk = ""
        try:
            with open(self._log_path, "r", encoding="utf-8", errors="ignore") as f:
                f.seek(getattr(self, "_tail_pos", 0))
                chunk = f.read(64 * 1024)  # 每 tick 最多 64KB
                self._tail_pos = f.tell()
        except FileNotFoundError:
            pass
        except Exception as e:
            chunk = f"[log-follow] 读取失败：{e}\n"
        if chunk:
            self.append_run_log(chunk)
        self._tail_job = self.after(getattr(self, "_tail_interval", 500), self._follow_log_tick)

    def _stop_following_log(self):
        if hasattr(self, "_tail_job") and self._tail_job:
            try:
                self.after_cancel(self._tail_job)
            except Exception:
                pass
            self._tail_job = None

    def _int_from_var(self, var, default=0) -> int:
        try:
            value = var.get()
        except Exception:
            value = default
        try:
            return int(value)
        except Exception:
            try:
                return int(default)
            except Exception:
                return 0

    # ------------------------- 页面：运行 / 提交 ----------------------------
    def _build_run_page(self, parent):
        frame = ttk.Frame(parent)

        status = ttk.LabelFrame(frame, text="运行状态")
        status.pack(fill=tk.X, padx=8, pady=6)
        row = ttk.Frame(status)
        row.pack(fill=tk.X, padx=6, pady=4)
        ttk.Label(row, text="当前状态：").pack(side=tk.LEFT)
        ttk.Label(row, textvariable=self.run_status_var).pack(side=tk.LEFT, padx=4)
        ttk.Button(row, text="刷新状态", command=self.refresh_run_status).pack(side=tk.RIGHT)
        run_suggest = ScrolledText(status, height=3, wrap="word", state="disabled")
        run_suggest.pack(fill=tk.X, padx=6, pady=(0, 6))
        self._register_suggestion_widget(run_suggest)

        # 运行方式
        row0 = ttk.LabelFrame(frame, text="运行方式")
        row0.pack(fill=tk.X, padx=8, pady=8)
        self.run_mode = tk.StringVar(value="local")
        ttk.Radiobutton(row0, text="本地 mpirun", value="local", variable=self.run_mode).pack(side=tk.LEFT, padx=8)
        ttk.Radiobutton(row0, text="WSL2 (Windows)", value="wsl", variable=self.run_mode).pack(side=tk.LEFT, padx=8)
        ttk.Radiobutton(row0, text="SLURM 集群", value="slurm", variable=self.run_mode).pack(side=tk.LEFT)

        # VASP 执行文件 & 核心数
        row1 = ttk.LabelFrame(frame, text="VASP 执行配置")
        row1.pack(fill=tk.X, padx=8, pady=4)
        ttk.Label(row1, text="VASP 命令").grid(row=0, column=0, sticky=tk.W, padx=6, pady=4)
        self.vasp_cmd = tk.StringVar(value="vasp_std")
        ttk.Entry(row1, textvariable=self.vasp_cmd, width=30).grid(row=0, column=1, sticky=tk.W)
        ttk.Button(row1, text="which?", command=self.which_vasp).grid(row=0, column=2, padx=6)

        ttk.Label(row1, text="MPI 进程数 -np").grid(row=1, column=0, sticky=tk.W, padx=6, pady=4)
        self.mpi_np = tk.IntVar(value=8)
        # 新增：自动并行
        self.auto_parallel = tk.BooleanVar(value=True)
        ttk.Checkbutton(row1, text="自动并行（智能设置 KPAR/NCORE）",
                        variable=self.auto_parallel).grid(row=2, column=0, columnspan=3, sticky=tk.W, padx=6)
        ttk.Spinbox(row1, from_=1, to=2048, textvariable=self.mpi_np, width=8).grid(row=1, column=1, sticky=tk.W)

        # SLURM 区域
        row2 = ttk.LabelFrame(frame, text="SLURM 提交（仅在选择 SLURM 运行时使用）")
        row2.pack(fill=tk.X, padx=8, pady=4)
        self.slurm_part = tk.StringVar(value="normal")
        self.slurm_time = tk.StringVar(value="02:00:00")
        self.slurm_nodes = tk.IntVar(value=1)
        self.slurm_ntasks = tk.IntVar(value=32)
        self.slurm_account = tk.StringVar(value="")
        ttk.Label(row2, text="分区").grid(row=0, column=0, sticky=tk.W, padx=6, pady=4)
        ttk.Entry(row2, textvariable=self.slurm_part, width=12).grid(row=0, column=1)
        ttk.Label(row2, text="时长").grid(row=0, column=2, sticky=tk.W, padx=6)
        ttk.Entry(row2, textvariable=self.slurm_time, width=12).grid(row=0, column=3)
        ttk.Label(row2, text="节点").grid(row=0, column=4, sticky=tk.W, padx=6)
        ttk.Spinbox(row2, from_=1, to=128, textvariable=self.slurm_nodes, width=6).grid(row=0, column=5)
        ttk.Label(row2, text="ntasks").grid(row=0, column=6, sticky=tk.W, padx=6)
        ttk.Spinbox(row2, from_=1, to=8192, textvariable=self.slurm_ntasks, width=8).grid(row=0, column=7)
        ttk.Label(row2, text="账号").grid(row=0, column=8, sticky=tk.W, padx=6)
        ttk.Entry(row2, textvariable=self.slurm_account, width=12).grid(row=0, column=9)

        btns = ttk.Frame(frame)
        btns.pack(fill=tk.X, padx=8, pady=8)
        ttk.Button(btns, text="生成运行脚本", command=self.write_job_script).pack(side=tk.LEFT)
        ttk.Button(btns, text="启动/提交", command=self.start_run).pack(side=tk.LEFT, padx=8)
        ttk.Button(btns, text="停止本地进程", command=self.stop_local).pack(side=tk.LEFT)

        self.run_log = ScrolledText(frame, height=14, wrap="word")
        self.run_log.pack(fill=tk.BOTH, expand=True, padx=8, pady=8)

        return frame

    @staticmethod
    def is_windows() -> bool:
        return os.name == "nt" or sys.platform.startswith("win")

    def win_to_wsl_path(self, p: Path) -> str:
        # 将 Windows 路径 C:\foo\bar 转为 /mnt/c/foo/bar
        s = str(p)
        if len(s) >= 2 and s[1] == ":":
            drive = s[0].lower()
            rest = s[2:].replace("\\", "/")
            return f"/mnt/{drive}{rest if rest.startswith('/') else '/' + rest}"
        return s.replace("\\", "/")

    def which_vasp(self):
        cmd = self.vasp_cmd.get().strip()
        path = which(cmd)
        if path:
            messagebox.showinfo(APP_NAME, f"{cmd} -> {path}")
        else:
            messagebox.showwarning(APP_NAME, f"未在 PATH 中找到 {cmd}")

    def write_job_script(self):
        """生成 run_local.sh / run_slurm.sh（含自动并行设置与稳健环境）。"""
        proj = self.current_project_path()
        proj.mkdir(parents=True, exist_ok=True)

        # —— 可选额外库（只拼接存在的路径，不会写坏环境）——
        extra_libs = []
        for pth in ["/home/yu/apps/aocl/4.1.0/aocc/lib",
                    "/home/yu/apps/aocc-compiler-4.1.0/lib"]:
            try:
                if Path(pth).exists():
                    extra_libs.append(pth)
            except Exception:
                pass
        extra_ld = ":".join(extra_libs)

        ld_line = (f'export LD_LIBRARY_PATH="{extra_ld}:${{LD_LIBRARY_PATH}}"\n'
                   if extra_ld else 'export LD_LIBRARY_PATH="${LD_LIBRARY_PATH:-}"\n')

        env_lines = (
            "# --- Runtime environment (auto generated) ---\n"
            ': "${LD_LIBRARY_PATH:=}"\n'
            f"{ld_line}"
            'export OMP_NUM_THREADS="${OMP_NUM_THREADS:-1}"\n'
            'export OMP_PROC_BIND="${OMP_PROC_BIND:-true}"\n'
            'export OMP_PLACES="${OMP_PLACES:-cores}"\n'
        )

        vcmd = (self.vasp_cmd.get().strip() if hasattr(self, "vasp_cmd") else "") or "vasp_std"
        mpirun_path = which("mpirun") or "mpirun"
        try:
            np = int(self.mpi_np.get()) if hasattr(self, "mpi_np") else 8
        except Exception:
            np = 8

        # —— 自动并行：写回 KPAR/NCORE（若提供了开关或未提供也尝试）——
        try:
            if hasattr(self, "auto_parallel"):
                if self.auto_parallel.get():
                    self._autotune_parallel_and_write(np)
            else:
                # 没有勾选框也尽量自动一次，不报错即可
                if hasattr(self, "_autotune_parallel_and_write"):
                    self._autotune_parallel_and_write(np)
        except Exception as e:
            self.append_run_log(f"[auto-parallel] 失败：{e}")

        # ===== 本地 run_local.sh =====
        local_script = f"""#!/bin/bash
    set -euo pipefail

    {env_lines}
    cd "{proj}"

    echo "[INFO] Workdir: $(pwd)"
    echo "[INFO] Using mpirun: {mpirun_path}"
    echo "[INFO] VASP cmd    : {vcmd}"
    echo "[INFO] NP          : {np}"
    echo "[INFO] LD_LIBRARY_PATH=$LD_LIBRARY_PATH"
    echo "[INFO] OMP_NUM_THREADS=$OMP_NUM_THREADS"

    # 降低调度与 I/O 优先级；并把 MPI 绑定到 core，降低任务迁移开销
    # 动态选择绑定策略：超过物理核数就用硬件线程
PHYS_CORES=$(lscpu -p=CORE 2>/dev/null | egrep -v '^#' | cut -d, -f2 | sort -u | wc -l | tr -d ' ')
if [ -n "$PHYS_CORES" ] && [ "$PHYS_CORES" -gt 0 ] && [ "{np}" -gt "$PHYS_CORES" ]; then
  BIND="--use-hwthread-cpus --bind-to hwthread --map-by ppr:1:hwthread"
else
  BIND="--bind-to core --map-by ppr:1:core"
fi

nice -n 5 ionice -c2 -n4 \
{mpirun_path} $BIND -np {np} {vcmd} > vasp.out 2>&1

    """

        # ===== SLURM run_slurm.sh =====
        slurm_part = self.slurm_part.get().strip() if hasattr(self, "slurm_part") else "normal"
        slurm_time = self.slurm_time.get().strip() if hasattr(self, "slurm_time") else "02:00:00"
        try:
            slurm_nodes = int(self.slurm_nodes.get()) if hasattr(self, "slurm_nodes") else 1
        except Exception:
            slurm_nodes = 1
        try:
            slurm_ntasks = int(self.slurm_ntasks.get()) if hasattr(self, "slurm_ntasks") else max(np, 1)
        except Exception:
            slurm_ntasks = max(np, 1)
        slurm_account = (self.slurm_account.get().strip() if hasattr(self, "slurm_account") else "")
        acc_line = f"#SBATCH --account={slurm_account}\n" if slurm_account else ""

        slurm_script = f"""#!/bin/bash
    #SBATCH --job-name=vasp
    #SBATCH --partition={slurm_part}
    #SBATCH --time={slurm_time}
    #SBATCH --nodes={slurm_nodes}
    #SBATCH --ntasks={slurm_ntasks}
    {acc_line}set -euo pipefail

    {env_lines}
    cd "{proj}"

    echo "SLURM_JOB_ID=$SLURM_JOB_ID"
    echo "[INFO] Workdir: $(pwd)"
    echo "[INFO] VASP cmd: {vcmd}"
    echo "[INFO] ntasks  : $SLURM_NTASKS"
    echo "[INFO] LD_LIBRARY_PATH=$LD_LIBRARY_PATH"
    echo "[INFO] OMP_NUM_THREADS=$OMP_NUM_THREADS"

    # 绑定到物理核，避免过度超线程导致的抖动
    srun --cpu-bind=cores {vcmd} > vasp.out 2>&1
    """

        # —— 写文件并授权 ——
        try:
            write_text(proj / "run_local.sh", local_script)
            os.chmod(proj / "run_local.sh", 0o755)
            self.append_run_log(f"已生成 {proj / 'run_local.sh'}")
        except Exception as e:
            self.append_run_log(f"[EXC] 写 run_local.sh 失败：{e}")

        try:
            write_text(proj / "run_slurm.sh", slurm_script)
            os.chmod(proj / "run_slurm.sh", 0o755)
            self.append_run_log(f"已生成 {proj / 'run_slurm.sh'}")
        except Exception as e:
            self.append_run_log(f"[EXC] 写 run_slurm.sh 失败：{e}")

        # 刷新界面状态
        self.refresh_project_overview()

    def start_run(self):
        proj = self.current_project_path()
        mode = self.run_mode.get()
        vcmd = self.vasp_cmd.get().strip()

        if not proj.exists():
            messagebox.showerror(APP_NAME, f"项目目录不存在：{proj}")
            return

        # 关键输入文件缺失时提示，但允许继续
        missing = [f for f in ["INCAR", "POSCAR", "POTCAR"] if not (proj / f).exists()]
        if missing:
            if not messagebox.askyesno(
                    APP_NAME,
                    "检测到以下关键输入文件缺失：\n"
                    + "\n".join(missing)
                    + "\n仍要继续启动吗？",
            ):
                return

        if mode == "local":
            # 防止重复起
            if self.proc and self.proc.poll() is None:
                messagebox.showwarning(APP_NAME, "已有本地 VASP 进程在运行。先停止或等待结束。")
                return

            # 基础可用性检查
            if not which("mpirun"):
                messagebox.showerror(APP_NAME, "未找到 mpirun。请安装 OpenMPI/IntelMPI 并加入 PATH。")
                return
            if not which(vcmd):
                messagebox.showerror(APP_NAME, f"未找到 VASP 命令：{vcmd}\n可改填绝对路径，例如 /opt/vasp/vasp_std")
                return

            # 总是重写一次脚本，确保环境最新
            self.write_job_script()
            # 替换 start_run() 内 local 分支里 “后台运行脚本” 那一段
            runsh = proj / "run_local.sh"
            try:
                # 使用 Popen 非阻塞启动脚本本身，而不是在主线程里 check_output
                self.proc = subprocess.Popen(
                    ["bash", "-lc", f"cd '{proj}' && exec './{runsh.name}'"],
                    stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL,
                    start_new_session=True  # 关键：新会话，便于后续整组终止
                )
                self.append_run_log(f"[run_local.sh pid] {self.proc.pid}")

                # 启动非阻塞日志跟随
                self._start_following_log(proj / "vasp.out")
                self.append_run_log("日志跟随 vasp.out（非阻塞）已启动。\n")

                # 改为 after 定时健康检查（避免 time.sleep 阻塞 Tk）
                def _health_check():
                    vout = proj / "vasp.out"
                    if not vout.exists() or vout.stat().st_size == 0:
                        # 再等 2 秒复查一次
                        self.after(2000, _health_check)
                        return
                    # 有输出就启动监视器
                    self.start_monitor()

                self.after(1500, _health_check)

            except Exception as e:
                self.append_run_log(f"[EXC] 启动失败：{e}")
                messagebox.showerror(APP_NAME, f"启动失败：{e}")
                return

        elif mode == "wsl":
            messagebox.showerror(APP_NAME, "WSL 分支未内置 AOCL/AOCC 环境设置，请使用本地或 SLURM。")
            return

        else:
            # SLURM：写脚本并 sbatch
            if not which("sbatch"):
                messagebox.showerror(APP_NAME, "未找到 sbatch。请在 SLURM 节点上运行或配置环境。")
                return
            self.write_job_script()
            script = proj / "run_slurm.sh"
            try:
                out = subprocess.check_output(["bash", "-lc", f"cd '{proj}' && sbatch '{script.name}'"], text=True)
                if out:
                    self.append_run_log(out)
                self.start_monitor()
            except subprocess.CalledProcessError as e:
                messagebox.showerror(APP_NAME, f"sbatch 失败：{e}{e.output}")

    def stop_local(self):
        try:
            if self.proc and self.proc.poll() is None:
                # 发送到整组（需要 start_new_session=True）
                os.killpg(os.getpgid(self.proc.pid), 15)  # SIGTERM
                time.sleep(0.5)
                if self.proc.poll() is None:
                    os.killpg(os.getpgid(self.proc.pid), 9)  # SIGKILL
                self.append_run_log("已停止本地 VASP 进程组。\n")
            else:
                # 兜底：旧行为
                subprocess.call(["bash", "-lc", f"pkill -f 'vasp' || true"])
                self.append_run_log("已尝试 pkill -f 'vasp'。\n")
            self.refresh_run_status()
        except Exception as e:
            messagebox.showerror(APP_NAME, f"停止失败：{e}")

    # ------------------------- 页面：监视 ----------------------------------
    def _build_monitor_page(self, parent):
        frame = ttk.Frame(parent)

        status_box = ttk.LabelFrame(frame, text="运行状态概览")
        status_box.pack(fill=tk.X, padx=8, pady=10)
        row = ttk.Frame(status_box)
        row.pack(fill=tk.X, padx=6, pady=8)
        ttk.Label(row, text="当前状态：").pack(side=tk.LEFT)
        ttk.Label(row, textvariable=self.run_status_var).pack(side=tk.LEFT, padx=4)
        ttk.Button(row, text="刷新状态", command=self.refresh_run_status).pack(side=tk.RIGHT)
        monitor_suggest = ScrolledText(status_box, height=3, wrap="word", state="disabled")
        monitor_suggest.pack(fill=tk.X, padx=6, pady=(2, 8))
        self._register_suggestion_widget(monitor_suggest)

        top = ttk.Frame(frame)
        top.pack(fill=tk.X, padx=8, pady=6)
        ttk.Button(top, text="开始监视", command=self.start_monitor).pack(side=tk.LEFT)
        ttk.Button(top, text="停止监视", command=self.stop_monitor).pack(side=tk.LEFT, padx=6)
        ttk.Label(top, text="文件列表(逗号分隔)").pack(side=tk.LEFT, padx=6)
        self.file_watch_var = tk.StringVar(value="vasp.out,OSZICAR,OUTCAR")
        ttk.Entry(top, textvariable=self.file_watch_var, width=36).pack(side=tk.LEFT)

        fig = Figure(figsize=(6, 4), dpi=100)
        self.ax = fig.add_subplot(111)
        self.ax.set_xlabel("Step")
        self.ax.set_ylabel("Total energy (F or E0) [eV]")
        self.ax.grid(True, linestyle=":", linewidth=0.8)
        self.line, = self.ax.plot([], [], marker="o", linestyle="-")

        self.canvas = FigureCanvasTkAgg(fig, master=frame)
        self.canvas.draw()
        self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True, padx=8, pady=8)

        self.mon_info = ScrolledText(frame, height=6, wrap="word")
        self.mon_info.pack(fill=tk.BOTH, expand=False, padx=8, pady=4)

        sys_frame = ttk.LabelFrame(frame, text="系统状态：CPU / 进程 / 文件增长")
        sys_frame.pack(fill=tk.BOTH, expand=False, padx=8, pady=6)
        self.sys_info = ScrolledText(sys_frame, height=10, wrap="word")
        self.sys_info.pack(fill=tk.BOTH, expand=True, padx=6, pady=6)

        self.sys_info.insert(tk.END, "点击“开始监视”以获取实时系统信息。\n")

        return frame

    def start_monitor(self):
        self.stop_monitor()
        proj = self.current_project_path()
        self.monitor = EnergyMonitor(proj, self.on_energy_update)
        self.monitor.start()
        self.mon_info.insert(tk.END, f"开始监视 {proj / 'OSZICAR'}\n")
        self.mon_info.see(tk.END)
        watch_files = [s.strip() for s in self.file_watch_var.get().split(",") if s.strip()]
        self.sys_monitor = SystemStatsMonitor(proj, watch_files, self.on_system_update)
        self.sys_monitor.start()
        self.sys_info.delete("1.0", tk.END)
        self.sys_info.insert(tk.END, "系统监视线程已启动……\n")
        self.apply_run_status("🟡 正在监视…", ["系统监视线程已启动，等待数据更新。"])

    def stop_monitor(self):
        if self.monitor:
            self.monitor.stop()
            self.monitor = None
        if self.sys_monitor:

            monitor = self.sys_monitor
            self.sys_monitor = None
            monitor.stop()
        self.mon_info.insert(tk.END, "已停止监视。\n")
        self.mon_info.see(tk.END)
        self.sys_info.insert(tk.END, "系统监视已停止。\n")
        self.refresh_run_status()
        self._stop_following_log()

    def on_energy_update(self, steps, energies):
        def _upd():
            # 初始化坐标轴标签只做一次
            if not hasattr(self, "_plot_inited"):
                self.ax.set_xlabel("Step")
                self.ax.set_ylabel("Total energy (F or E0) [eV]")
                self.ax.grid(True, linestyle=":", linewidth=0.8)
                self._plot_inited = True

            # ★ 不再 cla：直接更新 Line2D 数据
            self.line.set_data(steps or [], energies or [])
            self.ax.relim()
            self.ax.autoscale_view()

            self.canvas.draw_idle()
            # 保证布局立即刷新
            self.canvas.get_tk_widget().update_idletasks()

            if energies:
                self.mon_info.insert(tk.END, f"最新步：{steps[-1]}, 能量：{energies[-1]:.6f} eV\n")
                self.mon_info.see(tk.END)

        self.after(0, _upd)

    def on_system_update(self, stats):
        def _upd():
            self._handle_stats(stats)
            lines = []
            run_state = stats.get("run_state")
            run_pids = stats.get("run_pids", [])
            if run_state == "running" and run_pids:
                lines.append(f"运行状态：运行中 (PID {', '.join(run_pids)})")
            elif run_state == "idle":
                lines.append("运行状态：未检测到 VASP 进程")
            else:
                lines.append("运行状态：未知")
            lines.append(f"时间：{stats.get('timestamp', '-')}")
            cpu = stats.get("cpu_usage")
            if cpu is not None:
                lines.append(f"CPU 使用率：{cpu:.1f}%")
            load = stats.get("loadavg")
            if load:
                lines.append(f"平均负载：{load[0]:.2f}, {load[1]:.2f}, {load[2]:.2f}")
            lines.append("监视文件：")
            for item in stats.get("files", []):
                name = item.get("name", "-")
                if item.get("exists"):
                    size = format_bytes(item.get("size"))
                    delta = format_bytes(item.get("delta"))
                    lines.append(f"  {name}: {size} (Δ {delta})")
                else:
                    lines.append(f"  {name}: 未找到")
            procs = stats.get("processes", [])
            if procs:
                lines.append("相关进程 (前5按CPU)：")
                for p in procs:
                    mark = "★" if p.get("is_vasp") else " "
                    lines.append(
                        f" {mark} PID {p.get('pid')} {p.get('cmd')} | CPU {p.get('cpu')} | MEM {p.get('mem')}"
                    )
            else:
                lines.append("未获取到进程信息 (可能无 ps 命令或权限不足)。")
            self.sys_info.delete("1.0", tk.END)
            self.sys_info.insert(tk.END, "\n".join(lines) + "\n")

        self.after(0, _upd)

    # ------------------------- 页面：后处理 ---------------------------
    def _build_post_page(self, parent):
        frame = ttk.Frame(parent)

        # 左栏：带滚动条的控制与日志
        left_container = ttk.Frame(frame)
        left_container.pack(side=tk.LEFT, fill=tk.Y)
        left_canvas = tk.Canvas(left_container, borderwidth=0, highlightthickness=0, width=360)
        left_scroll = ttk.Scrollbar(left_container, orient=tk.VERTICAL, command=left_canvas.yview)
        left_canvas.configure(yscrollcommand=left_scroll.set)
        left_canvas.pack(side=tk.LEFT, fill=tk.Y, expand=False)
        left_scroll.pack(side=tk.RIGHT, fill=tk.Y)

        left = ttk.Frame(left_canvas, padding=8)
        left_window = left_canvas.create_window((0, 0), window=left, anchor="nw")

        def _sync_scrollregion(event):
            left_canvas.configure(scrollregion=left_canvas.bbox("all"))

        def _match_width(event):
            left_canvas.itemconfigure(left_window, width=event.width)

        left.bind("<Configure>", _sync_scrollregion)
        left_canvas.bind("<Configure>", _match_width)

        def _on_mousewheel(event):
            delta = 0
            if event.delta:
                delta = -int(event.delta / 120)
            elif event.num in (4, 5):
                delta = -1 if event.num == 4 else 1
            if delta:
                left_canvas.yview_scroll(delta, "units")
                return "break"

        for widget in (left_canvas, left):
            widget.bind("<MouseWheel>", _on_mousewheel)
            widget.bind("<Button-4>", _on_mousewheel)
            widget.bind("<Button-5>", _on_mousewheel)

        help_overview = textwrap.dedent("""
            【后处理速览】
            • 从当前项目目录读取 vasprun.xml、EIGENVAL、LOCPOT 等文件，一键生成论文级别的图表。
            • 运行任务会把 PNG/CSV 等输出写入 reports/post_时间戳/ 子目录，可随时导出或复用。
            • 勾选多个任务时将按顺序执行，避免同时解析大文件导致内存占用峰值。
        """).strip()
        self._add_section_heading(left, "一键后处理 | 论文级出图/表", help_overview, title="后处理说明", pady=(0, 6))

        row2 = ttk.Frame(left)
        row2.pack(fill=tk.X, pady=2)
        ttk.Label(row2, text="金属性阈值 DOS(E_F) ≤").pack(side=tk.LEFT)
        self.metal_threshold_var = tk.DoubleVar(value=0.02)
        ttk.Entry(row2, textvariable=self.metal_threshold_var, width=8).pack(side=tk.LEFT, padx=4)

        help_tasks = textwrap.dedent("""
            【任务清单】
            • DOS / PDOS：需要 vasprun.xml；PDOS 可按元素、轨道或前 8 个原子分组。
            • bands / bands_lbl：优先使用非自洽 vasprun.xml；若缺失则回退到 EIGENVAL+OUTCAR。
            • emass：在带边邻域做抛物线拟合，给出电子/空穴有效质量估计。
            • pot_z：读取 LOCPOT/CHGCAR，输出平面平均势沿 z 的轮廓。
        """).strip()
        tasks_box = ttk.LabelFrame(left, text="任务勾选")
        tasks_box.pack(fill=tk.X, pady=6)

        self._add_section_heading(left, "可用后处理", help_tasks, title="可用后处理", pady=(0, 4))
        task_defs = [
            ("dos", "总 DOS"),
            ("pdos", "投影 DOS"),
            ("bands", "基础能带"),
            ("bands_lbl", "能带（路径标签）"),
            ("emass", "有效质量 m*"),
            ("pot_z", "平面平均势 V(z)"),
        ]
        self._post_task_vars = {}
        for key, desc in task_defs:
            var = tk.BooleanVar(value=key in ("dos", "bands_lbl"))
            self._post_task_vars[key] = var
            ttk.Checkbutton(tasks_box, text=f"{key} — {desc}", variable=var).pack(anchor=tk.W)

        help_pdos = textwrap.dedent("""
            【PDOS 设置】
            • 运行前请确认 DOS 计算写出了投影（LORBIT=11/12）并保留 vasprun.xml。
            • “按元素/轨道/原子”会聚合不同的投影，导出的 CSV 便于后续在 Origin/Matplotlib 中再加工。
        """).strip()
        pdos_box = ttk.LabelFrame(left, text="投影选项")
        pdos_box.pack(fill=tk.X, pady=6)
        self._add_section_heading(left, "PDOS 设置", help_pdos, title="PDOS 设置", pady=(0, 4))
        self._pdos_group = tk.StringVar(value="element")
        rb_row = ttk.Frame(pdos_box)
        rb_row.pack(fill=tk.X, pady=2)
        ttk.Radiobutton(rb_row, text="按元素", variable=self._pdos_group, value="element").pack(side=tk.LEFT)
        ttk.Radiobutton(rb_row, text="按轨道", variable=self._pdos_group, value="orbital").pack(side=tk.LEFT, padx=(8, 0))
        ttk.Radiobutton(rb_row, text="按原子(前8)", variable=self._pdos_group, value="site").pack(side=tk.LEFT, padx=(8, 0))

        help_emass = textwrap.dedent("""
            【m* 拟合】
            • “窗口 ±k 点” 控制抛物线拟合使用的临近采样，默认取带边两侧各 4 个点。
            • 有效质量仅针对当前路径方向，强各向异性体系请在多个路径上重复评估。
        """).strip()
        em_box = ttk.LabelFrame(left, text="拟合参数")
        em_box.pack(fill=tk.X, pady=6)

        self._add_section_heading(left, "m* 拟合", help_emass, title="有效质量 m*", pady=(0, 4))
        ttk.Label(em_box, text="窗口 ±k 点").pack(side=tk.LEFT)
        self._em_win = tk.IntVar(value=4)
        ttk.Spinbox(em_box, from_=2, to=12, textvariable=self._em_win, width=5).pack(side=tk.LEFT, padx=4)

        help_actions = textwrap.dedent("""
            【运行与导出】
            • “运行所选” 将串行启动后台线程，完成后自动在右侧显示生成的图像预览。
            • 报告目录统一保存在项目 reports/ 下，可通过“打开报告文件夹”快速定位最新一次输出。
            • 日志窗口会记录每个任务的指标 metrics、备注 notes 以及潜在错误信息。
        """).strip()

        self._add_section_heading(left, "运行与导出", help_actions, title="运行与导出", pady=(8, 4))
        btns = ttk.Frame(left)
        btns.pack(fill=tk.X, pady=4)
        ttk.Button(btns, text="运行所选", command=self._run_selected_postprocs).pack(side=tk.LEFT)
        ttk.Button(btns, text="打开报告文件夹", command=self._open_latest_report_dir).pack(side=tk.LEFT, padx=6)
        ttk.Button(btns, text="关闭当前图页", command=self._close_current_post_tab).pack(side=tk.LEFT)

        log_frame = ttk.LabelFrame(left, text="运行日志")
        log_frame.pack(fill=tk.BOTH, expand=True, pady=(4, 0))
        self.post_metrics = ScrolledText(log_frame, height=12, wrap="word")
        self.post_metrics.pack(fill=tk.BOTH, expand=True, padx=4, pady=4)
        self.post_metrics.insert(tk.END, "运行结果与备注将在此显示。\n")
        self.post_metrics.configure(state=tk.DISABLED)

        # 右栏：图像预览
        right = ttk.Frame(frame, padding=8)
        right.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True)
        self.post_fig_area = ttk.Notebook(right)
        self.post_fig_area.pack(fill=tk.BOTH, expand=True)

        return frame

    def _run_selected_postprocs(self):
        workdir = self.current_project_path()
        ts = _dt.datetime.now().strftime("%Y%m%d-%H%M%S")
        report_dir = workdir / "reports" / f"post_{ts}"
        style = _normalize_style(self.figure_style_var.get())
        metal_th = float(self.metal_threshold_var.get() or 0.02)

        queue: list[tuple[str, Dict[str, Any]]] = []
        for key, var in self._post_task_vars.items():
            if not var.get():
                continue
            proc = POSTPROCS.get(key)
            if not proc:
                messagebox.showwarning(APP_NAME, f"未知的后处理任务：{key}")
                continue
            has_demo_payload = self.demo_mode and key in DEMO_POSTPROCS
            missing: list[str] = []
            for need in proc.needs:
                options = [n.strip() for n in need.split("|") if n.strip()]
                if not options:
                    continue
                if not any((workdir / opt).exists() for opt in options):
                    missing.append(" 或 ".join(str(workdir / opt) for opt in options))
            if missing and not has_demo_payload:
                messagebox.showwarning(APP_NAME, f"[{key}] 缺少必要文件：\n" + "\n".join(missing))
                continue
            opts: Dict[str, Any] = {
                "style": style,
                "report_dir": report_dir,
                "metal_threshold": metal_th,
                "workdir": workdir,
            }
            if key == "pdos":
                opts.update({"group": self._pdos_group.get(), "energy_window": (-6, 6)})
            if key == "emass":
                opts.update({"window_k": int(self._em_win.get())})
            if self.demo_mode:
                demo_payload = DEMO_POSTPROCS.get(key)
                if demo_payload:
                    opts["demo_payload"] = demo_payload
            queue.append((key, opts))

        if not queue:
            messagebox.showinfo(APP_NAME, "未选择可运行的后处理任务。")
            return

        for key, opts in queue:
            worker = PostprocWorker(self, key, opts)
            worker.start()

    def _open_latest_report_dir(self):
        root = self.current_project_path() / "reports"
        if not root.exists():
            messagebox.showwarning(APP_NAME, "当前项目尚未生成报告。")
            return
        try:
            latest = max((p for p in root.iterdir() if p.is_dir()), key=lambda p: p.stat().st_mtime)
        except ValueError:
            messagebox.showwarning(APP_NAME, "当前项目尚未生成报告。")
            return
        try:
            if sys.platform.startswith("darwin"):
                subprocess.Popen(["open", str(latest)])
            elif os.name == "nt":
                os.startfile(str(latest))  # type: ignore[attr-defined]
            else:
                subprocess.Popen(["xdg-open", str(latest)])
        except Exception as exc:
            messagebox.showerror(APP_NAME, f"打开目录失败：{exc}")

    def _close_current_post_tab(self):
        if not hasattr(self, "post_fig_area"):
            return
        current = self.post_fig_area.select()
        if not current:
            messagebox.showinfo(APP_NAME, "当前没有需要关闭的图页。")
            return
        self.post_fig_area.forget(current)

    def _on_postproc_success(self, key: str, result: PostResult, workdir: Path, opts: Dict[str, Any]):
        self.post_results[key] = result
        report_dir = Path(opts.get("report_dir", workdir / "reports"))
        self.post_latest_reports[key] = report_dir

        self.post_metrics.configure(state=tk.NORMAL)
        self.post_metrics.insert(tk.END, f"[{key}] 成功：{json.dumps(result.metrics, ensure_ascii=False)}\n")
        for note in result.notes:
            self.post_metrics.insert(tk.END, f"  - {note}\n")
        self.post_metrics.see(tk.END)
        self.post_metrics.configure(state=tk.DISABLED)

        for name, path in result.figs.items():
            try:
                tab = ttk.Frame(self.post_fig_area)
                fig = Figure(figsize=(5.0, 3.2))
                ax = fig.add_subplot(111)
                import matplotlib.image as mpimg

                img = mpimg.imread(str(path))
                ax.imshow(img)
                ax.axis("off")
                canvas = FigureCanvasTkAgg(fig, master=tab)
                canvas.draw()
                canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
                self.post_fig_area.add(tab, text=f"{key}:{name}")
            except Exception as exc:
                self.post_metrics.configure(state=tk.NORMAL)
                self.post_metrics.insert(tk.END, f"  ! 图像加载失败：{exc}\n")
                self.post_metrics.configure(state=tk.DISABLED)

    def _on_postproc_error(self, key: str, message: str):
        self.post_metrics.configure(state=tk.NORMAL)
        self.post_metrics.insert(tk.END, f"[{key}] 失败：{message}\n")
        self.post_metrics.see(tk.END)
        self.post_metrics.configure(state=tk.DISABLED)

    def _append_post_log(self, text: str):
        if not hasattr(self, "post_metrics"):
            return
        timestamp = time.strftime("%H:%M:%S")
        self.post_metrics.configure(state=tk.NORMAL)
        self.post_metrics.insert(tk.END, f"[{timestamp}] {text}\n")
        self.post_metrics.see(tk.END)
        self.post_metrics.configure(state=tk.DISABLED)
    def plot_once_from_oszicar(self):
        proj = self.current_project_path()
        osz = proj / "OSZICAR"
        if not osz.exists():
            messagebox.showwarning(APP_NAME, f"{osz} 不存在。")
            return
        steps, energies = [], []
        try:
            with osz.open("r", encoding="utf-8", errors="ignore") as f:
                i = 0
                for line in f:
                    m = ENERGY_RX.search(line)
                    if m:
                        val = m.group(1) or m.group(2)
                        try:
                            e = float(val)
                            i += 1
                            steps.append(i)
                            energies.append(e)
                        except Exception:
                            pass
        except Exception as e:
            messagebox.showerror(APP_NAME, f"解析失败：{e}")
            return
        # 复用监视页画布
        self.on_energy_update(steps, energies)
        self._append_post_log(f"[oszicar] 一次性绘制完成，点数：{len(steps)}")

    def extract_final_energy(self):
        proj = self.current_project_path()
        osz = proj / "OSZICAR"
        if not osz.exists():
            messagebox.showwarning(APP_NAME, f"{osz} 不存在。")
            return
        last_e = None
        try:
            for line in osz.read_text(encoding="utf-8", errors="ignore").splitlines():
                m = ENERGY_RX.search(line)
                if m:
                    val = m.group(1) or m.group(2)
                    try:
                        last_e = float(val)
                    except Exception:
                        pass
        except Exception as e:
            messagebox.showerror(APP_NAME, f"解析失败：{e}")
            return
        if last_e is None:
            messagebox.showwarning(APP_NAME, "未解析到能量。")
        else:
            self._append_post_log(f"[oszicar] 最终能量（最后一步）：{last_e:.6f} eV")

    # ------------------------- 配置读写（保存用户设置） ---------------------
    def load_config(self):
        if not CONFIG_PATH.exists():
            return
        try:
            data = json.loads(CONFIG_PATH.read_text(encoding="utf-8"))
        except Exception:
            return
        # 窗口几何
        geom = data.get("geometry")
        if geom:
            try:
                self.geometry(geom)
            except Exception:
                pass
        # 基本变量
        project_path = data.get("project", self.project_var.get())
        self.pot_dir_var.set(data.get("pot_dir", self.pot_dir_var.get()))
        self.run_mode.set(data.get("run_mode", self.run_mode.get()))
        self.vasp_cmd.set(data.get("vasp_cmd", self.vasp_cmd.get()))
        self.figure_style_var.set(_normalize_style(data.get("figure_style")))
        self.emit_report_var.set(bool(data.get("emit_report", self.emit_report_var.get())))
        try:
            self.mpi_np.set(int(data.get("mpi_np", self.mpi_np.get())))
        except Exception:
            pass
        self.file_watch_var.set(data.get("file_watch", self.file_watch_var.get()))
        # SLURM
        self.slurm_part.set(data.get("slurm_part", self.slurm_part.get()))
        self.slurm_time.set(data.get("slurm_time", self.slurm_time.get()))
        try:
            self.slurm_nodes.set(int(data.get("slurm_nodes", self.slurm_nodes.get())))
            self.slurm_ntasks.set(int(data.get("slurm_ntasks", self.slurm_ntasks.get())))
        except Exception:
            pass
        self.slurm_account.set(data.get("slurm_account", self.slurm_account.get()))
        # K 网格
        k = data.get("kgrid", {})
        for var, key in [(self.k_nx, "nx"),(self.k_ny, "ny"),(self.k_nz, "nz")]:
            try:
                var.set(int(k.get(key, var.get())))
            except Exception:
                pass
        try:
            self.k_gamma.set(bool(k.get("gamma", self.k_gamma.get())))
        except Exception:
            pass
        # 选中的页签
        try:
            idx = int(data.get("tab_index", 0))
            self.nb.select(idx)
        except Exception:
            pass
        self.set_project(project_path)

    def save_config(self):
        project_value = self.project_var.get()
        if self.demo_mode and self._pre_demo_project is not None:
            project_value = str(self._pre_demo_project)
        data = {
            "geometry": self.geometry(),
            "project": project_value,
            "pot_dir": self.pot_dir_var.get(),
            "run_mode": self.run_mode.get(),
            "vasp_cmd": self.vasp_cmd.get(),
            "mpi_np": self._int_from_var(self.mpi_np, 8),
            "figure_style": _normalize_style(self.figure_style_var.get()),
            "emit_report": bool(self.emit_report_var.get()),
            "slurm_part": self.slurm_part.get(),
            "slurm_time": self.slurm_time.get(),
            "slurm_nodes": self._int_from_var(self.slurm_nodes, 1),
            "slurm_ntasks": self._int_from_var(self.slurm_ntasks, 32),
            "slurm_account": self.slurm_account.get(),
            "kgrid": {
                "nx": self._int_from_var(self.k_nx, 5),
                "ny": self._int_from_var(self.k_ny, 5),
                "nz": self._int_from_var(self.k_nz, 5),
                "gamma": bool(self.k_gamma.get()),
            },
            "tab_index": self.nb.index("current"),
            "file_watch": self.file_watch_var.get(),
        }
        try:
            CONFIG_DIR.mkdir(parents=True, exist_ok=True)
            CONFIG_PATH.write_text(json.dumps(data, ensure_ascii=False, indent=2), encoding="utf-8")
        except Exception:
            pass

    def _register_suggestion_widget(self, widget: tk.Text):
        self.run_suggestion_widgets.append(widget)

    def current_project_path(self) -> Path:
        val = self.project_var.get()
        try:
            proj = Path(val).expanduser()
        except Exception:
            proj = Path(val)
        self.project_dir = proj
        return proj

    def apply_run_status(self, status_text: str, suggestions: list[str] | None = None):
        self.run_status_var.set(status_text)
        text = "暂无建议。"
        if suggestions:
            text = "\n".join(f"• {s}" for s in suggestions)
        for widget in self.run_suggestion_widgets:
            try:
                widget.configure(state="normal")
                widget.delete("1.0", tk.END)
                widget.insert("1.0", text)
                widget.configure(state="disabled")
            except Exception:
                pass

    def refresh_run_status(self):
        """后台采样 + 主线程更新；带防抖，确保同一时刻最多一个采样线程。"""
        proj = self.current_project_path()
        if not proj.exists():
            self.apply_run_status("⚠️ 项目目录不存在", ["请选择有效的项目路径。"])
            return

        # --- 防抖：已有一次刷新在路上，就直接跳过 ---
        if getattr(self, "_refresh_busy", False):
            return
        self._refresh_busy = True

        watch_files = [s.strip() for s in self.file_watch_var.get().split(",") if s.strip()]

        def _worker():
            try:
                stats = SystemStatsMonitor.snapshot(proj, watch_files)
            except Exception:
                stats = {"run_state": "unknown", "suggestions": ["状态刷新失败。"]}
            finally:
                # 回到主线程：更新 UI，并清除 busy 标记
                def _apply():
                    try:
                        self._handle_stats(stats)
                    finally:
                        self._refresh_busy = False

                self.after(0, _apply)

        threading.Thread(target=_worker, daemon=True).start()

    def _handle_stats(self, stats: dict):
        run_state = stats.get("run_state")
        run_pids = stats.get("run_pids", [])
        if run_state == "running" and run_pids:
            status = f"   运行中 (PID {', '.join(run_pids)})"
        elif run_state == "idle":
            status = "⚪ 未检测到 VASP 进程"
        else:
            status = "⚠️ 状态未知"
        suggestions = stats.get("suggestions") or []
        self.apply_run_status(status, suggestions)
        self.update_overview_with_file_stats(stats.get("files", []))

    def update_overview_with_file_stats(self, file_stats: list[dict]):
        tree = getattr(self, "workflow_tree", None)
        if not tree or not file_stats:
            return
        # 使用现有 iid 判断是否存在
        existing = set(tree.get_children()) | {"__project__", "INCAR", "POSCAR", "KPOINTS", "POTCAR", "CONTCAR",
                                               "vasp.out", "OSZICAR", "OUTCAR"}
        for item in file_stats:
            name = item.get("name")
            if not name:
                continue
            short = Path(name).name
            key = self.overview_key_map.get(short.lower())
            if not key or key not in existing:
                continue
            label = self.overview_label_map.get(key, short)
            if item.get("exists"):
                detail = f"大小 {format_bytes(item.get('size'))}"
                delta = item.get("delta")
                if isinstance(delta, (int, float)):
                    detail += f" | Δ {format_bytes(delta)}"
                status = "📈 输出增长" if isinstance(delta, (int, float)) and delta > 0 else "✅ 已存在"
            else:
                status = "⚠️ 未找到"
                detail = "尚未生成或路径不匹配"
            tree.item(key, values=(label, status, detail))

    def refresh_project_overview(self):
        tree = getattr(self, "workflow_tree", None)
        if not tree:
            return
        for row in tree.get_children():
            tree.delete(row)
        proj = self.current_project_path()
        exists = proj.exists()
        proj_status = "✅ 已存在" if exists else "⚠️ 未找到"
        tree.insert(
            "",
            tk.END,
            iid="__project__",
            values=(self.overview_label_map.get("__project__", "项目目录"), proj_status, str(proj)),
        )
        for key, label in self.overview_items:
            if key == "__project__":
                continue
            path = proj / key
            if path.exists():
                try:
                    stat = path.stat()
                    mtime = time.strftime("%Y-%m-%d %H:%M", time.localtime(stat.st_mtime))
                    status = "✅ 已存在"
                    detail = f"更新于 {mtime} | {format_bytes(stat.st_size)}"
                except Exception:
                    status = "✅ 已存在"
                    detail = "已检测到文件"
            else:
                status = "⚠️ 未找到"
                detail = "项目目录中未检测到该文件"
            tree.insert("", tk.END, iid=key, values=(label, status, detail))

    def load_project_inputs(self):
        proj = self.current_project_path()
        mapping = [
            (proj / "INCAR", getattr(self, "incar_text", None)),
            (proj / "POSCAR", getattr(self, "poscar_text", None)),
            (proj / "KPOINTS", getattr(self, "kpoints_text", None)),
        ]
        for path, widget in mapping:
            if not widget or not path.exists():
                continue
            try:
                widget.delete("1.0", tk.END)
                widget.insert("1.0", read_text(path))
            except Exception:
                pass

    def set_project(self, path: Path):
        try:
            path = Path(path).expanduser()
        except Exception:
            path = Path(path)
        self.project_dir = path
        self.project_var.set(str(path))
        self.load_project_inputs()
        self.refresh_project_overview()
        self.refresh_run_status()

    # ------------------------- 项目与体检 ----------------------------------
    def choose_project(self):
        d = filedialog.askdirectory(initialdir=self.project_var.get(), title="选择项目目录")
        if d:
            self.set_project(Path(d))

    def create_project(self):
        d = filedialog.askdirectory(initialdir=str(Path.home()), title="选择或创建项目父目录")
        if not d:
            return
        # 创建以时间命名的项目
        base = Path(d)
        name = time.strftime("vasp_proj_%Y%m%d_%H%M%S")
        p = base / name
        p.mkdir(parents=True, exist_ok=True)
        self.set_project(p)
        messagebox.showinfo(APP_NAME, f"已创建项目目录：{p}")

    def quick_check(self):
        proj = self.current_project_path()
        summary: list[str] = []
        issues: list[str] = []

        required = ["INCAR", "POSCAR", "POTCAR", "KPOINTS"]
        for name in required:
            path = proj / name
            exists = path.exists()
            mark = "✔" if exists else "✗"
            summary.append(f"{name:7s} : {mark} {path if exists else ''}".rstrip())
            if not exists:
                issues.append(f"未检测到 {name}，请确认是否已保存到项目目录。")

        poscar_text = ""
        poscar_path = proj / "POSCAR"
        if poscar_path.exists():
            poscar_text = read_text(poscar_path)
        else:
            poscar_text = self.poscar_text.get("1.0", tk.END).strip()

        elems = unique_elements_from_poscar(poscar_text) if poscar_text else []
        if elems:
            summary.append("POSCAR 元素: " + ", ".join(elems))
        elif poscar_text:
            issues.append("POSCAR 内容存在但未能解析元素，请检查第6/7行。")
        else:
            issues.append("POSCAR 内容为空。")

        potcar_path = proj / "POTCAR"
        if potcar_path.exists() and elems:
            pot_text = read_text(potcar_path)
            titels = [ln for ln in pot_text.splitlines() if ln.strip().startswith("TITEL")]
            if len(titels) < len(elems):
                issues.append("POTCAR 中的赝势数量少于 POSCAR 元素数量。")

        incar_path = proj / "INCAR"
        incar_text = read_text(incar_path) if incar_path.exists() else self.incar_text.get("1.0", tk.END)
        for key in ("ENCUT", "EDIFF"):
            if not re.search(rf"(?mi)^\s*{re.escape(key)}\s*=", incar_text):
                issues.append(f"INCAR 未设置 {key}，请确认输入参数。")

        for cmd in ["mpirun", self.vasp_cmd.get().strip(), "sbatch", "wsl" if os.name == "nt" else None]:
            if not cmd:
                continue
            resolved = which(cmd)
            summary.append(f"which {cmd:8s} -> {resolved or '未找到'}")
            if resolved is None and cmd not in ("sbatch", "wsl"):
                issues.append(f"未在 PATH 中找到 {cmd}，可能无法直接运行 VASP。")

        potroot = Path(self.pot_dir_var.get())
        summary.append(f"POT 库: {potroot} {'(存在)' if potroot.exists() else '(不存在)'}")
        if not potroot.exists():
            issues.append("赝势库根目录不存在，请重新设置 POTCAR 路径。")

        log_msg = "\n".join(summary)
        self.append_run_log(log_msg + "\n")
        self.refresh_project_overview()
        self.refresh_run_status()

        if issues:
            detail = "\n- " + "\n- ".join(issues)
            messagebox.showwarning(APP_NAME, f"项目体检结果：\n{log_msg}\n\n需关注：{detail}")
        else:
            messagebox.showinfo(APP_NAME, f"项目体检完成：\n{log_msg}\n\n未发现明显问题，可继续下一步。")

    # === 并行推断辅助 ===
    def _read_file_text(self, p: Path) -> str:
        try:
            return p.read_text(encoding="utf-8", errors="ignore")
        except Exception:
            return ""

    def _incar_get(self, key: str) -> int | None:
        txt = self._read_file_text(self.current_project_path() / "INCAR")
        m = re.search(rf"(?mi)^\s*{re.escape(key)}\s*=\s*([-+]?\d+)", txt)
        return int(m.group(1)) if m else None

    def _incar_upsert(self, key: str, val: int):
        """在 INCAR 中插入/更新形如 'KEY = val' 的行：
        - 匹配不区分大小写，仅替换第一处，以保留后续注释或模板段落
        - 保留原有行前缩进
        - 追加时确保文件末尾带换行
        """
        proj = self.current_project_path()
        incar = proj / "INCAR"
        txt = self._read_file_text(incar)

        # 目标行（不带末尾换行，写入时再统一补 '\n'）
        new_line = f"{key:6s} = {val}"

        # 匹配：行首可有空白，然后是 key，再等号到行尾；忽略大小写、多行模式
        # 使用命名分组 'lead' 保留原有缩进
        pattern = re.compile(rf"(?mi)^(?P<lead>\s*){re.escape(key)}\s*=.*$")

        m = pattern.search(txt)
        if m:
            # 仅替换第一处匹配，保持该行原有缩进
            def _repl(mm: re.Match) -> str:
                lead = mm.group('lead') or ''
                return f"{lead}{new_line}"

            txt = pattern.sub(_repl, txt, count=1)
            # 确保文件以换行结尾
            if not txt.endswith("\n"):
                txt += "\n"
        else:
            # 末尾补换行后再追加新行
            if txt and not txt.endswith("\n"):
                txt += "\n"
            txt += new_line + "\n"

        write_text(incar, txt)

    def _infer_nbands(self) -> int | None:
        outcar = self.current_project_path() / "OUTCAR"
        m = re.search(r"(?mi)\bNBANDS\s*=\s*(\d+)", self._read_file_text(outcar))
        return int(m.group(1)) if m else None

    def _infer_kpoints_total(self) -> int | None:
        """粗略从 KPOINTS 取 Monkhorst-Pack 网格乘积；line-mode 留空。"""
        kp = self.current_project_path() / "KPOINTS"
        s = self._read_file_text(kp).splitlines()
        if len(s) >= 4 and re.search(r"(?i)gamma|monkhorst", s[2]):
            try:
                nx, ny, nz = map(int, s[3].split()[:3])
                return max(1, nx * ny * nz)
            except Exception:
                return None
        return None

    def _best_divisor(self, n: int, choices=(8, 6, 4, 3, 2, 1)) -> int:
        for c in choices:
            if n % c == 0: return c
        return 1

    def _autotune_parallel_and_write(self, np_total: int):
        """核心：根据 -np / NBANDS / KPOINTS 推断 KPAR 与 NCORE，并写回 INCAR。"""
        # 1) 读现有设置（用户若已手动设定，尊重并只做校验）
        ncore_user = self._incar_get("NCORE")
        kpar_user = self._incar_get("KPAR")

        # 2) 粗略信息
        nbands = self._infer_nbands() or 12  # 缺省 12（小体系常见）
        ktot = self._infer_kpoints_total() or np_total  # 没法判断就放宽

        # 3) 选一个合理的 NCORE（要能整除 -np）
        ncore = ncore_user if ncore_user and np_total % ncore_user == 0 else self._best_divisor(np_total)

        # 4) 估 groups（band 并行组数），不能超过 NBANDS
        groups_max = max(1, nbands)
        # KPAR 先给个上限（不能超过总 k 点的粗略值）
        kpar_max = max(1, min(ktot, np_total // ncore))

        # 若用户指定了 KPAR 就尽量用，否则我们分配尽量多的 k 点并行
        if kpar_user:
            kpar = max(1, min(kpar_user, kpar_max))
        else:
            # 让剩余核数 /ncore 尽量落到“<= NBANDS”的组数
            # np_total = KPAR * NCORE * groups  →  groups = np_total/(KPAR*NCORE)
            kpar = kpar_max
            while kpar > 1 and np_total // (kpar * ncore) > groups_max:
                kpar -= 1
            # 还要让整除成立
            while kpar > 1 and (np_total % (kpar * ncore) != 0):
                kpar -= 1
            kpar = max(1, kpar)

        groups = max(1, np_total // (kpar * ncore))

        # 5) 写回（只有当自动模式勾选或用户未设置时才写）
        if self.auto_parallel.get() or (ncore_user is None):
            self._incar_upsert("NCORE", ncore)
        if self.auto_parallel.get() or (kpar_user is None):
            self._incar_upsert("KPAR", kpar)

        self.append_run_log(
            f"[auto-parallel] np={np_total}, 推断: NCORE={ncore}, KPAR={kpar}, groups≈{groups}, NBANDS≈{nbands}, K总≈{ktot}")

    def _plots_dir(self) -> Path:
        d = self.current_project_path() / "plots"
        d.mkdir(parents=True, exist_ok=True)
        return d

    def export_convergence(self):
        proj = self.current_project_path()
        osz = proj / "OSZICAR"
        if not osz.exists():
            messagebox.showwarning(APP_NAME, f"{osz} 不存在。");
            return
        steps, energies = [], []
        with osz.open("r", encoding="utf-8", errors="ignore") as f:
            i = 0
            for line in f:
                m = ENERGY_RX.search(line)
                if m:
                    val = m.group(1) or m.group(2)
                    try:
                        e = float(val.replace("D", "E").replace("d", "E"))
                        i += 1;
                        steps.append(i);
                        energies.append(e)
                    except:
                        pass
        if not energies:
            messagebox.showwarning(APP_NAME, "OSZICAR 未解析到能量。");
            return

        # 图
        fig = Figure(figsize=(6, 4), dpi=140);
        ax = fig.add_subplot(111)
        ax.plot(steps, energies, marker="o", linestyle="-")
        ax.set_xlabel("Ionic step");
        ax.set_ylabel("Total energy [eV]")
        ax.grid(True, linestyle=":", linewidth=0.8)
        canvas = FigureCanvasTkAgg(fig, master=self.page_post); canvas.draw()
        canvas.draw()

        out = self._plots_dir()
        png = out / "convergence.png";
        svg = out / "convergence.svg";
        csv = out / "convergence.csv"
        fig.savefig(png, bbox_inches="tight");
        fig.savefig(svg, bbox_inches="tight")
        with (csv).open("w", encoding="utf-8") as g:
            g.write("step,energy_eV\n");
            g.writelines(f"{s},{e}\n" for s, e in zip(steps, energies))
        self.post_log.insert(tk.END, f"已导出收敛图：{png}\nSVG：{svg}\nCSV：{csv}\n")

    def _fermi_from_outcar(self) -> float | None:
        m = re.search(r"(?mi)E-fermi\s*:\s*([-\d.Ee+]+)", self._read_file_text(self.current_project_path() / "OUTCAR"))
        return float(m.group(1)) if m else None

    def export_dos_total(self):
        proj = self.current_project_path()
        doscar = proj / "DOSCAR"
        if not doscar.exists():
            messagebox.showwarning(APP_NAME, "未找到 DOSCAR。请先做 DOS 计算。");
            return
        ef = self._fermi_from_outcar() or 0.0

        with doscar.open("r", encoding="utf-8", errors="ignore") as f:
            lines = f.read().splitlines()
        if len(lines) < 6:
            messagebox.showwarning(APP_NAME, "DOSCAR 文件太短。");
            return
        # 第6行起为 DOS 数据，直到 NEDOS 行数结束；简单做法：跳过前5行，直到遇到空行/非数字
        data = []
        for ln in lines[5:]:
            parts = ln.split()
            if len(parts) < 3: break
            try:
                nums = list(map(float, parts))
                data.append(nums)
            except:
                break
        if not data:
            messagebox.showwarning(APP_NAME, "未解析到 DOS 数据。");
            return

        arr = list(zip(*data))  # 转置
        E = [x - ef for x in arr[0]]
        if len(arr) >= 5:  # 自旋极化：E, DOS_up, DOS_dn, Int_up, Int_dn
            DOS = [u + d for u, d in zip(arr[1], arr[2])]
        else:  # 非极化：E, DOS, Int
            DOS = list(arr[1])

        # 图
        fig = Figure(figsize=(6, 4), dpi=140);
        ax = fig.add_subplot(111)
        ax.plot(E, DOS, linewidth=1.2)
        ax.axvline(0.0, linestyle="--", linewidth=0.8)  # EF
        ax.set_xlabel("Energy - $E_F$ (eV)");
        ax.set_ylabel("DOS (states/eV)")
        ax.grid(True, linestyle=":", linewidth=0.8)
        out = self._plots_dir()
        png = out / "dos_total.png";
        svg = out / "dos_total.svg";
        csv = out / "dos_total.csv"
        fig.savefig(png, bbox_inches="tight");
        fig.savefig(svg, bbox_inches="tight")
        with (csv).open("w", encoding="utf-8") as g:
            g.write("E-EF,DOS\n");
            g.writelines(f"{x},{y}\n" for x, y in zip(E, DOS))
        self.post_log.insert(tk.END, f"已导出 DOS：{png}\nSVG：{svg}\nCSV：{csv}\n")

    def export_bands(self):
        proj = self.current_project_path()
        eig = proj / "EIGENVAL"
        if not eig.exists():
            messagebox.showwarning(APP_NAME, "未找到 EIGENVAL。请使用 KPOINTS 路径做 band 计算。");
            return
        ef = self._fermi_from_outcar() or 0.0
        txt = self._read_file_text(eig).splitlines()

        # 头部：第6行通常包含 NKPTS, NBANDS, NIONS
        try:
            parts = txt[5].split()
            nk, nb = int(parts[0]), int(parts[1])
        except Exception:
            messagebox.showwarning(APP_NAME, "EIGENVAL 头部解析失败。");
            return

        i = 6
        kpts = []
        bands = [[] for _ in range(nb)]

        for _ in range(nk):
            # 跳过空行（有些版本每个 k-block 前有空行）
            while i < len(txt) and not txt[i].strip():
                i += 1
            if i >= len(txt):
                break

            # kx ky kz w
            try:
                kx, ky, kz, w = map(float, txt[i].split()[:4])
            except Exception:
                messagebox.showwarning(APP_NAME, "EIGENVAL k 点块格式异常。")
                return
            i += 1
            kpts.append((kx, ky, kz))

            # nb 行： bandIndex, energy, occ
            for b in range(nb):
                parts = txt[i].split()
                e = float(parts[1]) - ef
                bands[b].append(e)
                i += 1

        import math
        xs = [0.0]
        for a, b in zip(kpts[:-1], kpts[1:]):
            xs.append(xs[-1] + math.dist(a, b))

        fig = Figure(figsize=(6, 4), dpi=140)
        ax = fig.add_subplot(111)
        for b in range(nb):
            ax.plot(xs, bands[b], linewidth=0.8)
        ax.axhline(0, linestyle="--", linewidth=0.8)  # EF
        ax.set_xlabel("k-path (arb.)")
        ax.set_ylabel("Energy - $E_F$ (eV)")
        ax.grid(True, linestyle=":", linewidth=0.8)
        out = self._plots_dir()
        png, svg, csv = out / "bands.png", out / "bands.svg", out / "bands.csv"
        fig.savefig(png, bbox_inches="tight")
        fig.savefig(svg, bbox_inches="tight")
        with csv.open("w", encoding="utf-8") as g:
            g.write("k," + ",".join(f"band{b + 1}" for b in range(nb)) + "\n")
            for j in range(nk):
                row = [f"{xs[j]}"] + [f"{bands[b][j]}" for b in range(nb)]
                g.write(",".join(row) + "\n")
        self.post_log.insert(tk.END, f"已导出能带：{png}\nSVG：{svg}\nCSV：{csv}\n")

    def import_project_files(self):
        """把项目目录下的 INCAR/POSCAR/KPOINTS 一键读入三个编辑器，并刷新概览与状态。"""
        self.load_project_inputs()
        self.refresh_project_overview()
        self.refresh_run_status()
        messagebox.showinfo(APP_NAME, "已读取项目文件并刷新状态。")

    # ------------------------- 退出清理 ------------------------------------
    def on_close(self):
        try:
            # 保存配置
            self.save_config()
            # 停止监视与 tail 进程
            self.stop_monitor()
            if self.proc and self.proc.poll() is None:
                self.proc.terminate()
            self._cleanup_demo_project()
        except Exception:
            pass
        self.destroy()
        self._stop_following_log()


class FirstTimeWizard(tk.Toplevel):
    def __init__(self, master: VaspGUI):
        super().__init__(master)
        self.result: WizardProfile | None = None
        self.title("首次使用向导")
        self.transient(master)
        self.grab_set()
        self.resizable(False, False)
        # 适当扩大初始尺寸，避免表单内容被截断（尤其是第三步的精度设置）
        self.geometry("720x540")
        self.protocol("WM_DELETE_WINDOW", self.on_cancel)

        self.system_type = tk.StringVar(value="semiconductor")
        self.workflow = tk.StringVar(value="relax_scf_dos")
        self.encut_mode = tk.StringVar(value="auto")
        self.encut_value = tk.StringVar(value="520")
        self.k_mode = tk.StringVar(value="kspacing")
        self.kspacing = tk.StringVar(value="0.22")
        self.kgrid = [tk.IntVar(value=6), tk.IntVar(value=6), tk.IntVar(value=6)]
        self.use_slurm = tk.BooleanVar(value=False)
        self.np_var = tk.StringVar(value=str(max(1, master._int_from_var(master.mpi_np, 8))))
        self.slurm_part = tk.StringVar(value=master.slurm_part.get())
        self.slurm_time = tk.StringVar(value=master.slurm_time.get())
        self.slurm_nodes = tk.StringVar(value=str(master.slurm_nodes.get()))
        self.slurm_ntasks = tk.StringVar(value=str(master.slurm_ntasks.get()))
        self.slurm_account = tk.StringVar(value=master.slurm_account.get())
        self.emit_report = tk.BooleanVar(value=bool(master.emit_report_var.get()))

        container = ttk.Frame(self, padding=12)
        container.pack(fill=tk.BOTH, expand=True)
        self.step_var = tk.StringVar(value="步骤 1/5")
        ttk.Label(container, textvariable=self.step_var, font=("", 12, "bold")).pack(anchor=tk.W, pady=(0, 8))

        self.stack = ttk.Frame(container)
        self.stack.pack(fill=tk.BOTH, expand=True)
        self.pages: list[ttk.Frame] = []
        self.slurm_widgets: list[ttk.Widget] = []
        self.pages.append(self._build_system_page())
        self.pages.append(self._build_workflow_page())
        self.pages.append(self._build_precision_page())
        self.pages.append(self._build_resource_page())
        self.pages.append(self._build_output_page())

        nav = ttk.Frame(container)
        nav.pack(fill=tk.X, pady=(12, 0))
        self.btn_prev = ttk.Button(nav, text="上一步", command=self.on_prev)
        self.btn_prev.pack(side=tk.LEFT)
        self.btn_cancel = ttk.Button(nav, text="取消", command=self.on_cancel)
        self.btn_cancel.pack(side=tk.RIGHT)
        self.btn_finish = ttk.Button(nav, text="完成", command=self.on_finish)
        self.btn_finish.pack(side=tk.RIGHT, padx=6)
        self.btn_next = ttk.Button(nav, text="下一步", command=self.on_next)
        self.btn_next.pack(side=tk.RIGHT)

        self.current_index = 0
        self._update_page()
        self._center_on_parent(master)

    def _center_on_parent(self, master):
        try:
            self.update_idletasks()
            w = self.winfo_width()
            h = self.winfo_height()
            x = master.winfo_rootx() + (master.winfo_width() - w) // 2
            y = master.winfo_rooty() + (master.winfo_height() - h) // 2
            self.geometry(f"{w}x{h}+{x}+{y}")
        except Exception:
            pass

    def _build_system_page(self) -> ttk.Frame:
        frame = ttk.Frame(self.stack)
        ttk.Label(frame, text="选择体系类型：").pack(anchor=tk.W)
        options = [
            ("metal", "金属（ISMEAR=1, SIGMA≈0.2）"),
            ("semiconductor", "半导体（ISMEAR=0, SIGMA≈0.05）"),
            ("insulator", "绝缘体（ISMEAR=0, SIGMA≈0.05）"),
        ]
        for value, text in options:
            ttk.Radiobutton(frame, text=text, value=value, variable=self.system_type).pack(anchor=tk.W, pady=2)
        ttk.Label(frame, text="该设置用于推荐展宽参数。", foreground="#555555").pack(anchor=tk.W, pady=(6, 0))
        return frame

    def _build_workflow_page(self) -> ttk.Frame:
        frame = ttk.Frame(self.stack)
        ttk.Label(frame, text="选择计算流程：").pack(anchor=tk.W)
        for value, text in [
            ("relax_scf_dos", "Relax → SCF → DOS"),
            ("relax_scf_bands", "Relax → SCF → Bands"),
            ("scf_dos", "SCF → DOS"),
        ]:
            ttk.Radiobutton(frame, text=text, value=value, variable=self.workflow).pack(anchor=tk.W, pady=2)
        ttk.Label(frame, text="流程将决定生成的脚本与建议。", foreground="#555555").pack(anchor=tk.W, pady=(6, 0))
        ttk.Label(
            frame,
            text=(
                "Relax → SCF → DOS（默认）\n"
                "用于“有应力/对齐方式不确定”的结构：先几何优化，再精细自洽，最后基于该电荷做 DOS。\n"
                "可靠稳健，适合多数 2D 扭转/滑移扫描。\n\n"
                "Relax → SCF → Bands\n"
                "目标是能带路径：先 Relax，再 SCF 得到准确电荷，最后用 ICHARG=11 的 band run 走高对称线。\n"
                "适合在 DOS/带隙初筛后，对少量代表构型出图。\n\n"
                "SCF → DOS（无 Relax）\n"
                "当几何已可信或做快速预筛时可直接 SCF，随后投 DOS。速度快，但若未 Relax 可能影响能量和带隙。"
            ),
            wraplength=660,
            justify=tk.LEFT,
            foreground="#444444",
        ).pack(anchor=tk.W, pady=(8, 0))
        return frame

    def _build_precision_page(self) -> ttk.Frame:
        frame = ttk.Frame(self.stack)
        ttk.Label(frame, text="设置精度与 K 网格：").pack(anchor=tk.W)
        encut_box = ttk.LabelFrame(frame, text="ENCUT")
        encut_box.pack(fill=tk.X, pady=4)
        ttk.Radiobutton(encut_box, text="自动（1.3×ENMAX_max）", value="auto", variable=self.encut_mode, command=self._update_state).pack(anchor=tk.W)
        ttk.Radiobutton(encut_box, text="手动指定", value="manual", variable=self.encut_mode, command=self._update_state).pack(anchor=tk.W)
        row = ttk.Frame(encut_box)
        row.pack(anchor=tk.W, pady=4)
        ttk.Label(row, text="ENCUT (eV):").pack(side=tk.LEFT)
        self.encut_entry = ttk.Entry(row, textvariable=self.encut_value, width=8)
        self.encut_entry.pack(side=tk.LEFT, padx=4)
        ttk.Label(
            encut_box,
            text=(
                "自动（推荐）：ENCUT ≈ 1.3 × 元素最大 ENMAX，适合混合元素或批量扫描。\n"
                "手动：仅在做收敛测试或沿用既有基准时使用；常见半导体 450–550 eV，含 O/N/F 时 520–600 eV。"
            ),
            wraplength=640,
            justify=tk.LEFT,
            foreground="#444444",
        ).pack(anchor=tk.W, pady=(4, 0))

        k_box = ttk.LabelFrame(frame, text="K 网格")
        k_box.pack(fill=tk.X, pady=4)
        ttk.Radiobutton(k_box, text="使用 KSPACING", value="kspacing", variable=self.k_mode, command=self._update_state).pack(anchor=tk.W)
        ks_row = ttk.Frame(k_box)
        ks_row.pack(anchor=tk.W, pady=4)
        ttk.Label(ks_row, text="KSPACING:").pack(side=tk.LEFT)
        self.kspacing_entry = ttk.Entry(ks_row, textvariable=self.kspacing, width=8)
        self.kspacing_entry.pack(side=tk.LEFT, padx=4)
        ttk.Radiobutton(k_box, text="使用 Monkhorst-Pack 网格", value="kpoints", variable=self.k_mode, command=self._update_state).pack(anchor=tk.W, pady=(6, 0))
        grid_row = ttk.Frame(k_box)
        grid_row.pack(anchor=tk.W, pady=4)
        for label, var in zip(["Nx", "Ny", "Nz"], self.kgrid):
            ttk.Label(grid_row, text=label).pack(side=tk.LEFT, padx=(0, 2))
            ttk.Spinbox(grid_row, from_=1, to=24, textvariable=var, width=4).pack(side=tk.LEFT, padx=(0, 6))
        ttk.Label(
            k_box,
            text=(
                "KSPACING（推荐）：以倒空间点间距控制密度，随超胞自动缩放。\n"
                "金属/小原胞 0.18–0.22，半导体 0.22–0.30，大莫尔超胞可改为 Γ-only 并放宽到 ~0.35。\n"
                "Monkhorst-Pack：当你明确需要 Nx×Ny×Nz 网格时使用；2D 薄膜通常 Nz=1，金属可考虑取消 Γ 中心。"
            ),
            wraplength=640,
            justify=tk.LEFT,
            foreground="#444444",
        ).pack(anchor=tk.W, pady=(4, 0))
        if not HAS_SEEKPATH:
            ttk.Label(k_box, text="未检测到 seekpath，建议优先使用 KSPACING。", foreground="#aa5500").pack(anchor=tk.W, pady=(4, 0))
        return frame

    def _build_resource_page(self) -> ttk.Frame:
        frame = ttk.Frame(self.stack)
        ttk.Label(frame, text="配置资源：").pack(anchor=tk.W)
        row = ttk.Frame(frame)
        row.pack(anchor=tk.W, pady=4)
        ttk.Label(row, text="本地核数 (-np):").pack(side=tk.LEFT)
        self.np_entry = ttk.Entry(row, textvariable=self.np_var, width=6)
        self.np_entry.pack(side=tk.LEFT, padx=4)
        ttk.Checkbutton(frame, text="使用 SLURM 集群", variable=self.use_slurm, command=self._update_state).pack(anchor=tk.W, pady=(6, 4))
        slurm_box = ttk.LabelFrame(frame, text="SLURM")
        slurm_box.pack(fill=tk.X, pady=4)
        for label, var in [
            ("分区", self.slurm_part),
            ("时长", self.slurm_time),
            ("节点", self.slurm_nodes),
            ("ntasks", self.slurm_ntasks),
            ("账号", self.slurm_account),
        ]:
            r = ttk.Frame(slurm_box)
            r.pack(anchor=tk.W, pady=2)
            ttk.Label(r, text=label + "：").pack(side=tk.LEFT)
            entry = ttk.Entry(r, textvariable=var, width=12)
            entry.pack(side=tk.LEFT, padx=4)
            self.slurm_widgets.append(entry)
        if not shutil.which("squeue"):
            ttk.Label(slurm_box, text="未检测到 SLURM 命令，提交功能可能不可用。", foreground="#aa5500").pack(anchor=tk.W, pady=(4, 0))
        return frame

    def _build_output_page(self) -> ttk.Frame:
        frame = ttk.Frame(self.stack)
        ttk.Label(frame, text="输出选项：").pack(anchor=tk.W)
        ttk.Label(frame, text="图像风格固定为 AFM 期刊预设。", foreground="#555555").pack(anchor=tk.W, pady=(0, 2))
        ttk.Checkbutton(frame, text="生成复现报告", variable=self.emit_report).pack(anchor=tk.W, pady=(6, 2))
        if not HAS_PYMATGEN:
            ttk.Label(frame, text="未检测到 pymatgen，高级结构功能将关闭。", foreground="#aa5500").pack(anchor=tk.W, pady=(6, 0))
        return frame

    def _update_state(self):
        self.encut_entry.configure(state=tk.NORMAL if self.encut_mode.get() == "manual" else tk.DISABLED)
        self.kspacing_entry.configure(state=tk.NORMAL if self.k_mode.get() == "kspacing" else tk.DISABLED)
        for widget in self.slurm_widgets:
            try:
                widget.configure(state=tk.NORMAL if self.use_slurm.get() else tk.DISABLED)
            except Exception:
                pass

    def _update_page(self):
        for page in self.pages:
            page.pack_forget()
        page = self.pages[self.current_index]
        page.pack(fill=tk.BOTH, expand=True)
        self.step_var.set(f"步骤 {self.current_index + 1}/5")
        self.btn_prev.configure(state=tk.NORMAL if self.current_index > 0 else tk.DISABLED)
        if self.current_index >= len(self.pages) - 1:
            self.btn_next.configure(state=tk.DISABLED)
            self.btn_finish.configure(state=tk.NORMAL)
        else:
            self.btn_next.configure(state=tk.NORMAL)
            self.btn_finish.configure(state=tk.DISABLED)
        self._update_state()

    def _validate_page(self) -> bool:
        if self.current_index == 2 and self.k_mode.get() == "kspacing":
            try:
                float(self.kspacing.get())
            except Exception:
                messagebox.showerror(APP_NAME, "KSPACING 需为数字")
                return False
        if self.current_index == 3:
            try:
                int(self.np_var.get())
            except Exception:
                messagebox.showerror(APP_NAME, "-np 需为正整数")
                return False
        return True

    def on_next(self):
        if not self._validate_page():
            return
        if self.current_index < len(self.pages) - 1:
            self.current_index += 1
            self._update_page()

    def on_prev(self):
        if self.current_index > 0:
            self.current_index -= 1
            self._update_page()

    def on_cancel(self):
        self.result = None
        self.destroy()

    def on_finish(self):
        if not self._validate_page():
            return
        try:
            np_total = int(self.np_var.get())
            if np_total <= 0:
                raise ValueError
        except Exception:
            messagebox.showerror(APP_NAME, "-np 需为正整数")
            return
        encut_val = None
        if self.encut_mode.get() == "manual":
            try:
                encut_val = int(self.encut_value.get())
            except Exception:
                messagebox.showerror(APP_NAME, "请输入合法的 ENCUT 数值")
                return
        kspacing_val = None
        kgrid_val = None
        if self.k_mode.get() == "kspacing":
            try:
                kspacing_val = float(self.kspacing.get())
            except Exception:
                messagebox.showerror(APP_NAME, "KSPACING 需为数字")
                return
        else:
            kgrid_val = tuple(int(var.get()) for var in self.kgrid)
        slurm_cfg: Dict[str, Any] = {
            "partition": self.slurm_part.get(),
            "time": self.slurm_time.get(),
            "nodes": self._safe_int(self.slurm_nodes.get(), 1),
            "ntasks": self._safe_int(self.slurm_ntasks.get(), np_total),
            "account": self.slurm_account.get(),
        }
        profile = WizardProfile(
            system_type=self.system_type.get(),
            workflow=self.workflow.get(),
            encut_strategy=self.encut_mode.get(),
            encut_value=encut_val,
            k_mode=self.k_mode.get(),
            kspacing=kspacing_val,
            kgrid=kgrid_val,
            use_slurm=bool(self.use_slurm.get()),
            np=np_total,
            slurm=slurm_cfg,
            figure_style="AFM",
            emit_report=bool(self.emit_report.get()),
        )
        self.result = profile
        self.destroy()

    def _safe_int(self, value: str, default: int) -> int:
        try:
            num = int(value)
            return num if num > 0 else default
        except Exception:
            return default


if __name__ == "__main__":
    app = VaspGUI()
    app.mainloop()

